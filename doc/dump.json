[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/config/defaultParameters/index.js",
    "memberof": null,
    "longname": "src/config/defaultParameters/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "export default require('./defaultParameters.json');\n"
  },
  {
    "__docId__": 1,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/connectors/filesystem/index.js",
    "memberof": null,
    "longname": "src/connectors/filesystem/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Filesystem connector\n * @module connectors/filesystem\n */\n\nimport fs, {\n  readFile,\n  readdir,\n  lstatSync,\n  mkdir,\n  exists,\n  writeFile,\n  unlink\n} from 'fs';\nimport {\n  resolve,\n  extname,\n  basename,\n  join as joinPath\n} from 'path';\nimport {map as asyncMap, reduce as asyncReduce} from 'async';\n// import removeFolderRecursively from 'rmdir';\n\nconst removeFolderRecursively = function(path) {\n  if ( fs.existsSync(path) ) {\n    fs.readdirSync(path).forEach(function(file, index) {\n      const curPath = path + '/' + file;\n      if (fs.lstatSync(curPath).isDirectory()) { // recurse\n        removeFolderRecursively(curPath);\n      } else {\n        // delete file\n        fs.unlinkSync(curPath);\n      }\n    });\n    fs.rmdirSync(path);\n  }\n};\n\n// I get meta information about an fs element\nconst analyseElement = (fileName, absPath) =>{\n  const path = joinPath(absPath, fileName);\n  return {\n    name: fileName,\n    path,\n    type: (lstatSync(path).isDirectory()) ? 'directory' : 'file',\n    extname: extname(path)\n  };\n};\n\n// I get meta information about several fs elements\nconst analyseContents = (filesList, absPath) =>{\n  if (!filesList) {\n    return undefined;\n  }\n  return filesList.map((fileName) => {\n    return analyseElement(fileName, absPath);\n  });\n};\n\n\n// I recursively parse an fs element\nconst parseElement = ({path = '', element, parseFiles, depth, actualDepth, acceptedExtensions}, callback) =>{\n  // file to parse\n  if (element.type === 'file' && parseFiles === true && acceptedExtensions.indexOf(element.extname) > -1) {\n    try {\n      readFile(path, 'utf8', function(err, str) {\n        if (err) {\n          return callback(err, undefined);\n        }\n        return callback(null, Object.assign({}, element, {stringContents: str}));\n      });\n    } catch (exception) {\n      callback(null, element);\n    }\n  // dir to parse\n  } else if (element.type === 'directory' && (actualDepth < depth || depth === true)) {\n    readdir(element.path + '/', function(err, files) {\n      const children = analyseContents(files, path)\n                      .filter((child)=>{\n                        return child.type === 'directory' || acceptedExtensions.indexOf(child.extname) > -1;\n                      });\n      const newDepth = actualDepth + 1;\n      asyncMap(children, function(elem, colback) {\n        parseElement({element: elem, path: path + '/' + elem.name, parseFiles, depth, actualDepth: newDepth, acceptedExtensions}, colback);\n      }, function(error, otherChildren) {\n        return callback(error, Object.assign({}, element, {children: otherChildren}));\n      });\n    });\n  // default return element as it was input\n  } else {\n    return callback(null, Object.assign({}, element));\n  }\n};\n\n/**\n * Reads a file from a certain path (cRud)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {number} requestParams.depth - if the target is a \"folder\" that contains other \"subfolders\", specifies the parsing level\n * @param {boolean} requestParams.parseFiles - Whether to parse files if the target is a \"folder\"\n * @param {Array|string} obj.acceptedExtensions - The list of accepted files extensions (or \"*\") if all must be accepted\n * @param {function(error: error)} callback - returns error and a filesystem representation of the file metadata and contents\n */\nexport const readFromPath = ({\n    path = [],\n    params,\n    depth = 1,\n    parseFiles = false,\n    acceptedExtensions = ['.md', '.bib', '.css', '.js']\n  }, callback) =>{\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  let element;\n  const name = basename(finalPath);\n\n  try {\n    element = {\n      name: name,\n      path: finalPath,\n      type: (lstatSync(finalPath).isDirectory()) ? 'directory' : 'file',\n      extname: extname(name)\n    };\n  }catch (err) {\n    return callback(err, undefined);\n  }\n\n  if (element.type === 'directory') {\n    return parseElement({path: finalPath, element, parseFiles, depth, actualDepth: 0, acceptedExtensions}, callback);\n  } else if (acceptedExtensions === '*' || acceptedExtensions.indexOf(element.extname) > -1) {\n    readFile(finalPath, 'utf8', (err, str) => {\n      if (err) {\n        return callback(err, undefined);\n      }\n      return callback(null, Object.assign({}, element, {stringContents: str}));\n    });\n  } else {\n    return callback(new Error('the file extension is not accepted'), undefined);\n  }\n};\n\n/**\n * Creates a file from a certain path and possibly some contents (Crud)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {string} requestParams.stringContents - the contents to be created\n * @param {boolean} requestParams.overwrite - Whether to overwrite existing entity already present at path\n * @param {function(error: error, returnedPath: string)} callback - returns error and the path of created entity\n */\nexport const createFromPath = ({path = '', params, type = 'file', stringContents = '', overwrite = false}, callback) =>{\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  const pathSteps = finalPath.split('/').filter((thatPath)=> {return thatPath.length > 0;});\n  // first check-or-create path folders\n  const activePath = '/';\n  asyncReduce(pathSteps, activePath, (inputMemo, pathStep, cback) =>{\n    // case : not end of path, walking through\n    if (pathStep !== pathSteps[pathSteps.length - 1]) {\n      const memo = inputMemo + pathStep + '/';\n      exists(memo, function(isThere) {\n        if (isThere) {\n          cback(null, memo);\n        }else {\n          mkdir(memo, function(err) {\n            cback(err, memo);\n          });\n        }\n      });\n    // case : end of path\n    } else {\n      cback(null, inputMemo + pathStep);\n    }\n\n  }, (err, result) =>{\n    // check if element already exists\n    exists(finalPath, function(isThere) {\n      if ((isThere && overwrite === true) || !isThere) {\n        if (type === 'file') {\n          writeFile(finalPath, stringContents, 'utf8', function(error) {\n            callback(error);\n          });\n        }else if (type === 'directory') {\n          mkdir(finalPath, function(error) {\n            callback(error);\n          });\n        }else {\n          callback(new Error('No element type matching'));\n        }\n      }else {\n        callback(new Error('File/directory already exists and overwrite option is set to false'));\n      }\n    });\n  });\n};\n\n/**\n * Updates a file from a certain path and possibly some contents (crUd)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {string} requestParams.stringContents - the contents to be created\n * @param {function(error: error)} callback - returns possible error\n */\nexport const updateFromPath = ({path = '', params, stringContents = ''}, callback) => {\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath + '/' + resolvedPath);\n  exists(finalPath, (isThere) =>{\n    if (isThere) {\n      const pathSteps = finalPath.split('/').filter((thatPath)=> {return thatPath.length > 0;});\n      const elementName = pathSteps.pop();\n      const element = analyseElement(elementName, '/' + pathSteps.join('/'));\n      if (element.type === 'directory') {\n        callback(new Error('cannot update directories'));\n      } else if (element.type === 'file') {\n        writeFile(finalPath, stringContents, (err) =>{\n          callback(err);\n        });\n      }\n    }else {\n      callback(new Error('Path does not exists'));\n    }\n  });\n};\n\n/**\n * Deletes a file from a certain path and possibly some contents (cruD)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {function(error: error)} callback - returns potential errors\n */\nexport const deleteFromPath = ({path = '', params}, callback) => {\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  exists(finalPath, function(isThere) {\n    if (isThere) {\n      const pathSteps = finalPath.split('/').filter((thatPath) => {return thatPath.length > 0;});\n      const elementName = pathSteps.pop();\n      const element = analyseElement(elementName, '/' + pathSteps.join('/'));\n      if (element.type === 'directory') {\n        removeFolderRecursively(finalPath /*\n        , (err) =>{\n          callback(err);\n        }\n        */);\n        callback(null);\n      }else if (element.type === 'file') {\n        unlink(finalPath, (err) =>{\n          callback(err);\n        });\n      }\n    }else {\n      callback(new Error('Path does not exists'));\n    }\n  });\n};\n\n/**\n * Gets the absolute uri of an asset\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {function(error: error, finalPath: string)} callback - returns error and the asset's uri\n * @todo question : should it check for resource availability ?\n */\nexport const getAssetUri = ({path, params}, callback) => {\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  return callback(null, finalPath);\n};\n"
  },
  {
    "__docId__": 2,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "removeFolderRecursively",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~removeFolderRecursively",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 3,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "analyseElement",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~analyseElement",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "analyseContents",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~analyseContents",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseElement",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~parseElement",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "readFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~readFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{readFromPath}",
    "description": "Reads a file from a certain path (cRud)",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.depth",
        "description": "if the target is a \"folder\" that contains other \"subfolders\", specifies the parsing level"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.parseFiles",
        "description": "Whether to parse files if the target is a \"folder\""
      },
      {
        "nullable": null,
        "types": [
          "Array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.acceptedExtensions",
        "description": "The list of accepted files extensions (or \"*\") if all must be accepted"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns error and a filesystem representation of the file metadata and contents"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~createFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{createFromPath}",
    "description": "Creates a file from a certain path and possibly some contents (Crud)",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.stringContents",
        "description": "the contents to be created"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.overwrite",
        "description": "Whether to overwrite existing entity already present at path"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, returnedPath: string)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns error and the path of created entity"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~updateFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{updateFromPath}",
    "description": "Updates a file from a certain path and possibly some contents (crUd)",
    "lineNumber": 208,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.stringContents",
        "description": "the contents to be created"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns possible error"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 9,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "deleteFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~deleteFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{deleteFromPath}",
    "description": "Deletes a file from a certain path and possibly some contents (cruD)",
    "lineNumber": 237,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns potential errors"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getAssetUri",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~getAssetUri",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{getAssetUri}",
    "description": "Gets the absolute uri of an asset",
    "lineNumber": 272,
    "todo": [
      "question : should it check for resource availability ?"
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, finalPath: string)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns error and the asset's uri"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/citation/index.js",
    "memberof": null,
    "longname": "src/contextualizers/citation/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Citation contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/citation\n */\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputSection, inputContextualization, settings) => {\n  const contextualization = Object.assign({}, inputContextualization);\n  const formatter = require('./../../referencers/' + settings.citationStyle + '.js');\n  const node = contextualization.node;\n  const props = {\n    contextualization,\n    resource: contextualization.resources[0],\n    ibid: contextualization.sectionIbid,\n    opCit: contextualization.sectionOpCit\n  };\n  // citation text --> wrap in span > q + citation\n  if (node.child) {\n    const citation = {\n      node: 'element',\n      special: true,\n      tag: formatter.InlineCitation,\n      props\n    };\n    const child = node.child.slice();\n    const quote = {\n      attr: {\n        class: 'peritext-quote-container',\n        id: contextualization.citeKey\n      },\n      node: 'element',\n      tag: 'q',\n      child\n    };\n    node.node = 'element';\n    node.tag = 'span';\n    node.child = [\n      quote,\n      {\n        node: 'text',\n        text: ' ('\n      },\n      citation,\n      {\n        node: 'text',\n        text: ')'\n      }\n    ];\n  } else {\n    node.special = true;\n    node.tag = formatter.InlineCitation;\n    node.props = props;\n  }\n  return Object.assign({}, inputSection);\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputSection, inputContextualization, settings) => {\n  const contextualization = Object.assign({}, inputContextualization);\n  const formatter = require('./../../referencers/' + settings.citationStyle + '.js');\n  const node = contextualization.node;\n  const props = {\n    contextualization,\n    resource: contextualization.resources[0],\n    ibid: contextualization.sectionIbid,\n    opCit: contextualization.sectionOpCit\n  };\n  node.special = true;\n  node.tag = formatter.BlockCitation;\n  node.props = props;\n  return Object.assign({}, inputSection);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (section, contextualization, settings) => {\n  return section;\n};\n\n/**\n * Handle an block contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (section, contextualization, settings) => {\n  return section;\n};\n"
  },
  {
    "__docId__": 12,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 13,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 15,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle an block contextualization for dynamic outputs",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 16,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/glossary/StaticEntityBlock.js",
    "memberof": null,
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n// let styles = {};\nimport {bibToSchema} from './../../core/utils/microDataUtils';\n\n/**\n * dumb component and placeholder for rendering the structured representation of an entity long citation (in a glossary for example)\n */\n@Radium\nexport default class StaticEntityBlock extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} entity - the entity resource to contextualize\n   * @property {object} contextualizer - the contextualizer params to use for contextualization\n   * @property {object} contextualization - the contextualization object\n   * @property {object} settings - the set of settings to use for rendering\n   */\n  static propTypes = {\n    entity: PropTypes.object,\n    contextualizer: PropTypes.object,\n    contextualization: PropTypes.object,\n    settings: PropTypes.object\n  };\n\n  static defaultProps = {\n    contextualizer: {\n      showdescription: 'yes'\n    }\n  };\n\n  /**\n   * render a structured representation of the entities mentions, sorted by aliases\n   * @return {ReactElement} markup\n   */\n  renderMentions() {\n    const self = this;\n    return Object.keys(this.props.entity.aliases).map(function(alias, aliasIndex) {\n      return (<p key={alias} className=\"peritext-static-entity-block-page-mentions-container\">\n        <span>{alias === 'no-alias' ? '' : alias + ' : '}</span>\n        {self.props.entity.aliases[alias].map((entry, index)=> {\n          return (<span key={entry.mentionId}>\n              p. <a className=\"peritext-static-entity-block-page-pointer\" href={entry.mentionId}></a>\n            </span>);\n        }).reduce((accu, elem) => {\n          return accu === null ? [elem] : [...accu, ', ', elem];\n        }, null)}\n      </p>);\n    });\n  }\n\n  /**\n   * render component\n   * @return {ReactElement} markup\n   */\n  render() {\n    const itemType = bibToSchema(this.props.entity.bibType);\n    return (\n      <section\n        className=\"peritext-static-entity-block-container\"\n        name={'peritext-static-entity-block-' + this.props.entity.citeKey}\n        id={'peritext-static-entity-block-' + this.props.entity.citeKey}\n        itemProp=\"mentions\"\n        value=\"mentions\"\n        itemScope\n        itemType={'http://schema.org/' + itemType}\n        typeof={itemType}\n        resource={this.props.entity.citeKey}\n      >\n        <h5\n          className=\"peritext-static-entity-block-name\">\n          {itemType === 'Person' ?\n            [<span\n              itemProp=\"familyName\"\n              property=\"familyName\"\n              key=\"familyName\"\n            >{this.props.entity.lastname}</span>,\n            <span key=\"separator1\"> (</span>,\n            <span\n              itemProp=\"givenName\"\n              property=\"givenName\"\n              key=\"givenName\"\n            >{this.props.entity.firstname}</span>,\n            <span key=\"separator2\">)</span>]\n            :\n            <span\n              property=\"name\"\n              itemProp=\"name\"\n            >{this.props.entity.name}</span>\n          }\n        </h5>\n\n        {this.props.entity.aliases ?\n            this.renderMentions()\n            : ''}\n\n        {this.props.entity.description && this.props.contextualizer.showdescription === 'yes' ?\n          <p className=\"peritext-static-entity-block-description\">\n            {this.props.entity.description}\n          </p>\n          : ''}\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 17,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEntityBlock",
    "memberof": "src/contextualizers/glossary/StaticEntityBlock.js",
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/StaticEntityBlock.js",
    "importStyle": "StaticEntityBlock",
    "description": "dumb component and placeholder for rendering the structured representation of an entity long citation (in a glossary for example)",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 18,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderMentions",
    "memberof": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock",
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock#renderMentions",
    "access": null,
    "description": "render a structured representation of the entities mentions, sorted by aliases",
    "lineNumber": 36,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 19,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock",
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock#render",
    "access": null,
    "description": "render component",
    "lineNumber": 56,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 20,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/glossary/StaticEntityInline.js",
    "memberof": null,
    "longname": "src/contextualizers/glossary/StaticEntityInline.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\nimport {bibToSchema} from './../../core/utils/microDataUtils';\n// let styles = {};\nimport renderContents from './../../core/utils/componentsFactory';\n\n/**\n * dumb component and placeholder for rendering the structured representation of an entity citation\n */\n@Radium\nexport default class StaticEntityInline extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} entity - the entity resource to contextualize\n   * @property {string} sectionCiteKey - the host section citeKey (used for identifying the element)\n   * @property {object} contextualization - the contextualization object\n   * @property {array} contents - the pseudo-dom js representation of contextualization's pointer contents\n   */\n  static propTypes = {\n    entity: PropTypes.object,\n    sectionCiteKey: PropTypes.string,\n    contextualization: PropTypes.object,\n    contents: PropTypes.array\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const itemType = bibToSchema(this.props.entity.bibType);\n    return (\n      <a\n        className=\"peritext-static-entity-container-inline\"\n        name={'peritext-content-entity-inline-' + this.props.sectionCiteKey + '-' + this.props.contextualization.citeKey}\n        id={'peritext-static-entity-inline-' + this.props.sectionCiteKey + '-' + this.props.contextualization.citeKey}\n        href={'#peritext-static-entity-block-' + this.props.entity.citeKey}\n        itemProp=\"mentions\"\n        value=\"mentions\"\n        itemScope\n        itemType={'http://schema.org/' + itemType}\n        typeof={itemType}\n        resource={this.props.entity.citeKey}\n      >\n        {itemType === 'Person' ?\n          [<span\n            style={{display: 'none'}}\n            itemProp=\"givenName\"\n            property=\"givenName\"\n            key=\"givenName\"\n          >{this.props.entity.firstname}</span>,\n          <span\n            style={{display: 'none'}}\n            itemProp=\"familyName\"\n            property=\"familyName\"\n            key=\"familyName\"\n          >{this.props.entity.lastname}</span>]\n          :\n          <span\n            style={{display: 'none'}}\n            property=\"name\"\n            itemProp=\"name\"\n          >{this.props.entity.name}</span>\n        }\n        <span>{renderContents(this.props.contents)}</span>\n      </a>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 21,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEntityInline",
    "memberof": "src/contextualizers/glossary/StaticEntityInline.js",
    "longname": "src/contextualizers/glossary/StaticEntityInline.js~StaticEntityInline",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/StaticEntityInline.js",
    "importStyle": "StaticEntityInline",
    "description": "dumb component and placeholder for rendering the structured representation of an entity citation",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 22,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/glossary/StaticEntityInline.js~StaticEntityInline",
    "longname": "src/contextualizers/glossary/StaticEntityInline.js~StaticEntityInline#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 23,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/glossary/index.js",
    "memberof": null,
    "longname": "src/contextualizers/glossary/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Glossary contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/glossary\n */\n\nimport StaticEntityInline from './StaticEntityInline.js';\nimport StaticEntityBlock from './StaticEntityBlock.js';\nimport {getMetaValue} from './../../core/utils/sectionUtils';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputSection, inputContextualization, settings) => {\n  const section = Object.assign({}, inputSection);\n  const contextualization = Object.assign({}, inputContextualization);\n  const node = contextualization.node;\n  const sectionCiteKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  const entity = contextualization.resources[0];\n  let contents = node.child;\n  if (!contents || (contents[0] && contents[0].text.trim().length === 0)) {\n    contents = contextualization.contextualizer.alias || entity.name || entity.firstname + ' ' + entity.lastname;\n    contents = [{\n      node: 'text',\n      text: contents\n    }];\n  }\n  node.props = {\n    contextualization,\n    entity,\n    contents,\n    sectionCiteKey\n  };\n  node.special = true;\n  node.tag = StaticEntityInline;\n  return Object.assign({}, inputSection);\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputSection, inputContextualization, settings) => {\n  const contextualization = Object.assign({}, inputContextualization);\n  const node = contextualization.node;\n  const entity = contextualization.resources[0];\n  node.props = {\n    entity,\n    contextualization,\n    settings\n  };\n  node.special = true;\n  node.tag = StaticEntityBlock;\n  return Object.assign({}, inputSection);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (section, contextualization, settings) => {\n  return section;\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (section, contextualization, settings) => {\n  return section;\n};\n"
  },
  {
    "__docId__": 24,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 25,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 27,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/imagegallery/StaticImageGallery.js",
    "memberof": null,
    "longname": "src/contextualizers/imagegallery/StaticImageGallery.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {StaticImageFigure} from './../../core/components';\n// let styles = {};\n\nimport renderContents from './../../core/utils/componentsFactory';\nimport Radium from 'radium';\n\n/**\n * dumb static-oriented component for displaying an image gallery\n */\n@Radium\nexport default class StaticImageGallery extends React.Component {\n  /**\n   * propTypes\n   * @property {string} schematype - html schema type of the element\n   * @property {array} resources - array of resources used\n   * @property {string} captionContent - what to display as caption\n   * @property {number} figureNumber - in static mode, the number of the figure\n   * @property {string} id - the id to use in order to label the figure\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resources: PropTypes.array,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'ImageGallery',\n    comment: ''\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n            <figure\n              role=\"group\"\n              className=\"peritext-static-image-gallery-container peritext-figure-container\"\n              itemScope\n              itemProp=\"citation\"\n              itemType={'http://schema.org/' + this.props.schematype}\n              typeof={this.props.schematype}\n              resource={this.props.figureNumber ? 'peritext-figure-' + this.props.figureNumber : undefined }\n              id={'peritext-figure-' + this.props.id}\n            >\n              <div className=\"peritext-static-image-gallery-figures-wrapper\">\n                {this.props.resources.map((resource)=>{\n                  return <StaticImageFigure resource={resource} key={resource.citeKey} />;\n                })}\n              </div>\n              <figcaption\n                itemProp=\"description\"\n                property=\"description\">\n                  <span className=\"peritext-figure-marker\">\n                    Figure <span className=\"peritext-figure-number\">{this.props.figureNumber}</span>\n                  </span>\n                  <span> – </span>\n                  <span className=\"peritext-figure-caption-content\">\n                    {renderContents(this.props.captionContent)}\n                  </span>\n              </figcaption>\n            </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 29,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticImageGallery",
    "memberof": "src/contextualizers/imagegallery/StaticImageGallery.js",
    "longname": "src/contextualizers/imagegallery/StaticImageGallery.js~StaticImageGallery",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/StaticImageGallery.js",
    "importStyle": "StaticImageGallery",
    "description": "dumb static-oriented component for displaying an image gallery",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 30,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/imagegallery/StaticImageGallery.js~StaticImageGallery",
    "longname": "src/contextualizers/imagegallery/StaticImageGallery.js~StaticImageGallery#render",
    "access": null,
    "description": "render",
    "lineNumber": 38,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 31,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/imagegallery/index.js",
    "memberof": null,
    "longname": "src/contextualizers/imagegallery/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Image gallery contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/imagegallery\n */\n\nimport StaticImageGallery from './StaticImageGallery.js';\nimport {getMetaValue} from './../../core/utils/sectionUtils';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputSection, inputContextualization, settings) => {\n  const section = Object.assign({}, inputSection);\n  const contextualization = Object.assign({}, inputContextualization);\n  const citeKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  const node = contextualization.node;\n  const blockIndex = node.blockIndex;\n  let figureId;\n  let number;\n  const contents = node.child;\n  // figure is not there yet, add it\n  if (!contextualization.sectionOpCit) {\n    section.figuresCount ++;\n    figureId = citeKey + '-' + contextualization.citeKey;\n    contextualization.figureId = figureId;\n    contextualization.figureNumber = section.figuresCount;\n    const figure = {\n      node: 'element',\n      special: true,\n      tag: StaticImageGallery,\n      props: {\n        resources: contextualization.resources,\n        captionContent: [{\n          node: 'text',\n          text: contextualization.title || contextualization.resources[0].title\n        }],\n        figureNumber: contextualization.figureNumber,\n        id: figureId\n      }\n    };\n    number = contextualization.figureNumber;\n    if (settings.figuresPosition === 'inline') {\n      section.contents.splice(blockIndex + section.figuresCount, 0, figure);\n    } else {\n      section.figures = section.figures ? section.figures.concat(figure) : [figure];\n    }\n  } else {\n    figureId = citeKey + '-' + contextualization.precursorCiteKey;\n    section.contextualizations.some(cont =>{\n      if (cont.citeKey === contextualization.precursorCiteKey) {\n        number = cont.figureNumber;\n        return true;\n      }\n    });\n  }\n  const displayId = '#peritext-figure-' + figureId;\n  const newContents = [\n    ...contents.slice(),\n    {\n      node: 'text',\n      text: ' ('\n    },\n    {\n      node: 'element',\n      tag: 'a',\n      attr: {\n        href: displayId\n      },\n      child: [\n        {\n          node: 'text',\n          text: 'figure ' + number\n        }\n      ]\n    },\n    {\n      node: 'text',\n      text: ') '\n    }\n  ];\n  node.tag = 'span';\n  node.child = newContents;\n  section.contextualizations = section.contextualizations.map(cont=> {\n    if (cont.citeKey === contextualization.citeKey) {\n      return contextualization;\n    }\n    return cont;\n  });\n  return Object.assign({}, section);\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputSection, inputContextualization, settings) => {\n  const section = Object.assign({}, inputSection);\n  const contextualization = Object.assign({}, inputContextualization);\n  const citeKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  const node = contextualization.node;\n  const blockIndex = node.blockIndex;\n  let figureId;\n  section.figuresCount ++;\n  figureId = citeKey + '-' + contextualization.citeKey;\n  contextualization.figureId = figureId;\n  contextualization.figureNumber = section.figuresCount;\n  const figure = {\n    node: 'element',\n    special: true,\n    tag: StaticImageGallery,\n    props: {\n      resources: contextualization.resources,\n      captionContent: node.child[0].child,\n      figureNumber: contextualization.figureNumber,\n      id: figureId\n    }\n  };\n  if (settings.figuresPosition === 'inline') {\n    section.contents[blockIndex + section.figuresCount - 1] = figure;\n  } else {\n    section.figures = section.figures ? section.figures.concat(figure) : [figure];\n  }\n  section.contextualizations = section.contextualizations.map(cont=> {\n    if (cont.citeKey === contextualization.citeKey) {\n      return contextualization;\n    }\n    return cont;\n  });\n  return Object.assign({}, section);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (section, contextualization, settings) => {\n  return section;\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (section, contextualization, settings) => {\n  return section;\n};\n"
  },
  {
    "__docId__": 32,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 33,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 34,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 35,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 157,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/index.js",
    "memberof": null,
    "longname": "src/contextualizers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Contextualizers - pure functions that resolve sections against contextualizations+settings objects\n * @module contextualizers\n */\nimport * as citationLib from './citation';\nimport * as timelineLib from './timeline';\nimport * as imagegalleryLib from './imagegallery';\nimport * as webpageLib from './webpage';\nimport * as glossaryLib from './glossary';\nimport * as tableLib from './table';\n\n/**\n * Citation contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const citation = citationLib;\n/**\n * Timeline contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const timeline = timelineLib;\n/**\n * Image gallery contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const imagegallery = imagegalleryLib;\n/**\n * Webpage contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const webpage = webpageLib;\n/**\n * Glossary contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const glossary = glossaryLib;\n/**\n * Table contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const table = tableLib;\n"
  },
  {
    "__docId__": 37,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "citation",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~citation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{citation}",
    "description": "Citation contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 15,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "timeline",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~timeline",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{timeline}",
    "description": "Timeline contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 39,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "imagegallery",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~imagegallery",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{imagegallery}",
    "description": "Image gallery contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 40,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "webpage",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~webpage",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{webpage}",
    "description": "Webpage contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 27,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 41,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "glossary",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~glossary",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{glossary}",
    "description": "Glossary contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 31,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 42,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "table",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~table",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{table}",
    "description": "Table contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 35,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 43,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/table/StaticTable.js",
    "memberof": null,
    "longname": "src/contextualizers/table/StaticTable.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n// let styles = {};\nimport renderContents from './../../core/utils/componentsFactory';\nimport Radium from 'radium';\n\n\n/**\n * dumb static-oriented component for displaying a table\n */\n@Radium\nexport default class StaticTable extends React.Component {\n  /**\n   * propTypes\n   * @property {string} schematype - html schema type of the element\n   * @property {array} resources - array of resources used\n   * @property {string} captionContent - what to display as caption\n   * @property {number} figureNumber - in static mode, the number of the figure\n   * @property {object} data - the resource data to use\n   * @property {string} id - the id to use for identifying the contextualization\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resources: PropTypes.array,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number,\n    data: PropTypes.object,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'Dataset',\n    comment: ''\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const headers = Object.keys(this.props.data.data[0]);\n    const objects = this.props.data.data;\n    return (\n            <figure\n              role=\"group\"\n              className=\"peritext-static-table-container peritext-figure-container\"\n              itemScope\n              itemProp=\"citation\"\n              itemType={'http://schema.org/' + this.props.schematype}\n              typeof={this.props.schematype}\n              resource={this.props.figureNumber ? 'peritext-figure-' + this.props.figureNumber : undefined }\n              id={'peritext-figure-' + this.props.id}\n            >\n              <table className=\"peritext-static-table-table\">\n                <thead>\n                  <tr>\n                    {headers.map((header, index)=>{\n                      return <th key={index}>{header}</th>;\n                    })}\n                  </tr>\n                </thead>\n                <tbody>\n                  {objects.map((object, oIndex)=>{\n                    return (<tr key={oIndex}>\n                      {headers.map((header, hIndex)=>{\n                        return <th key={hIndex}>{object[header]}</th>;\n                      })}\n                    </tr>);\n                  })}\n                </tbody>\n              </table>\n              <figcaption\n                itemProp=\"description\"\n                property=\"description\">\n                  <span className=\"peritext-figure-marker\">\n                    Figure <span className=\"peritext-figure-number\">{this.props.figureNumber}</span>\n                  </span>\n                  <span> – </span>\n                  <span className=\"peritext-figure-caption-content\">\n                    {renderContents(this.props.captionContent)}\n                  </span>\n              </figcaption>\n            </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 44,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTable",
    "memberof": "src/contextualizers/table/StaticTable.js",
    "longname": "src/contextualizers/table/StaticTable.js~StaticTable",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/StaticTable.js",
    "importStyle": "StaticTable",
    "description": "dumb static-oriented component for displaying a table",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 45,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/table/StaticTable.js~StaticTable",
    "longname": "src/contextualizers/table/StaticTable.js~StaticTable#render",
    "access": null,
    "description": "render",
    "lineNumber": 39,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 46,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/table/index.js",
    "memberof": null,
    "longname": "src/contextualizers/table/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Table contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/table\n */\n\nimport StaticTable from './StaticTable.js';\nimport {getMetaValue} from './../../core/utils/sectionUtils';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputSection, inputContextualization, settings) => {\n  const section = Object.assign({}, inputSection);\n  const contextualization = Object.assign({}, inputContextualization);\n  const citeKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  const data = section.data[contextualization.resources[0].citeKey];\n  const node = contextualization.node;\n  const blockIndex = node.blockIndex;\n  let figureId;\n  let number;\n  const contents = node.child;\n  // figure is not there yet, add it\n  if (!contextualization.sectionOpCit) {\n    section.figuresCount ++;\n    figureId = citeKey + '-' + contextualization.citeKey;\n    contextualization.figureId = figureId;\n    contextualization.figureNumber = section.figuresCount;\n    const figure = {\n      node: 'element',\n      special: true,\n      tag: StaticTable,\n      props: {\n        resources: contextualization.resources,\n        data,\n        captionContent: [{\n          node: 'text',\n          text: contextualization.title || contextualization.resources[0].title\n        }],\n        figureNumber: contextualization.figureNumber,\n        id: figureId\n      }\n    };\n    number = contextualization.figureNumber;\n    if (settings.figuresPosition === 'inline') {\n      section.contents.splice(blockIndex + section.figuresCount, 0, figure);\n    } else {\n      section.figures = section.figures ? section.figures.concat(figure) : [figure];\n    }\n  } else {\n    figureId = citeKey + '-' + contextualization.precursorCiteKey;\n    section.contextualizations.some(cont =>{\n      if (cont.citeKey === contextualization.precursorCiteKey) {\n        number = cont.figureNumber;\n        return true;\n      }\n    });\n  }\n  const displayId = '#peritext-figure-' + figureId;\n  const newContents = [\n    ...contents.slice(),\n    {\n      node: 'text',\n      text: ' ('\n    },\n    {\n      node: 'element',\n      tag: 'a',\n      attr: {\n        href: displayId\n      },\n      child: [\n        {\n          node: 'text',\n          text: 'figure ' + number\n        }\n      ]\n    },\n    {\n      node: 'text',\n      text: ') '\n    }\n  ];\n  node.tag = 'span';\n  node.child = newContents;\n  section.contextualizations = section.contextualizations.map(cont=> {\n    if (cont.citeKey === contextualization.citeKey) {\n      return contextualization;\n    }\n    return cont;\n  });\n  return Object.assign({}, section);\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputSection, inputContextualization, settings) => {\n  return Object.assign({}, inputSection);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (inputSection, inputContextualization, settings) => {\n  return Object.assign({}, inputSection);\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (inputSection, inputContextualization, settings) => {\n  return Object.assign({}, inputSection);\n};\n"
  },
  {
    "__docId__": 47,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 48,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/timeline/index.js",
    "memberof": null,
    "longname": "src/contextualizers/timeline/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Timline contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/timeline\n */\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (section, contextualization, settings) => {\n  return Object.assign({}, section);\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (section, contextualization, settings) => {\n  return Object.assign({}, section);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (section, contextualization, settings) => {\n  return Object.assign({}, section);\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (section, contextualization, settings) => {\n  return Object.assign({}, section);\n};\n"
  },
  {
    "__docId__": 52,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/webpage/StaticWebsitePoster.js",
    "memberof": null,
    "longname": "src/contextualizers/webpage/StaticWebsitePoster.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {StaticImageFigure, StructuredHyperLink} from './../../core/components';\nimport Radium from 'radium';\n\n// let styles = {};\nimport renderContents from './../../core/utils/componentsFactory';\n\n/**\n * dumb static-oriented component for displaying a webpage poster image\n */\n@Radium\nexport default class StructuredWebsitePoster extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} schematype html schema type of the element\n   * @property {object} resource the resource to be parsed\n   * @property {array} captionContent what to display as caption\n   * @property {number} figureNumber in static mode, the number of the figure\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resource: PropTypes.object.isRequired,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'website',\n    captionContent: ''\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const invisibleStyle = {\n      display: 'none'\n    };\n    const contents = [\n      {\n        node: 'text',\n        text: this.props.resource.url\n      }\n    ];\n    return (\n            <figure\n              role=\"group\"\n              className=\"peritext-static-website-poster-container peritext-figure-container\"\n              itemScope\n              itemProp=\"citation\"\n              itemType={'http://schema.org/' + this.props.schematype}\n              typeof={this.props.schematype}\n              resource={'#' + this.props.resource.citeKey}\n              id={'peritext-figure-' + this.props.id}\n            >\n              <span\n                itemProp=\"name\"\n                property=\"name\"\n                style={invisibleStyle}\n              >\n                {this.props.resource.title}\n              </span>\n              <StaticImageFigure {...this.props} />\n              <figcaption\n                itemProp=\"description\"\n                property=\"description\"\n              >\n                Figure {this.props.figureNumber} – {renderContents(this.props.captionContent)} – <StructuredHyperLink contents={contents} resource={this.props.resource}/>\n              </figcaption>\n            </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 57,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredWebsitePoster",
    "memberof": "src/contextualizers/webpage/StaticWebsitePoster.js",
    "longname": "src/contextualizers/webpage/StaticWebsitePoster.js~StructuredWebsitePoster",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/StaticWebsitePoster.js",
    "importStyle": "StructuredWebsitePoster",
    "description": "dumb static-oriented component for displaying a webpage poster image",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 58,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/webpage/StaticWebsitePoster.js~StructuredWebsitePoster",
    "longname": "src/contextualizers/webpage/StaticWebsitePoster.js~StructuredWebsitePoster#render",
    "access": null,
    "description": "render",
    "lineNumber": 38,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 59,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/webpage/index.js",
    "memberof": null,
    "longname": "src/contextualizers/webpage/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Webpage contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/webpage\n */\n\nimport {StructuredHyperLink} from './../../core/components';\nimport StaticWebsitePoster from './StaticWebsitePoster.js';\nimport {getMetaValue} from './../../core/utils/sectionUtils';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputSection, inputContextualization, settings) => {\n  const section = Object.assign({}, inputSection);\n  const contextualization = Object.assign({}, inputContextualization);\n  const citeKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  const node = contextualization.node;\n  const link = {\n    node: 'element',\n    tag: StructuredHyperLink,\n    special: true,\n    props: {\n      resource: contextualization.resources[0],\n      contents: [{\n        node: 'text',\n        text: contextualization.resources[0].url\n      }]\n    }\n  };\n  const noteNumber = section.notes.length + 1;\n  const noteId = citeKey + noteNumber;\n  section.notes.push({\n    noteNumber,\n    contents: [link],\n    id: noteId\n  });\n  node.child = [\n    ...node.child,\n    {\n      element: 'node',\n      tag: 'note',\n      target: noteId\n    }\n  ];\n\n  return Object.assign({}, section);\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputSection, inputContextualization, settings) => {\n  const section = Object.assign({}, inputSection);\n  const contextualization = Object.assign({}, inputContextualization);\n  const citeKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  const node = contextualization.node;\n  const blockIndex = node.blockIndex;\n  let figureId;\n  section.figuresCount ++;\n  figureId = citeKey + '-' + contextualization.citeKey;\n  contextualization.figureId = figureId;\n  contextualization.figureNumber = section.figuresCount;\n  const figure = {\n    node: 'element',\n    special: true,\n    tag: StaticWebsitePoster,\n    props: {\n      imageKey: 'posterurl',\n      resource: contextualization.resources[0],\n      captionContent: node.child[0].child,\n      figureNumber: contextualization.figureNumber,\n      id: figureId\n    }\n  };\n\n  if (settings.figuresPosition === 'inline') {\n    section.contents[blockIndex + section.figuresCount - 1] = figure;\n  } else {\n    section.figures = section.figures ? section.figures.concat(figure) : [figure];\n  }\n  section.contextualizations = section.contextualizations.map(cont=> {\n    if (cont.citeKey === contextualization.citeKey) {\n      return contextualization;\n    }\n    return cont;\n  });\n  return Object.assign({}, section);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (section, contextualization, settings) => {\n  return section;\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newSection - the updated representation of the peritext section in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (section, contextualization, settings) => {\n  return section;\n};\n"
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticBackCover.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticBackCover.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n// let styles = {};\nimport Radium from 'radium';\n\nimport {\n  StructuredPerson\n} from './../index.js';\n\n/**\n * dumb component for back cover page of a static publication of document\n */\n@Radium\nexport default class StaticBackCover extends React.Component {\n\n  /**\n   * propTypes\n   * @property {array} metadata - a section metadata to parse in order to fill cover template\n   */\n  static propTypes = {\n    metadata: PropTypes.array\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * Util for returning the value of a \"general\" type metadata\n   * @param {array} list - the list of metadata\n   * @param {string} key - the key of the metadata prop\n   * @return {string} value\n   */\n  getGeneralProp(list, key) {\n    const obj = list.find((meta) => {\n      return meta.domain === 'general' && meta.key === key;\n    });\n    if (obj) {\n      return obj.value;\n    }\n    return undefined;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <section\n        id=\"peritext-static-back-cover\"\n        className=\"peritext-static-back-cover\"\n      >\n        <h2>{this.getGeneralProp(this.props.metadata, 'title')}</h2>\n        <h3 className=\"peritext-static-authors\">\n          {this.getGeneralProp(this.props.metadata, 'author').map((person) =>{\n            return <StructuredPerson key={person.citeKey} resource={person}/>;\n          })}\n        </h3>\n        <p>\n          {this.getGeneralProp(this.props.metadata, 'abstract')}\n        </p>\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 65,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticBackCover",
    "memberof": "src/core/components/StaticComponents/StaticBackCover.js",
    "longname": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticBackCover.js",
    "importStyle": "StaticBackCover",
    "description": "dumb component for back cover page of a static publication of document",
    "lineNumber": 13,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 66,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getGeneralProp",
    "memberof": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover",
    "longname": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover#getGeneralProp",
    "access": null,
    "description": "Util for returning the value of a \"general\" type metadata",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "list",
        "description": "the list of metadata"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key of the metadata prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "value"
    },
    "generator": false
  },
  {
    "__docId__": 67,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover",
    "longname": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover#render",
    "access": null,
    "description": "render",
    "lineNumber": 46,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 68,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticDocument.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticDocument.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\nimport { intlShape } from 'react-intl';\n// let styles = {};\nimport {getMetaValue} from './../../utils/sectionUtils';\nimport {bibToSchema} from './../../utils/microDataUtils';\nimport {\n  StaticBackCover,\n  StaticEndNotes,\n  StaticEndFigures,\n  StaticFrontCover,\n  StaticGlossary,\n  StaticReferencesList,\n  StaticSection,\n  StaticTableOfContents,\n  StaticTableOfFigures,\n  StructuredMetadataPlaceholder\n} from './../index.js';\n\n\n/**\n * dumb component for rendering the structured representation of a static document\n */\n@Radium\nclass StaticDocument extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} rootSection - the root/first/mother section of the document\n   * @property {array} sections - the list of rendering sections to include - warning -> can include cover, table of contents, ... sections\n   * @property {Object} settings - the rendering settings to use\n   */\n  static propTypes = {\n    rootSection: PropTypes.object,\n    sections: PropTypes.array,\n    settings: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const bibType = bibToSchema(getMetaValue(this.props.rootSection.metadata, 'general', 'bibType'));\n    const citeKey = getMetaValue(this.props.rootSection.metadata, 'general', 'citeKey');\n    return (\n        <section\n          itemScope\n          itemType={'http://schema.org/' + bibType}\n          typeof={bibType}\n          vocab=\"http://schema.org/\"\n          resource={'#' + citeKey}\n        >\n          <StructuredMetadataPlaceholder section={this.props.rootSection} />\n\n          {this.props.sections.map((section, index)=> {\n            switch (section.type) {\n            case 'table-of-contents':\n              return (section.contents.length) ? <StaticTableOfContents id={section.id} key={index} contents={section.contents} /> : '';\n            case 'table-of-figures':\n              return (section.contents.length) ? <StaticTableOfFigures id={section.id} key={index} contents={section.contents} /> : '';\n            case 'front-cover':\n              return <StaticFrontCover key={index} metadata={section.metadata} />;\n            case 'back-cover':\n              return <StaticBackCover key={index} metadata={section.metadata} />;\n            case 'endnotes':\n              return (section.contents.length) ? <StaticEndNotes id={section.id} key={index} notes={section.contents} classSuffix=\"document-end\" /> : '';\n            case 'endfigures':\n              return (section.contents.length) ? <StaticEndFigures id={section.id} key={index} contents={section.contents} classSuffix=\"document-end\" /> : '';\n            case 'references':\n              return (section.contents.length) ? <StaticReferencesList id={section.id} key={index} references={section.contents} settings={this.props.settings} /> : '';\n            case 'glossary':\n              return (section.contents.length) ? <StaticGlossary id={section.id} key={index} elements={section.contents} /> : '';\n            case 'contents':\n              return <StaticSection key={index} section={section} settings={this.props.settings} />;\n            default:\n              break;\n            }\n          })}\n        </section>\n    );\n  }\n}\n\nStaticDocument.contextTypes = { intl: intlShape };\nexport default StaticDocument;\n"
  },
  {
    "__docId__": 69,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticDocument",
    "memberof": "src/core/components/StaticComponents/StaticDocument.js",
    "longname": "src/core/components/StaticComponents/StaticDocument.js~StaticDocument",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticDocument.js",
    "importStyle": "StaticDocument",
    "description": "dumb component for rendering the structured representation of a static document",
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 70,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticDocument.js~StaticDocument",
    "longname": "src/core/components/StaticComponents/StaticDocument.js~StaticDocument#render",
    "access": null,
    "description": "render",
    "lineNumber": 46,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 71,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticEndFigures.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\nimport { intlShape, defineMessages } from 'react-intl';\n\nimport renderContents from './../../utils/componentsFactory';\n\n// let styles = {};\n\nconst translate = defineMessages({\n  endfigures: {\n    id: 'end_figures',\n    description: 'Title of the end figures',\n    defaultMessage: 'Figures',\n  }\n});\n\n/**\n * dumb component for rendering the structured representation of a static section\n */\n@Radium\nclass StaticEndFigures extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    classSuffix: PropTypes.string,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        className={'peritext-static-end-figures-container peritext-static-end-figures-' + this.props.classSuffix + '-container'}\n        id={this.props.id}\n      >\n        {this.props.contents.length > 0 ? <h4 className=\"peritext-static-end-figures-title\">\n         { formatMessage(translate.endfigures, {}) }\n        </h4> : ''}\n\n        <div className=\"peritext-static-end-figures-figures-container\">\n          {renderContents(this.props.contents)}\n        </div>\n      </section>\n    );\n  }\n}\n\nStaticEndFigures.contextTypes = { intl: intlShape };\n\nexport default StaticEndFigures;\n"
  },
  {
    "__docId__": 72,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticEndFigures.js",
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndFigures.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEndFigures",
    "memberof": "src/core/components/StaticComponents/StaticEndFigures.js",
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js~StaticEndFigures",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndFigures.js",
    "importStyle": "StaticEndFigures",
    "description": "dumb component for rendering the structured representation of a static section",
    "lineNumber": 21,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 74,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticEndFigures.js~StaticEndFigures",
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js~StaticEndFigures#render",
    "access": null,
    "description": "render",
    "lineNumber": 39,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 75,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticEndNotes.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\nimport {StaticNoteContent} from './../index.js';\nimport { intlShape, defineMessages } from 'react-intl';\n\n// let styles = {};\n\nconst translate = defineMessages({\n  endnotes: {\n    id: 'end_notes',\n    description: 'Title of the endnotes',\n    defaultMessage: 'Notes',\n  }\n});\n\n/**\n * dumb component for rendering the structured representation of a static section\n */\n@Radium\nclass StaticEndNotes extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    notes: PropTypes.array,\n    classSuffix: PropTypes.string,\n    id: PropTypes.id\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        className={'peritext-static-end-notes-container peritext-static-end-notes-' + this.props.classSuffix + '-container'}\n        id={this.props.id}\n      >\n        {this.props.notes.length > 0 ? <h4 className=\"peritext-static-end-notes-title\">\n         { formatMessage(translate.endnotes, {}) }\n        </h4> : ''}\n\n        <div className=\"peritext-static-end-notes-notes-container\">\n          {this.props.notes.map((note, noteIndex)=> {\n            return <StaticNoteContent key={noteIndex} note={note} />;\n          })}\n        </div>\n      </section>\n    );\n  }\n}\n\nStaticEndNotes.contextTypes = { intl: intlShape };\n\nexport default StaticEndNotes;\n"
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticEndNotes.js",
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndNotes.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEndNotes",
    "memberof": "src/core/components/StaticComponents/StaticEndNotes.js",
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js~StaticEndNotes",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndNotes.js",
    "importStyle": "StaticEndNotes",
    "description": "dumb component for rendering the structured representation of a static section",
    "lineNumber": 20,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 78,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticEndNotes.js~StaticEndNotes",
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js~StaticEndNotes#render",
    "access": null,
    "description": "render",
    "lineNumber": 38,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 79,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticFootnote.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticFootnote.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n// let styles = {};\nimport renderContents from './../../utils/componentsFactory';\n\n/**\n * dumb component for containing either a static or dynamic note, acting whether as a pointer or as a container\n */\n@Radium\nexport default class StaticFootnote extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} note - the note object to use in order to render the footnote\n   */\n  static propTypes = {\n    note: PropTypes.object,\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <sup\n        className=\"peritext-static-note-content-container\"\n        name={'peritext-static-note-content-' + this.props.note.target }\n        id={'peritext-static-note-content-' + this.props.note.target}\n      >\n        {renderContents(this.props.note.contents)}\n      </sup>);\n  }\n}\n"
  },
  {
    "__docId__": 80,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticFootnote",
    "memberof": "src/core/components/StaticComponents/StaticFootnote.js",
    "longname": "src/core/components/StaticComponents/StaticFootnote.js~StaticFootnote",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticFootnote.js",
    "importStyle": "StaticFootnote",
    "description": "dumb component for containing either a static or dynamic note, acting whether as a pointer or as a container",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 81,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticFootnote.js~StaticFootnote",
    "longname": "src/core/components/StaticComponents/StaticFootnote.js~StaticFootnote#render",
    "access": null,
    "description": "render",
    "lineNumber": 27,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 82,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticFrontCover.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticFrontCover.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport StructuredPerson from './../StructuredDataComponents/StructuredPerson.js';\nimport Radium from 'radium';\n\n/**\n * dumb component for cover page of a static publication of document\n */\n@Radium\nexport default class StaticFrontCover extends React.Component {\n\n  /**\n   * propTypes\n   * @property {array} metadata a section metadata to parse in order to fill cover template\n   */\n  static propTypes = {\n    metadata: PropTypes.array\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * Util for returning the value of a \"general\" type metadata\n   * @param {array} list - the list of metadata\n   * @param {string} key - the key of the metadata prop\n   * @return {string} value\n   */\n  getGeneralProp(list, key) {\n    const obj = list.find((meta) => {\n      return meta.domain === 'general' && meta.key === key;\n    });\n    if (obj) {\n      return obj.value;\n    }\n    return undefined;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <section\n        id=\"peritext-static-front-cover\"\n        className=\"peritext-static-front-cover-container\"\n      >\n        <div\n          style={{backgroundImage: 'url(' + this.getGeneralProp(this.props.metadata, 'coverimage') + ')'}}\n          id=\"peritext-static-front-cover-image-container\"\n        ></div>\n        <div\n          className=\"peritext-static-front-cover-texts-container\"\n        >\n          <section className=\"peritext-static-front-cover-part-top-left\">\n            <h3 className=\"peritext-static-front-cover-dissertationinstitution\">\n              Thèse / {this.getGeneralProp(this.props.metadata, 'dissertationinstitution')}\n            </h3>\n            <p>\n              Pour obtenir le grade de DOCTEUR\n            </p>\n            <h4 className=\"peritext-static-front-cover-dissertationcomment\">\n              {this.getGeneralProp(this.props.metadata, 'dissertationcomment')}\n            </h4>\n\n            <p className=\"peritext-static-front-cover-dissertationdoctoralschool\">\n              École doctorale {this.getGeneralProp(this.props.metadata, 'dissertationdoctoralschool')}\n            </p>\n\n            <p className=\"peritext-static-front-cover-dissertationdiscipline\">\n              Mention : <span>{this.getGeneralProp(this.props.metadata, 'dissertationdiscipline')}</span>\n            </p>\n          </section>\n\n          <section className=\"peritext-static-front-cover-part-top-right\">\n            <p>\n              présentée par\n            </p>\n            <h1 className=\"peritext-static-authors\">\n              {this.getGeneralProp(this.props.metadata, 'author').map((person) =>{\n                return <StructuredPerson key={person.citeKey} resource={person}/>;\n              })}\n            </h1>\n            <p className=\"peritext-static-front-cover-dissertationlab\">\n              {this.getGeneralProp(this.props.metadata, 'dissertationlab')}\n            </p>\n          </section>\n\n          <section className=\"peritext-static-front-cover-part-bottom-left\">\n            <h1>\n              {this.getGeneralProp(this.props.metadata, 'title')}\n            </h1>\n          </section>\n\n          <section className=\"peritext-static-front-cover-part-bottom-right\">\n            <p className=\"peritext-static-front-cover-date\">\n              Thèse soutenue le {this.getGeneralProp(this.props.metadata, 'date')}\n            </p>\n            <p>\n              devant le jury composé de :\n            </p>\n            {\n              this.getGeneralProp(this.props.metadata, 'dissertationjury').map((person) =>{\n                return (\n                    <p key={person.citeKey} className=\"peritext-static-front-cover-jury-member\">\n                      <StructuredPerson resource={person} pattern=\"${firstName} ${lastName:capitals} ${information} / ${role}\"/>\n                    </p>\n                  );\n              })\n            }\n          </section>\n        </div>\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 83,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticFrontCover",
    "memberof": "src/core/components/StaticComponents/StaticFrontCover.js",
    "longname": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticFrontCover.js",
    "importStyle": "StaticFrontCover",
    "description": "dumb component for cover page of a static publication of document",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 84,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getGeneralProp",
    "memberof": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover",
    "longname": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover#getGeneralProp",
    "access": null,
    "description": "Util for returning the value of a \"general\" type metadata",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "list",
        "description": "the list of metadata"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key of the metadata prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "value"
    },
    "generator": false
  },
  {
    "__docId__": 85,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover",
    "longname": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover#render",
    "access": null,
    "description": "render",
    "lineNumber": 42,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 86,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticGlossary.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticGlossary.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\nimport { intlShape, defineMessages } from 'react-intl';\nimport StaticEntityBlock from './../../../contextualizers/glossary/StaticEntityBlock.js';\n// let styles = {};\n\nconst translate = defineMessages({\n  glossary: {\n    id: 'glossary',\n    description: 'Title of glossary section',\n    defaultMessage: 'Glossary',\n  }\n});\n\n/**\n * dumb component for rendering a static table of contents\n */\n@Radium\nclass StaticGlossary extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    elements: PropTypes.array,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    elements: []\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        id={this.props.id}\n        className=\"peritext-static-glossary-container\"\n      >\n        <h2>{ formatMessage(translate.glossary, {}) }</h2>\n        <section\n          className=\"peritext-static-glossary-elements-container\"\n        >\n          {\n            this.props.elements.map((entity, index) => (\n              <StaticEntityBlock key={index} entity={entity} />\n            ))\n          }\n        </section>\n      </section>\n    );\n  }\n}\nStaticGlossary.contextTypes = { intl: intlShape };\n\nexport default StaticGlossary;\n"
  },
  {
    "__docId__": 87,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticGlossary.js",
    "longname": "src/core/components/StaticComponents/StaticGlossary.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticGlossary.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticGlossary",
    "memberof": "src/core/components/StaticComponents/StaticGlossary.js",
    "longname": "src/core/components/StaticComponents/StaticGlossary.js~StaticGlossary",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticGlossary.js",
    "importStyle": "StaticGlossary",
    "description": "dumb component for rendering a static table of contents",
    "lineNumber": 19,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 89,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticGlossary.js~StaticGlossary",
    "longname": "src/core/components/StaticComponents/StaticGlossary.js~StaticGlossary#render",
    "access": null,
    "description": "render",
    "lineNumber": 38,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 90,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticImageFigure.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticImageFigure.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\n/**\n * dumb component for displaying a simple structured image figure\n */\n@Radium\nexport default class StaticImageFigure extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} schematype - html schema type of the element\n   * @property {object} resource - the resource to be parsed\n   * @property {string} imageKey - the resource prop to use for finding the image url\n   * @property {string} captionContent - what to display as caption\n   * @property {number} figureNumber - in static mode, the number of the figure\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resource: PropTypes.object,\n    imageKey: PropTypes.string,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number\n  };\n\n  static defaultProps = {\n    schematype: 'ImageObject',\n    captionContent: [],\n    imageKey: 'imageurl'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n              <figure\n                className=\"peritext-static-image-figure-container\"\n                itemProp=\"image\"\n                value=\"image\"\n                itemScope\n                itemType=\"http://schema.org/ImageObject\"\n                typeof=\"ImageObject\"\n              >\n                <a\n                  href={this.props.resource[this.props.imageKey]}\n                  itemProp=\"url\"\n                  property=\"url\"\n                  value={this.props.resource[this.props.imageKey]}\n                >\n                </a>\n                <img\n                  itemProp=\"contentUrl\"\n                  value=\"contentUrl\"\n                  src={this.props.resource[this.props.imageKey]}\n                  alt={this.props.resource.title}\n                />\n              </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 91,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticImageFigure",
    "memberof": "src/core/components/StaticComponents/StaticImageFigure.js",
    "longname": "src/core/components/StaticComponents/StaticImageFigure.js~StaticImageFigure",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticImageFigure.js",
    "importStyle": "StaticImageFigure",
    "description": "dumb component for displaying a simple structured image figure",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 92,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticImageFigure.js~StaticImageFigure",
    "longname": "src/core/components/StaticComponents/StaticImageFigure.js~StaticImageFigure#render",
    "access": null,
    "description": "render",
    "lineNumber": 36,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 93,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticNoteContent.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticNoteContent.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\nimport renderContents from './../../utils/componentsFactory';\n\n\n/**\n * dumb component for rendering the structured representation of a static note\n */\n@Radium\nexport default class StaticNote extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} note - the note object to use in order to render the note content\n   */\n  static propTypes = {\n    note: PropTypes.object,\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        style={{display: 'block'}}\n        className=\"peritext-static-note-content-container\"\n        name={'peritext-static-note-content-' + this.props.note.id}\n        id={'peritext-static-note-content-' + this.props.note.id}\n      >\n        <a\n          href={'#peritext-static-note-pointer-' + this.props.note.id}\n          className=\"peritext-static-note-content-number\"\n        >\n          {this.props.note.noteNumber}\n        </a>\n        {renderContents(this.props.note.contents)}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 94,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticNote",
    "memberof": "src/core/components/StaticComponents/StaticNoteContent.js",
    "longname": "src/core/components/StaticComponents/StaticNoteContent.js~StaticNote",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticNoteContent.js",
    "importStyle": "StaticNote",
    "description": "dumb component for rendering the structured representation of a static note",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 95,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticNoteContent.js~StaticNote",
    "longname": "src/core/components/StaticComponents/StaticNoteContent.js~StaticNote#render",
    "access": null,
    "description": "render",
    "lineNumber": 28,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 96,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticNotePointer.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticNotePointer.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\n/**\n * dumb component for rendering the structured representation of a static note pointer\n */\n@Radium\nexport default class StaticNotePointer extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} note - the note object to use in order to render the note pointer\n   */\n  static propTypes = {\n    note: PropTypes.object,\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <sup\n        className=\"peritext-static-note-pointer-container\"\n        name={'peritext-static-note-pointer-' + this.props.note.id}\n        id={'peritext-static-note-pointer-' + this.props.note.id}\n      >\n        <a\n          href={'#peritext-static-note-content-' + this.props.note.id}\n          className=\"peritext-static-note-pointer-number\"\n        >\n          {this.props.note.noteNumber}\n        </a>\n      </sup>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 97,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticNotePointer",
    "memberof": "src/core/components/StaticComponents/StaticNotePointer.js",
    "longname": "src/core/components/StaticComponents/StaticNotePointer.js~StaticNotePointer",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticNotePointer.js",
    "importStyle": "StaticNotePointer",
    "description": "dumb component for rendering the structured representation of a static note pointer",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 98,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticNotePointer.js~StaticNotePointer",
    "longname": "src/core/components/StaticComponents/StaticNotePointer.js~StaticNotePointer#render",
    "access": null,
    "description": "render",
    "lineNumber": 25,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 99,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticReferencesList.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\nimport { intlShape, defineMessages } from 'react-intl';\n\n// let styles = {};\n\nconst translate = defineMessages({\n  referencestitle: {\n    id: 'references_title',\n    description: 'Title of references/bibliography section',\n    defaultMessage: 'References'\n  }\n});\n\n/**\n * dumb component for rendering a static table of figures\n */\n@Radium\nclass StaticReferencesList extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    references: PropTypes.array,\n    settings: PropTypes.object,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    references: []\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const citationRenderer = require('./../../../referencers/' + this.props.settings.citationStyle + '.js');\n    const BlockCitation = citationRenderer.BlockCitation;\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        className=\"peritext-static-references-list-container\"\n        id={this.props.id}\n      >\n        <h2>{ formatMessage(translate.referencestitle, {}) }</h2>\n        <section className=\"peritext-static-references-list-items-container\">\n          {this.props.references.map((reference)=> {\n            return <BlockCitation key={reference.citeKey} resource={reference} contextualization={{}} />;\n          })}\n        </section>\n      </section>\n    );\n  }\n}\n\nStaticReferencesList.contextTypes = { intl: intlShape };\n\nexport default StaticReferencesList;\n"
  },
  {
    "__docId__": 100,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticReferencesList.js",
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticReferencesList.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticReferencesList",
    "memberof": "src/core/components/StaticComponents/StaticReferencesList.js",
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js~StaticReferencesList",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticReferencesList.js",
    "importStyle": "StaticReferencesList",
    "description": "dumb component for rendering a static table of figures",
    "lineNumber": 19,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 102,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticReferencesList.js~StaticReferencesList",
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js~StaticReferencesList#render",
    "access": null,
    "description": "render",
    "lineNumber": 39,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 103,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticSection.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticSection.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\nimport {getMetaValue} from './../../utils/sectionUtils';\nimport {bibToSchema} from './../../utils/microDataUtils';\n\nimport {\n  StructuredMetadataPlaceholder,\n  StaticEndNotes,\n  StaticEndFigures\n} from './../index.js';\n\nimport renderContents from './../../utils/componentsFactory';\n\n/**\n * dumb component for rendering the structured representation of a static section\n */\n@Radium\nexport default class StaticSection extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} section - the section to render\n   * @property {Object} settings - the settings to use for section rendering\n   */\n  static propTypes = {\n    section: PropTypes.object,\n    settings: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const bibType = bibToSchema(getMetaValue(this.props.section.metadata, 'general', 'bibType'));\n    const citeKey = getMetaValue(this.props.section.metadata, 'general', 'citeKey');\n    return (\n      <section\n        className={'peritext-static-section-container peritext-static-section-level-' + getMetaValue(this.props.section.metadata, 'general', 'generalityLevel')}\n        id={getMetaValue(this.props.section.metadata, 'general', 'citeKey')}\n        itemScope\n        itemType={'http://schema.org/' + bibType}\n        typeof={bibType}\n        resource={'#' + citeKey}\n        itemProp=\"hasPart\"\n        property=\"hasPart\"\n      >\n        <StructuredMetadataPlaceholder section={this.props.section} />\n        {renderContents(this.props.section.contents)}\n        {this.props.settings.figuresPosition === 'section-end' && this.props.section.figures ?\n          <StaticEndFigures\n            contents={this.props.section.figures}\n            classSuffix=\"section-end\"\n          /> : ''}\n        {this.props.settings.notesPosition === 'section-end' && this.props.section.notes.length ?\n          <StaticEndNotes\n            classSuffix=\"section-end\"\n            notes={this.props.section.notes}\n          /> : ''}\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 104,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticSection",
    "memberof": "src/core/components/StaticComponents/StaticSection.js",
    "longname": "src/core/components/StaticComponents/StaticSection.js~StaticSection",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticSection.js",
    "importStyle": "StaticSection",
    "description": "dumb component for rendering the structured representation of a static section",
    "lineNumber": 19,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 105,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticSection.js~StaticSection",
    "longname": "src/core/components/StaticComponents/StaticSection.js~StaticSection#render",
    "access": null,
    "description": "render",
    "lineNumber": 38,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 106,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\nimport { intlShape, defineMessages } from 'react-intl';\n\n// let styles = {};\n\nconst translate = defineMessages({\n  tableofcontents: {\n    id: 'table_of_contents',\n    description: 'Table of contents title',\n    defaultMessage: 'Table of contents',\n  }\n});\n\n/**\n * dumb component for rendering a static table of contents\n */\n@Radium\nclass StaticTableOfContents extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    level: PropTypes.number,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    title: 'Table of contents',\n    level: 1\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        id={this.props.id}\n        className=\"peritext-static-table-of-contents-container\"\n      >\n        <h2>{ formatMessage(translate.tableofcontents, {}) }</h2>\n        <section className=\"peritext-static-table-of-contents-elements-container\">\n          {this.props.contents.map((element) =>{\n            return <StaticTableOfContentsElement id={element.id} key={element.id} title={element.title} level={element.level} levelDisplacement={this.props.level}/>;\n          })}\n        </section>\n      </section>\n    );\n  }\n}\n\nStaticTableOfContents.contextTypes = { intl: intlShape };\n\nexport default StaticTableOfContents;\n\nclass StaticTableOfContentsElement extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    title: PropTypes.string,\n    level: PropTypes.number,\n    id: PropTypes.string,\n    paddingDisplacement: PropTypes.number,\n    levelDisplacement: PropTypes.number\n  };\n\n  static defaultProps = {\n    level: 0,\n    paddingDisplacement: 0.5,\n    levelDisplacement: 0\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <section\n        className=\"peritext-static-table-of-contents-element-container\"\n        style={{paddingLeft: (this.props.level - this.props.levelDisplacement - 1) * this.props.paddingDisplacement + 'cm'}}\n      >\n        <a\n          href={'#' + this.props.id}\n        >\n          {this.props.title}\n        </a>\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 107,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfContents.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTableOfContentsElement",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContentsElement",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfContents.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 109,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContentsElement",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContentsElement#render",
    "access": null,
    "description": "render",
    "lineNumber": 85,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 110,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTableOfContents",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfContents.js",
    "importStyle": "StaticTableOfContents",
    "description": "dumb component for rendering a static table of contents",
    "lineNumber": 19,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 111,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContents",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContents#render",
    "access": null,
    "description": "render",
    "lineNumber": 40,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 112,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\nimport { intlShape, defineMessages } from 'react-intl';\n\n// let styles = {};\n\nconst translate = defineMessages({\n  tableoffigures: {\n    id: 'table_of_figures',\n    description: 'Table of figures title',\n    defaultMessage: 'Table of figures',\n  },\n  figurename: {\n    id: 'figure',\n    description: 'Name of a figure',\n    defaultMessage: 'Figure',\n  }\n});\n\n\n/**\n * dumb component for rendering a static table of figures\n */\n@Radium\nclass StaticTableOfFigures extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    contents: []\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        id={this.props.id}\n        className=\"peritext-static-table-of-figures-container\"\n      >\n        <h2>{ formatMessage(translate.tableoffigures, {}) }</h2>\n        <section className=\"peritext-static-table-of-figures-elements-container\">\n          {this.props.contents.map((element, index) =>{\n            return (<section\n                      className=\"peritext-static-table-of-figures-element\"\n                      key={element.id + index}>\n                      <a\n                        href={'#' + element.id}\n                      >\n                        { formatMessage(translate.figurename, {}) } {element.number}\n                      </a>\n                    </section>);\n          })}\n        </section>\n      </section>\n    );\n  }\n}\n\nStaticTableOfFigures.contextTypes = { intl: intlShape };\n\nexport default StaticTableOfFigures;\n"
  },
  {
    "__docId__": 113,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfFigures.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTableOfFigures",
    "memberof": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js~StaticTableOfFigures",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfFigures.js",
    "importStyle": "StaticTableOfFigures",
    "description": "dumb component for rendering a static table of figures",
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 115,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticTableOfFigures.js~StaticTableOfFigures",
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js~StaticTableOfFigures#render",
    "access": null,
    "description": "render",
    "lineNumber": 44,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 116,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {generateOpenUrl} from './../../utils/microDataUtils';\n\n// let styles = {};\n\n/**\n * dumb component for rendering the structured representation of a cited element in the format of openUrl/Context Object in Span\n */\nexport default class StructuredCOinS extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    resource: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const openUrl = generateOpenUrl(this.props.resource);\n    return (\n      <span className=\"peritext-structured-context-object-in-span-container Z3988\" title={openUrl}></span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 117,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredCOinS",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredCOinS.js~StructuredCOinS",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "importStyle": "StructuredCOinS",
    "description": "dumb component for rendering the structured representation of a cited element in the format of openUrl/Context Object in Span",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 118,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCOinS.js~StructuredCOinS",
    "longname": "src/core/components/StructuredDataComponents/StructuredCOinS.js~StructuredCOinS#render",
    "access": null,
    "description": "render",
    "lineNumber": 25,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 119,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredCite.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredCite.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\n/**\n * dumb component for rendering the structured representation of a cite element\n */\n@Radium\nexport default class StructuredCite extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} value - the value of the cite item\n   * @property {string} property - the schema property to apply\n   */\n  static propTypes = {\n    value: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    property: 'name'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <cite\n        className=\"peritext-structred-cite-container\"\n        property={this.props.property}\n        itemProp={this.props.property}\n      >\n        {this.props.value}\n      </cite>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 120,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredCite",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCite.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredCite.js~StructuredCite",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredCite.js",
    "importStyle": "StructuredCite",
    "description": "dumb component for rendering the structured representation of a cite element",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 121,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCite.js~StructuredCite",
    "longname": "src/core/components/StructuredDataComponents/StructuredCite.js~StructuredCite#render",
    "access": null,
    "description": "render",
    "lineNumber": 28,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 122,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredDate.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\n/**\n * dumb component for rendering the structured representation of a date\n */\n@Radium\nexport default class StructuredDate extends React.Component {\n\n  /**\n   * propTypes\n   * @property {number|string} value - the value of the date, as an absolute date number or as a string statement\n   * @property {string} property - the schema property to use for microformatting the element\n   * @property {string} modificator - the modificator statement to use for formatting the date\n   */\n  static propTypes = {\n    value: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string\n    ]),\n    property: PropTypes.string,\n    modificator: PropTypes.string\n  };\n\n  static defaultProps = {\n    property: 'datePublished'\n  };\n\n  /**\n   * Resolves date value against modificator statement\n   * @param {string|number} value - value of the date\n   * @param {string} modificator - modificator to be applied\n   * @return {Object} newVal - the modified value of the date\n  */\n  setFinalValue(value, modificator) {\n    if (typeof value === 'string' && modificator === 'year') {\n      const match = value.match(/([\\d]{2,4})/);\n      if (match) {\n        return match[1];\n      }\n    }\n    return value;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const finalValue = this.setFinalValue(this.props.value, this.props.modificator);\n    return (\n      <time\n        className=\"peritext-structured-date-container\"\n        property={this.props.property}\n        itemProp={this.props.property}\n        dateTime={finalValue}\n      >\n        {finalValue}\n      </time>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 123,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredDate",
    "memberof": "src/core/components/StructuredDataComponents/StructuredDate.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredDate.js",
    "importStyle": "StructuredDate",
    "description": "dumb component for rendering the structured representation of a date",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 124,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setFinalValue",
    "memberof": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate",
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate#setFinalValue",
    "access": null,
    "description": "Resolves date value against modificator statement",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value of the date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "modificator",
        "description": "modificator to be applied"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newVal - the modified value of the date"
    },
    "generator": false
  },
  {
    "__docId__": 125,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate",
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate#render",
    "access": null,
    "description": "render",
    "lineNumber": 49,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 126,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\n// let styles = {};\nimport renderContents from './../../utils/componentsFactory';\n\n/**\n * dumb component for displaying a structured simple hyperlink <a>\n */\n@Radium\nexport default class StructuredHyperLink extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} schematype html schema type of the element\n   * @property {array} contents the text to display inside the hyperlink\n   * @property {object} resource the resource to be parsed\n   * @property {object} property the microformat property of the hyperlink\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    schematype: PropTypes.string,\n    resource: PropTypes.object,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'website',\n    property: 'citation'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const invisibleStyle = {\n      display: 'none'\n    };\n    return (\n            <a className=\"peritext-structured-hyperlink-container\"\n                itemScope\n                itemProp={this.props.property}\n                itemType={'http://schema.org/' + this.props.schematype}\n                typeof={this.props.schematype}\n                resource={'#' + this.props.resource.citeKey}\n                href={this.props.resource.url}\n            >\n              <span\n                itemProp=\"name\"\n                property=\"name\"\n                value={this.props.resource.title}\n                style={invisibleStyle}\n              >\n                {this.props.resource.title}\n              </span>\n              <span\n                itemrop=\"name\"\n                property=\"name\"\n                value={this.props.resource.url}\n                style={invisibleStyle}\n              >\n                {this.props.resource.url}\n              </span>\n              <span>\n                {renderContents(this.props.contents)}\n              </span>\n            </a>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 127,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredHyperLink",
    "memberof": "src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredHyperLink.js~StructuredHyperLink",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "importStyle": "StructuredHyperLink",
    "description": "dumb component for displaying a structured simple hyperlink <a>",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 128,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredHyperLink.js~StructuredHyperLink",
    "longname": "src/core/components/StructuredDataComponents/StructuredHyperLink.js~StructuredHyperLink#render",
    "access": null,
    "description": "render",
    "lineNumber": 36,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 129,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {\n  StructuredDate,\n  StructuredSpan,\n  StructuredPerson\n} from './../index.js';\n\n/**\n * dumb component for rendering the structured representation of a section\n */\nexport default class StructuredMetadataPlaceholder extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} section - section to represent with metadata\n   */\n  static propTypes = {\n    section: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <div\n        className=\"peritext-structured-metadata-placeholder-container\"\n        style={{visibility: 'hidden'}}\n      >\n        {this.props.section.metadata.filter((prop) =>{\n          return prop.domain === 'general';\n        }).map((meta) =>{\n          switch (meta.key) {\n          case 'title':\n            return <StructuredSpan key={meta.key} property=\"name\" value={meta.value} />;\n          case 'date':\n            return <StructuredDate key={meta.key} property=\"datePublished\" value={meta.value} />;\n          case 'author':\n            return (\n              <span key={meta.key}>\n                {\n                  meta.value.map((author)=> {\n                    return <StructuredPerson resource={author} key={author.citeKey} />;\n                  })\n                }\n              </span>\n            );\n          // TODO : continue along with other metadata-to-schema conversions\n          default:\n            return '';\n          }\n        })}\n      </div>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 130,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredMetadataPlaceholder",
    "memberof": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js~StructuredMetadataPlaceholder",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "importStyle": "StructuredMetadataPlaceholder",
    "description": "dumb component for rendering the structured representation of a section",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 131,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js~StructuredMetadataPlaceholder",
    "longname": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js~StructuredMetadataPlaceholder#render",
    "access": null,
    "description": "render",
    "lineNumber": 28,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 132,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport reactStringReplace from 'react-string-replace';\nimport {\n  StructuredDate\n} from './../index.js';\n\nimport Radium from 'radium';\n\n\n/**\n * dumb component for rendering the structured representation of parent journal information\n */\n@Radium\nexport default class StructuredParentJournal extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource parsed for structuring data\n   * @property {string} pattern - the pattern to apply for formatting thresource\n   * @property {string} property - the microformat property to apply to the structured element\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    pattern: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    pattern: '${journal}, ${date}, ${volume}(${issue}). ISSN : ${issn}',\n    property: 'isPartOf'\n  };\n\n  /**\n   * updateHtml : transform pattern+resource props into a react element\n   * @param {object} resource - the resource to render\n   * @param {string} pattern - the pattern to use for rendering the resource\n   * @return {ReactElement} markup\n   */\n  updateHtml(resource, pattern) {\n    let replacedText;\n    replacedText = reactStringReplace(pattern, /(\\${journal})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-journal\">{resource.journal}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${date})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-date\">{resource.date || resource.year}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${volume})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-volume\">{resource.volume}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${issue})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-issue\">{resource.issue}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${issn})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-issn\">{resource.issn}</span>\n    ));\n    return replacedText;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        className=\"peritext-structured-parent-journal-container\"\n        itemProp={this.props.property}\n        property={this.props.property}\n        itemScope\n        itemType=\"http://schema.org/Periodical\"\n        typeof=\"Periodical\"\n        resource={this.props.resource.issn + this.props.resource.journal}\n      >\n        <span style={{display: 'none'}} itemProp=\"name\" property=\"name\">{this.props.resource.journal}</span>\n        <span\n          itemProp=\"hasPart\"\n          property=\"hasPart\"\n          itemScope\n          itemType=\"http://schema.org/PublicationVolume\"\n          typeof=\"PublicationVolume\"\n          resource={this.props.resource.issn + this.props.resource.journal + '-volume' + this.props.resource.volume}\n          style={{display: 'none'}}\n        >\n          <span itemProp=\"volumeNumber\" property=\"volumeNumber\">{this.props.resource.volume}</span>\n          <span\n            itemProp=\"hasPart\"\n            property=\"hasPart\"\n            itemScope\n            itemType=\"http://schema.org/PublicationIssue\"\n            typeof=\"PublicationIssue\"\n            resource={this.props.resource.issn + this.props.resource.journal + '-volume' + this.props.resource.volume + '-issue' + this.props.resource.issue}\n          >\n            <span itemProp=\"issueNumber\" property=\"issueNumber\">{this.props.resource.issue}</span>\n            <StructuredDate value={this.props.resource.date || this.props.resource.year}/>\n          </span>\n        </span>\n        <span\n          itemProp=\"issn\"\n          style={{display: 'none'}}\n          property=\"issn\">\n            {this.props.resource.issn}\n        </span>\n\n        {this.updateHtml(this.props.resource, this.props.pattern)}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 133,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredParentJournal",
    "memberof": "src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "importStyle": "StructuredParentJournal",
    "description": "dumb component for rendering the structured representation of parent journal information",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 134,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "updateHtml",
    "memberof": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal",
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal#updateHtml",
    "access": null,
    "description": "updateHtml : transform pattern+resource props into a react element",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "the resource to render"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to use for rendering the resource"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 135,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal",
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal#render",
    "access": null,
    "description": "render",
    "lineNumber": 67,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 136,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredPerson.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport reactStringReplace from 'react-string-replace';\n\nimport Radium from 'radium';\n\n/**\n * dumb component for rendering the structured representation of a person\n */\n@Radium\nexport default class StructuredPerson extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} resource - the person object which may contain the following props : \"lastName\", \"firstName\", \"role\", and \"information\"\n   * @property {string} pattern - the pattern to apply for formatting the person name to html, eg : \" ${lastName:capitals}, ${firstName:initials}\"\n   * @property {string} property - the microformat property to apply to the structured element\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    pattern: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    pattern: '${firstName} ${lastName}',\n    property: 'author'\n  };\n\n  /**\n   * transformValues modifies firstName and lastName according to pattern indications\n   * @param {Object} author - the person representation to transform\n   * @param {string} pattern - the pattern to use for transforming person representation\n   * @return {Object} newAuthor - new author object\n   */\n  transformValues(author, pattern) {\n    const vals = Object.assign({}, author);\n    // catch format transformers\n    const transformFirstNameMatch = pattern.match(/(\\${firstName(:[^}]*)?})/);\n    const transformLastNameMatch = pattern.match(/(\\${lastName(:[^}]*)?})/);\n    // if transformers - transform\n    if (transformFirstNameMatch) {\n      if (transformFirstNameMatch[2] === ':initials') {\n        // processing composed names (e.g. Gian-Marco Patalucci)\n        let initials = vals.firstName.split('-').map((term)=>{\n          if (term.length > 0) {\n            return term.toUpperCase().substr(0, 1) + '.';\n          }\n          return term;\n        }).join('-');\n        // processing multiple names (e.g. Donald Ronald Romuald Ronaldo Reagan)\n        initials = vals.firstName.split(' ').map((term)=>{\n          if (term.length > 0) {\n            return term.toUpperCase().substr(0, 1) + '.';\n          }\n          return term;\n        }).join(' ');\n        vals.firstName = initials;\n      }\n    }\n    if (transformLastNameMatch) {\n      if (transformLastNameMatch[2] === ':capitals') {\n        vals.lastName = vals.lastName.toUpperCase();\n      }\n    }\n    return vals;\n  }\n\n  /**\n   * updateHtml : transform pattern+person props into a react element\n   * @return {ReactElement} markup\n   */\n  updateHtml() {\n    const vals = this.transformValues(this.props.resource, this.props.pattern);\n\n    const firstNameExp = this.props.pattern.match(/(\\${firstName(:[^}]*)?})/);\n    const lastNameExp = this.props.pattern.match(/(\\${lastName(:[^}]*)?})/);\n    let replacedText = this.props.pattern;\n    if (firstNameExp) {\n      replacedText = reactStringReplace(replacedText, new RegExp('(\\\\' + firstNameExp[0] + ')', 'g'), (match, index)=> (\n        <span key={match + index} className=\"peritext-structured-person-firstname\" itemProp=\"givenName\" property=\"givenName\" >{vals.firstName}</span>\n      ));\n    }\n\n    if (lastNameExp) {\n      replacedText = reactStringReplace(replacedText, new RegExp('(\\\\' + lastNameExp[0] + ')', 'g'), (match, index)=> (\n        <span key={match + index} className=\"peritext-structured-person-lastname\" itemProp=\"familyName\" property=\"familyName\" >{vals.lastName}</span>\n      ));\n    }\n\n    replacedText = reactStringReplace(replacedText, /(\\${role})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-person-role\" >{vals.role}</span>\n    ));\n\n    if (vals.information) {\n      replacedText = reactStringReplace(replacedText, /(\\${information})/g, (match, index)=> (\n        <span key={match + index} className=\"peritext-structured-person-information\" >{vals.information}</span>\n      ));\n    }\n\n    return replacedText;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        className=\"peritext-structured-person-container\"\n        itemProp={this.props.property}\n        itemScope\n        itemType=\"http://schema.org/Person\"\n        property={this.props.property}\n        typeof=\"Person\"\n        resource={this.props.resource.citeKey}\n      >\n        {this.updateHtml()}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 137,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredPerson",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredPerson.js",
    "importStyle": "StructuredPerson",
    "description": "dumb component for rendering the structured representation of a person",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 138,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "transformValues",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson#transformValues",
    "access": null,
    "description": "transformValues modifies firstName and lastName according to pattern indications",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "author",
        "description": "the person representation to transform"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to use for transforming person representation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newAuthor - new author object"
    },
    "generator": false
  },
  {
    "__docId__": 139,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "updateHtml",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson#updateHtml",
    "access": null,
    "description": "updateHtml : transform pattern+person props into a react element",
    "lineNumber": 72,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 140,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson#render",
    "access": null,
    "description": "render",
    "lineNumber": 107,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 141,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport reactStringReplace from 'react-string-replace';\nimport Radium from 'radium';\n\n/**\n * dumb component for rendering the structured representation of publisher information\n */\n@Radium\nexport default class StructuredPublisher extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource parsed for structuring data\n   * @property {string} pattern - the pattern to apply for formatting thresource\n   * @property {string} property - the microformat property to apply to the structured element\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    pattern: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    pattern: '${publisher} : ${address}',\n    property: 'publisher'\n  };\n\n  /**\n   * updateHtml : transform pattern+resource props into a react element\n   * @param {object} resource - the resource to represent\n   * @param {string} pattern - the pattern to represent the resource with\n   * @return {ReactElement} markup\n   */\n  updateHtml(resource, pattern) {\n\n    let replacedText = reactStringReplace(pattern, /(\\${publisher})/g, (match, index)=> (\n      <span key={match + index} itemProp=\"name\" property=\"name\" className=\"peritext-structured-publisher-publisher\">{resource.publisher}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${address})/g, (match, index)=> (\n      <span key={match + index} itemProp=\"address\" value=\"address\" className=\"peritext-structured-publisher-address\">{resource.address}</span>\n    ));\n\n    return replacedText;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        className=\"peritext-structured-publisher-container\"\n        itemProp={this.props.property}\n        property={this.props.property}\n        itemScope\n        itemType=\"http://schema.org/Organization\"\n        typeof=\"Organization\"\n        resource={this.props.resource.publisher}\n      >\n        {this.updateHtml(this.props.resource, this.props.pattern)}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 142,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredPublisher",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "importStyle": "StructuredPublisher",
    "description": "dumb component for rendering the structured representation of publisher information",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 143,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "updateHtml",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher",
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher#updateHtml",
    "access": null,
    "description": "updateHtml : transform pattern+resource props into a react element",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "the resource to represent"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to represent the resource with"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 144,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher",
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher#render",
    "access": null,
    "description": "render",
    "lineNumber": 51,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 145,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredSpan.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredSpan.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport Radium from 'radium';\n\n/**\n * dumb generic component for rendering the structured representation of a property\n */\n@Radium\nexport default class StructuredSpan extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string|number} value - the value to put in the span\n   * @property {string} property - the schema property to microformat the span with\n   * @property {string} htmlClass - the class to apply to the span element\n   */\n  static propTypes = {\n    value: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.number\n    ]),\n    property: PropTypes.string,\n    htmlClass: PropTypes.string\n  };\n\n  static defaultProps = {\n    property: 'name'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        property={this.props.property}\n        itemProp={this.props.property}\n        className={this.props.htmlClass}\n      >\n        {this.props.value}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 146,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredSpan",
    "memberof": "src/core/components/StructuredDataComponents/StructuredSpan.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredSpan.js~StructuredSpan",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredSpan.js",
    "importStyle": "StructuredSpan",
    "description": "dumb generic component for rendering the structured representation of a property",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 147,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredSpan.js~StructuredSpan",
    "longname": "src/core/components/StructuredDataComponents/StructuredSpan.js~StructuredSpan#render",
    "access": null,
    "description": "render",
    "lineNumber": 33,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 148,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/index.js",
    "memberof": null,
    "longname": "src/core/components/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Components - generic components to be used in several places of the lib\n * @module components\n */\n\nexport { default as StaticBackCover } from './StaticComponents/StaticBackCover.js';\nexport { default as StaticDocument } from './StaticComponents/StaticDocument.js';\nexport { default as StaticEndNotes } from './StaticComponents/StaticEndNotes.js';\nexport { default as StaticEndFigures } from './StaticComponents/StaticEndFigures.js';\nexport { default as StaticFootnote } from './StaticComponents/StaticFootnote.js';\nexport { default as StaticFrontCover } from './StaticComponents/StaticFrontCover.js';\nexport { default as StaticGlossary } from './StaticComponents/StaticGlossary.js';\nexport { default as StaticImageFigure } from './StaticComponents/StaticImageFigure.js';\nexport { default as StaticNoteContent } from './StaticComponents/StaticNoteContent.js';\nexport { default as StaticNotePointer } from './StaticComponents/StaticNotePointer.js';\nexport { default as StaticReferencesList } from './StaticComponents/StaticReferencesList.js';\nexport { default as StaticSection } from './StaticComponents/StaticSection.js';\nexport { default as StaticTableOfContents } from './StaticComponents/StaticTableOfContents.js';\nexport { default as StaticTableOfFigures } from './StaticComponents/StaticTableOfFigures.js';\n\nexport { default as StructuredCite } from './StructuredDataComponents/StructuredCite.js';\nexport { default as StructuredCOinS } from './StructuredDataComponents/StructuredCOinS.js';\nexport { default as StructuredDate } from './StructuredDataComponents/StructuredDate.js';\nexport { default as StructuredHyperLink } from './StructuredDataComponents/StructuredHyperLink.js';\nexport { default as StructuredMetadataPlaceholder } from './StructuredDataComponents/StructuredMetadataPlaceholder.js';\nexport { default as StructuredParentJournal } from './StructuredDataComponents/StructuredParentJournal.js';\nexport { default as StructuredPerson } from './StructuredDataComponents/StructuredPerson.js';\nexport { default as StructuredPublisher } from './StructuredDataComponents/StructuredPublisher.js';\nexport { default as StructuredSpan } from './StructuredDataComponents/StructuredSpan.js';\n"
  },
  {
    "__docId__": 149,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/controllers/annotationsController/index.js",
    "memberof": null,
    "longname": "src/core/controllers/annotationsController/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Annotations controller - a set of pure functions for interacting with an annotations source (through a connector)\n * @module controllers/annotationsController\n * @todo everything\n */\n"
  },
  {
    "__docId__": 150,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/controllers/assetsController/index.js",
    "memberof": null,
    "longname": "src/core/controllers/assetsController/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Assets controller - a set of pure functions for interacting with an assets source (through a connector)\n * @module controllers/assetsController\n */\n\nlet connector;\nlet connectorName;\nlet tempConnectorName;\n\n/**\n* Updates the active connector module according to connection params\n* @param {Object} params - connection params\n*/\nconst updateConnector = (params)=> {\n  tempConnectorName = params.connector;\n  if (tempConnectorName !== connectorName) {\n    connectorName = tempConnectorName;\n    connector = require('./../../../connectors/' + params.connector);\n  }\n};\n\n/**\n * Provides the URI of a specific assets file from connector\n * @param {array|string} path - the path of the assets file to look for\n * @param {Object} params - connection params\n * @return {function(connectorError: error, uri: string)} callback - possible errors and the uri\n*/\nexport const getAssetUri = (path, params, callback)=> {\n  updateConnector(params);\n  connector.getAssetUri({path, params}, callback);\n};\n\n/**\n* Returns an appropriate connector function for directly reading a file from assets source\n* @param {Object} params - connection params\n* @return {function(err: error, res: Object)} readFunction - the connector function for directly reading a file contents from assets source\n*/\nexport const getReader = (params) =>{\n  updateConnector(params);\n  return connector.readFromPath;\n};\n"
  },
  {
    "__docId__": 151,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateConnector",
    "memberof": "src/core/controllers/assetsController/index.js",
    "longname": "src/core/controllers/assetsController/index.js~updateConnector",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/controllers/assetsController/index.js",
    "importStyle": null,
    "description": "Updates the active connector module according to connection params",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getAssetUri",
    "memberof": "src/core/controllers/assetsController/index.js",
    "longname": "src/core/controllers/assetsController/index.js~getAssetUri",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/assetsController/index.js",
    "importStyle": "{getAssetUri}",
    "description": "Provides the URI of a specific assets file from connector",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "the path of the assets file to look for"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(connectorError: error, uri: string)"
      ],
      "spread": false,
      "description": "callback - possible errors and the uri"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getReader",
    "memberof": "src/core/controllers/assetsController/index.js",
    "longname": "src/core/controllers/assetsController/index.js~getReader",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/assetsController/index.js",
    "importStyle": "{getReader}",
    "description": "Returns an appropriate connector function for directly reading a file from assets source",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(err: error, res: Object)"
      ],
      "spread": false,
      "description": "readFunction - the connector function for directly reading a file contents from assets source"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/controllers/contentsController/index.js",
    "memberof": null,
    "longname": "src/core/controllers/contentsController/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Contents controller - a set of pure functions for parsing and serializing fsTree representations to peritextSections representations\n * @module controllers/contentsController\n */\n\nimport {waterfall, map as asyncMap} from 'async';\nimport {parseSection, serializeSectionList} from './../../converters/sectionConverter';\nimport {diff} from 'deep-diff';\nimport * as filesystem from './../../../connectors/filesystem';\nlet connector;\nlet connectorName;\nlet tempConnectorName;\n\n/**\n* Updates the active connector module according to connection params\n* @param {Object} params - connection params\n*/\nconst updateConnector = (params) => {\n  tempConnectorName = params.connector;\n  if (tempConnectorName !== connectorName) {\n    connectorName = tempConnectorName;\n    if ( connectorName === 'filesystem' ) {\n      connector = filesystem;\n    }\n    // this method is better but does not work when integrating the lib with webpack\n    // connector = require('./../../../connectors/' + params.connector);\n  }\n};\n\n/**\n* Resolves a difference object through Create/Update/Delete operations\n* @param {Object} difference - the difference object specifying type of difference and details\n* @param {Object} params - connection params\n* @param {Object} connect - connector module\n* @param {function(connectorError: error, connectorResult)} callback - provided by connector\n*/\nconst applyDifference = (difference, params, connect, callback) => {\n  let item;\n  switch (difference.kind) {\n  // new element\n  case 'N':\n    console.log('unhandled new element difference ', difference);\n    break;\n  // delete element\n  case 'D':\n    connect.deleteFromPath({path: difference.lhs.path, params}, callback);\n    break;\n  // edit element\n  case 'E':\n    if (difference.path.pop() === 'path') {\n      return callback();\n    }\n    console.log('unhandled edit difference ', difference);\n    break;\n  // change in array\n  case 'A':\n    switch (difference.item.kind) {\n    case 'N':\n      item = difference.item.rhs;\n      waterfall([\n        // create root\n        function(cb) {\n          connect.createFromPath({path: item.path, params, type: item.type, overwrite: true, stringContents: (item.stringContents || '')}, cb);\n        },\n        // create children\n        function(cb) {\n          if (item.children) {\n            asyncMap(item.children, function(child, cb2) {\n              connect.createFromPath({path: child.path, params, type: child.type, overwrite: true, stringContents: (child.stringContents || '')}, cb2);\n            }, cb);\n          } else cb();\n        }\n      ], callback);\n      break;\n\n    case 'D':\n      item = difference.item.lhs;\n      connect.deleteFromPath({path: item.path, params}, callback);\n      break;\n    case 'E':\n      item = difference.item.rhs;\n      waterfall([\n        // create root\n        function(cb) {\n          connect.updateFromPath({path: item.path, params, stringContents: (item.stringContents || '')}, cb);\n        },\n        // create children\n        function(cb) {\n          if (item.children) {\n            asyncMap(item.children, function(child, cb2) {\n              connect.updateFromPath({path: child.path, params, stringContents: (child.stringContents || '')}, cb2);\n            }, cb);\n          } else cb();\n        }\n      ], callback);\n      break;\n    default:\n      console.log('unhandled difference ', difference);\n      break;\n    }\n    break;\n  default:\n    console.log('unhandled difference ', difference);\n    break;\n  }\n  callback();\n};\n\n/**\n  * @param {Object} params - connection params\n  * @param {Object} models - peritext models to use\n  * @param {Object} parametesr - language templates parameters - with which expressions are templates or includes wrapped ?\n  * @param {function(parsingErrors: error, results:Object)} callback - block errors and a result object containing section and an array of warnings+parsing errors\n  */\nexport const updateFromSource = (params, models, parameters, callback) => {\n  updateConnector(params);\n  waterfall([\n    function(cb) {\n      connector.readFromPath({params, path: [], depth: true, parseFiles: true}, function(err, results) {\n        cb(err, results);\n      });\n    },\n    function(tree, cb) {\n      parseSection({tree, models, parameters}, cb);\n    }\n  ],\n  function(err, results) {\n    callback(err, results);\n  });\n};\n\n/**\n* Serializes the representation of a series of peritext sections to an fsTree representation by \"diffing\" new fsTree with previous fsTree\n* then makes a diff list with deep-diff\n* then monitor source tree updating (with C.U.D. operations) accordingly\n* @param {Object} params - connection params\n* @param {array} sections - the peritext sections to serialize\n* @param {Object} models - peritext models to use\n* @param {Object} oldFsTree - the previous fsTree representation to compare with the new\n* @param {function(serializingErrors: error, sections:array)} callback - errors and input sections\n*/\nexport const updateToSource = (params, sections, models, oldFsTree, callback) => {\n  updateConnector(params);\n  serializeSectionList({sectionList: sections, models, basePath: params.basePath}, function(err, newFsTree) {\n    const differences = diff(oldFsTree, newFsTree);\n    asyncMap(differences, function(difference, cb) {\n      applyDifference(difference, params, connector, cb);\n    }, function(errors, res) {\n      callback(errors, sections);\n    });\n  });\n};\n"
  },
  {
    "__docId__": 155,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateConnector",
    "memberof": "src/core/controllers/contentsController/index.js",
    "longname": "src/core/controllers/contentsController/index.js~updateConnector",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/controllers/contentsController/index.js",
    "importStyle": null,
    "description": "Updates the active connector module according to connection params",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "applyDifference",
    "memberof": "src/core/controllers/contentsController/index.js",
    "longname": "src/core/controllers/contentsController/index.js~applyDifference",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/controllers/contentsController/index.js",
    "importStyle": null,
    "description": "Resolves a difference object through Create/Update/Delete operations",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "difference",
        "description": "the difference object specifying type of difference and details"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "connect",
        "description": "connector module"
      },
      {
        "nullable": null,
        "types": [
          "function(connectorError: error, connectorResult)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "provided by connector"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateFromSource",
    "memberof": "src/core/controllers/contentsController/index.js",
    "longname": "src/core/controllers/contentsController/index.js~updateFromSource",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/contentsController/index.js",
    "importStyle": "{updateFromSource}",
    "description": "",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "peritext models to use"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parametesr",
        "description": "language templates parameters - with which expressions are templates or includes wrapped ?"
      },
      {
        "nullable": null,
        "types": [
          "function(parsingErrors: error, results:Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "block errors and a result object containing section and an array of warnings+parsing errors"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateToSource",
    "memberof": "src/core/controllers/contentsController/index.js",
    "longname": "src/core/controllers/contentsController/index.js~updateToSource",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/contentsController/index.js",
    "importStyle": "{updateToSource}",
    "description": "Serializes the representation of a series of peritext sections to an fsTree representation by \"diffing\" new fsTree with previous fsTree\nthen makes a diff list with deep-diff\nthen monitor source tree updating (with C.U.D. operations) accordingly",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "sections",
        "description": "the peritext sections to serialize"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "peritext models to use"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "oldFsTree",
        "description": "the previous fsTree representation to compare with the new"
      },
      {
        "nullable": null,
        "types": [
          "function(serializingErrors: error, sections:array)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "errors and input sections"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/bibTexConverter/index.js",
    "memberof": null,
    "longname": "src/core/converters/bibTexConverter/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module parses and serializes bibTex objects\n * @module converters/bibTexConverter\n */\n\n/**\n * homemade bibTeX syntax parser (performance could be improved I guess)\n * it needs a second pass to parse {} in values and analyze them against a model - that should be done elsewhere, as this converter just deals with syntax-to-object conversion\n */\nclass bibTexParser {\n  /**\n   * constructor\n   */\n  constructor() {\n    this.STATES = ['bibType', 'citeKey', 'properties'];\n  }\n\n  /**\n   * Adds a key+value prop to the resource's javascript representation object\n   * @param {object} obj - the resource representation\n   * @param {string} key - the key to populate\n   * @param {string} value - the value to set\n   * @return {object} newObj - the updated resource representation\n   */\n  addValue(obj, key, value) {\n    if (obj[key]) {\n\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      }else obj[key] = [obj[key], value];\n\n    }else obj[key] = value;\n\n    return obj;\n  }\n\n  /**\n   * Consumes a string (stored in this.consumable) representation of a bibTeX expression\n   * @return {boolean} exit - a simple exit trigger (but internal props will have been mutated)\n   */\n  consume() {\n    const matchBibType = /^@([^{]+)/;\n    const matchCiteKey = /^{([^,]+),/;\n    const wrappers = [\n      ['{', '}'],\n      ['\"', '\"'],\n      [\"'\", \"'\"]\n    ];\n    let match;\n    if (this.currentState === 'bibType') {\n      match = matchBibType.exec(this.consumable);\n      if (match) {\n        this.currentObject.bibType = match[1];\n        this.consumable = this.consumable.substr(match[1].length + 1);\n        this.currentState = this.STATES[1];\n        return true;\n      }\n      this.error = {\n        type: 'error',\n        preciseType: 'bibParsingError',\n        message: 'could not find bibType',\n        initialString: this.initialStr\n      };\n      return true;\n\n    }else if (this.currentState === 'citeKey') {\n      match = matchCiteKey.exec(this.consumable);\n      if (match) {\n        this.currentObject.citeKey = match[1];\n        this.consumable = this.consumable.substr(match[1].length + 2);\n        this.currentState = this.STATES[2];\n        return true;\n      }\n      this.error = {\n        type: 'error',\n        preciseType: 'bibParsingError',\n        message: 'could not find citekey',\n        initialString: this.initialStr\n      };\n      return true;\n\n    /*\n     * ``key = value`` structure\n     * value is always wrapped inside character couples that vary depending on bibtex implementation (\" { ')\n     * possibility of nested wrapping (eg {Name {{S}urname}})\n     */\n    }else if (this.currentState === 'properties') {\n      const wrapped = [wrappers[0]];\n      let index = 0;\n      let mode = 'key';\n      let temp = '';\n      let tempKey = '';\n      let trespassing;\n      let character;\n      let entering;\n\n      while (wrapped.length > 0) {\n\n        trespassing = index > this.consumable.length - 1;\n        character = this.consumable.charAt(index);\n\n        if (trespassing) {\n          this.error = {\n            type: 'error',\n            preciseType: 'bibParsingError',\n            message: 'finished to parse bibtex string without finding closing character ' + wrapped[wrapped.length - 1][1],\n            initialString: this.initialStr\n          };\n          return true;\n        // end of wrapped expression - if matches with last recorded wrapper's closing character\n        }else if (character === wrapped[wrapped.length - 1][1]) {\n          wrapped.pop();\n          if (wrapped.length > 1) {\n            temp += character;\n          }\n          index = 1;\n        // end of key specification, record tempkey and wait to have found value\n        }else if (mode === 'key' && character === '=') {\n          tempKey = temp.trim();\n          temp = '';\n          mode = 'value';\n          index = 1;\n        // end of value specification - add value and reboot temp\n        }else if (mode === 'value' && wrapped.length < 2 && character === ',') {\n          this.addValue(this.currentObject, tempKey, temp.trim());\n          temp = '';\n          mode = 'key';\n          index = 1;\n        // in the middle of some key or value = continue\n        }else if (mode === 'value') {\n          entering = false;\n          // catch wrapper char\n          wrappers.some((wrapper) => {\n            if (this.consumable.charAt(index) === wrapper[0]) {\n              entering = true;\n              return wrapped.push(wrapper);\n            }\n          });\n          if (!(entering && wrapped.length <= 2)) {\n            temp += character;\n          }\n          index = 1;\n        // default, by security\n        }else {\n          temp += character;\n          index = 1;\n        }\n        this.consumable = this.consumable.substr(index);\n      }\n      this.addValue(this.currentObject, tempKey.trim(), temp.trim());\n\n      // add if not empty\n      if (Object.keys(this.currentObject).length) {\n        this.results.push(Object.assign({}, this.currentObject));\n      }\n      this.currentObject = {};\n      this.consumable = this.consumable.substr(index).trim();\n      this.currentState = this.STATES[0];\n      return true;\n    }\n  }\n\n\n  /**\n   * Parses a bibTeX string and callbacks a javascript objet\n   * @param {string} str - the string to parse\n   * @param {function(error:error, results:Object)} callback\n   */\n  parse(str, callback) {\n    this.currentObject = {};\n    this.currentState = this.STATES[0];\n    this.results = [];\n    this.consumable = str.trim();\n    this.initialStr = str.trim();\n    this.error = null;\n    while (this.error === null && this.consumable.trim().length > 0) {\n      this.consume();\n    }\n    return callback(this.error, this.results);\n  }\n\n}\n\nconst parser = new bibTexParser();\n\nconst validateBibObject = function(bibObject) {\n  if (bibObject.citeKey === undefined) {\n    return {\n      type: 'error',\n      preciseType: 'bibObjectValidationError',\n      message: 'bibObject must have a citeKey property',\n      bibObject: bibObject\n    };\n  } else if (bibObject.bibType === undefined) {\n    return {\n      type: 'error',\n      preciseType: 'bibObjectValidationError',\n      message: 'bibObject must have a bibType property',\n      bibObject: bibObject\n    };\n  }\n\n  for (const key in bibObject) {\n    if (typeof bibObject[key] === 'object' && !Array.isArray(bibObject[key])) {\n      return {\n        type: 'error',\n        preciseType: 'bibObjectValidationError',\n        message: 'bibObject cannot contain nested objects',\n        bibObject: bibObject\n      };\n    }\n  }\n\n  return true;\n};\n\n/**\n * Serializes a javascript object representing a resource or a contextualizer, to a bibTeX-formatted string\n * @param {object} bibObject - the resource/contextualizer representation\n * @return {function(error:error, bibStr: string)} callback - error and the bibTeX mention as a string\n */\nexport const serializeBibTexObject = (bibObject, callback) => {\n  const validated = validateBibObject(bibObject);\n  if (validated.type === 'error') {\n    return callback(validated, undefined);\n  }\n  let str = '';\n  let val;\n  for (const key in bibObject) {\n    if (bibObject[key]) {\n      val = bibObject[key];\n      if (Array.isArray(val)) {\n        val.forEach((value)=>{\n          str += '\\t' + key + ' = {' + value + '},\\n';\n        });\n        //  val = val.join(',');\n      }else if (key !== 'citeKey' && key !== 'bibType') {\n        str += '\\t' + key + ' = {' + val + '},\\n';\n      }\n    }\n  }\n  // removing the last coma\n  if (str.length > 1) {\n    str = str.substr(0, str.length - 2);\n  }\n  return callback(null, `@${bibObject.bibType}{${bibObject.citeKey},\n    ${str}\n}`);\n};\n\n/**\n * Parses a bibTeX string and returns an object\n * @param {string} str - the bibTeX string to parse\n * @return {function(error: error, result: Object)} callback - error and the resulting object\n */\nexport const parseBibTexStr = (str, callback) => {\n  if (typeof str === 'string') {\n    return parser.parse(str, callback);\n  }\n  return callback(new Error('must input a string'), undefined);\n};\n\n/**\nAccepted inputs for authors and persons (to add in doc/spec):\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\nMaskin, Eric S.\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\nMaskin, Eric S.\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\n*/\n\n/**\n * Parses a list of authors as they are formatted in bbiTeX statements\n * @param {string} str - the bibTeX string to parse\n * @return {array} authors - the javascript representation of authors as an array\n */\nexport const parseBibAuthors = (str) => {\n  const authors = str.split(/;|and|et/);\n  const additionalInfo = /\\(([^)]*)?\\)?\\(?([^)]*)?\\)?/;\n  let match;\n  return authors.filter((inputStr) =>{\n    return inputStr.trim().length > 0;\n  }).map((inputAuthorStr) =>{\n    let workingStr = inputAuthorStr;\n    let authorStr = '';\n    let firstName;\n    let lastName;\n    let role = 'author';\n    let information;\n    match = inputAuthorStr.match(additionalInfo);\n    if (match) {\n      workingStr = workingStr.replace(match[0], '');\n      if (match[1]) {\n        role = match[1].trim();\n      }\n      if (match[2]) {\n        information = match[2];\n        information = information.trim();\n      }\n    }\n    const lastNameMatch = workingStr.match(/{([^}]*)}/);\n    if (lastNameMatch) {\n      lastName = lastNameMatch[1].trim();\n      authorStr = [workingStr.substr(0, lastNameMatch.index), workingStr.substr(lastNameMatch.index + lastNameMatch[0].length)].join('');\n      firstName = authorStr.replace(',', '').trim();\n    } else {\n      let vals = workingStr.split(',');\n      if (vals.length > 1) {\n        firstName = vals[1].trim();\n        lastName = vals[0].trim();\n      } else if (workingStr.trim().indexOf(' ') > -1) {\n        vals = workingStr.trim().split(' ');\n        firstName = vals.shift().trim();\n        lastName = vals.join(' ').trim();\n      } else {\n        lastName = workingStr.trim();\n        firstName = '';\n      }\n    }\n    const citeKey = (role + '-' + firstName + lastName).toLowerCase().replace(' ', '-');\n    return {firstName, lastName, role, information, citeKey};\n  });\n};\n\n/**\n * Parses a bibTeX-like contextualization statement given as string and returns an object\n * @param {string} inputStr - the bibTeX string to parse\n * @return {Object} contextualization - the contextualization object\n */\nexport const parseBibContextualization = (inputStr) => {\n  const bracketsRE = /([^=^,]+)=(?:{)([^}]*)(?:}),?/g;\n  const quoteRE = /([^=^,]+)=\"([^\"]*)\",?/g;\n  const paramsObject = {};\n\n\n  const str = inputStr.substr(1, inputStr.length - 2).replace(/&quot;/g, '\"');\n  let match;\n  let key;\n  let expression;\n  let subObject;\n  let newObj;\n\n  while ((match = bracketsRE.exec(str)) !== null) {\n    key = match[1].trim();\n    expression = match[2].trim().split(',');\n    // simple\n    if (expression.length === 1) {\n      paramsObject[key] = expression[0];\n    // nested\n    } else {\n      subObject = {};\n\n      let isArray;\n\n      expression = expression.map((exp) =>{\n        const split = exp.split('=');\n        if (split.length === 2) {\n          isArray = false;\n          return {\n            key: split[0],\n            value: split[1]\n          };\n        }\n        isArray = true;\n        return exp;\n      });\n\n      if (!isArray) {\n        subObject = expression.reduce((obj, exp)=>{\n          obj[exp.key] = exp.value;\n          return obj;\n        }, subObject);\n      }\n\n      newObj = Object.assign({}, subObject);\n\n      if (paramsObject[key] === undefined) {\n        paramsObject[key] = newObj;\n      } else if (Array.isArray(paramsObject[key])) {\n        paramsObject[key].push(newObj);\n      } else paramsObject[key] = [paramsObject[key], newObj];\n    }\n\n  }\n\n  while ((match = quoteRE.exec(str)) !== null) {\n    key = match[1].trim();\n    expression = match[2].trim();\n    paramsObject[key] = expression;\n  }\n\n  return paramsObject;\n};\n\n\nconst resolveNested = (subVal) => {\n  if (typeof subVal !== 'string') {\n    return subVal;\n  }\n  let expression = subVal.split(',');\n  let subObject;\n  let newObj;\n  // simple\n  if (expression.length === 1) {\n    return subVal;\n  // nested\n  }\n  subObject = {};\n  let isArray;\n  expression = expression.map((exp) =>{\n    const split = exp.split('=');\n    if (split.length === 2) {\n      isArray = false;\n      return {\n        key: split[0],\n        value: split[1]\n      };\n    }\n    isArray = true;\n    return exp;\n  });\n\n  if (!isArray) {\n    subObject = expression.reduce((obj, exp)=>{\n      obj[exp.key] = exp.value;\n      return obj;\n    }, subObject);\n  }\n\n  newObj = Object.assign({}, subObject);\n  return newObj;\n};\n\n/**\n * Parses bibTeX nested values inside a bibObject\n * @param {Object} bibObject - the object to parse\n * @return {Object} newObject - the resulting updated object\n */\nexport const parseBibNestedValues = (bibObject) => {\n  const newObject = Object.assign({}, bibObject);\n  let subVal;\n  for (const index in newObject) {\n    if (newObject[index]) {\n      subVal = newObject[index];\n      if (Array.isArray(subVal)) {\n        newObject[index] = bibObject[index].map(resolveNested);\n      }else {\n        newObject[index] = resolveNested(newObject[index]);\n      }\n    }\n  }\n  return newObject;\n};\n"
  },
  {
    "__docId__": 160,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "bibTexParser",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": null,
    "description": "homemade bibTeX syntax parser (performance could be improved I guess)\nit needs a second pass to parse {} in values and analyze them against a model - that should be done elsewhere, as this converter just deals with syntax-to-object conversion",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 161,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#constructor",
    "access": null,
    "description": "constructor",
    "lineNumber": 14,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 162,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "STATES",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#STATES",
    "access": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "addValue",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#addValue",
    "access": null,
    "description": "Adds a key+value prop to the resource's javascript representation object",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the resource representation"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key to populate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "newObj - the updated resource representation"
    },
    "generator": false
  },
  {
    "__docId__": 164,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "consume",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#consume",
    "access": null,
    "description": "Consumes a string (stored in this.consumable) representation of a bibTeX expression",
    "lineNumber": 41,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "exit - a simple exit trigger (but internal props will have been mutated)"
    },
    "generator": false
  },
  {
    "__docId__": 165,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentObject",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#currentObject",
    "access": null,
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 157,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 158,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "parse",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#parse",
    "access": null,
    "description": "Parses a bibTeX string and callbacks a javascript objet",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the string to parse"
      },
      {
        "nullable": null,
        "types": [
          "function(error:error, results:Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 177,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentObject",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#currentObject",
    "access": null,
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "results",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#results",
    "access": null,
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "initialStr",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#initialStr",
    "access": null,
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter/index.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter/index.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parser",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~parser",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 184,
    "undocument": true,
    "type": {
      "types": [
        "bibTexParser"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "validateBibObject",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~validateBibObject",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "params": [
      {
        "name": "bibObject",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 185,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializeBibTexObject",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~serializeBibTexObject",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": "{serializeBibTexObject}",
    "description": "Serializes a javascript object representing a resource or a contextualizer, to a bibTeX-formatted string",
    "lineNumber": 222,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "bibObject",
        "description": "the resource/contextualizer representation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(error:error, bibStr: string)"
      ],
      "spread": false,
      "description": "callback - error and the bibTeX mention as a string"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibTexStr",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~parseBibTexStr",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": "{parseBibTexStr}",
    "description": "Parses a bibTeX string and returns an object",
    "lineNumber": 256,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the bibTeX string to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(error: error, result: Object)"
      ],
      "spread": false,
      "description": "callback - error and the resulting object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibAuthors",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~parseBibAuthors",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": "{parseBibAuthors}",
    "description": "Parses a list of authors as they are formatted in bbiTeX statements",
    "lineNumber": 286,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the bibTeX string to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "authors - the javascript representation of authors as an array"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibContextualization",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~parseBibContextualization",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": "{parseBibContextualization}",
    "description": "Parses a bibTeX-like contextualization statement given as string and returns an object",
    "lineNumber": 339,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputStr",
        "description": "the bibTeX string to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "contextualization - the contextualization object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveNested",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~resolveNested",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 405,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibNestedValues",
    "memberof": "src/core/converters/bibTexConverter/index.js",
    "longname": "src/core/converters/bibTexConverter/index.js~parseBibNestedValues",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter/index.js",
    "importStyle": "{parseBibNestedValues}",
    "description": "Parses bibTeX nested values inside a bibObject",
    "lineNumber": 448,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bibObject",
        "description": "the object to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newObject - the resulting updated object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/markdownConverter/index.js",
    "memberof": null,
    "longname": "src/core/converters/markdownConverter/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module resolves markdown contents + peritext-specific assertions (notes, contextualizations, contextualizers)\n * It returns a representation of a section's content as an object containing arrays of: DOM children as js representation, notes, contextualizations, contextualizers\n * @module converters/markdownConverter\n */\nimport marked from 'marked';\nimport {html2json} from 'html2json';\nimport {XmlEntities} from 'html-entities';\nconst entities = new XmlEntities();\n\nimport {getMetaValue} from './../../utils/sectionUtils';\nimport {parseBibContextualization, parseBibNestedValues} from './../bibTexConverter';\n\n// basic marked parser settings\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: true,\n  smartLists: true,\n  smartypants: false\n});\n\nconst eatParamsObject = (str)=> {\n  let index = 0;\n  let wrappingLevel = 0;\n  let paramsObject = '';\n  let inObject = false;\n  let ch;\n  while (index < str.length) {\n    ch = str.charAt(index);\n    if (ch === '{') {\n      wrappingLevel++;\n    }else if (ch === '}') {\n      wrappingLevel--;\n    }\n\n    if (!inObject && wrappingLevel > 0) {\n      inObject = true;\n      paramsObject += ch;\n    } else if (inObject && wrappingLevel === 0) {\n      paramsObject += ch;\n      return paramsObject;\n    } else if (inObject) {\n      paramsObject += ch;\n      // not in object, character is neither a wrapper nor a whitespace, leave\n    } else if (!inObject && ch.match(/([\\s])/) === null) {\n      return undefined;\n    }\n    index++;\n  }\n  return undefined;\n};\n\nconst parseParamsObject = (paramsObject, impliedResources, contextualizationCount, contextualizers)=> {\n  /*\n   * analyse contextualizer statement\n  */\n  let overloading;\n  let contextualizerKey;\n  // case : explicit call to a contextualizer ==> overload\n  if (paramsObject && paramsObject.indexOf('@') === 1) {\n    contextualizerKey = paramsObject.match(/^\\{(@[^,}]+)/)[1];\n    overloading = contextualizerKey;\n    let counter = 1;\n    let newKey = contextualizerKey + '_' + counter;\n    let unique = false;\n    // getting a unique citeKey for the overloaded contextualizer\n    while (!unique) {\n      unique = true;\n      contextualizers.forEach((cont) => {\n        if (cont.citeKey === newKey) {\n          unique = false;\n          counter++;\n          newKey = contextualizerKey + '_' + counter;\n        }\n      });\n    }\n    contextualizerKey = newKey;\n  // case : no explicit call to a contextualizer ==> inline implicit contextualization, determine citeKey automatically\n  }else {\n    contextualizerKey = 'contextualizer_' + contextualizationCount + 1;\n  }\n\n  let formattedParams;\n  if (paramsObject !== undefined) {\n    formattedParams = parseBibContextualization(paramsObject);\n    const emptyParams = JSON.stringify(formattedParams).length <= 2;\n    // not empty = params present, so inline (implicit new contextualizer, or contextualizer overloading)\n    if (!emptyParams) {\n      formattedParams.describedInline = true;\n    // case : no additionnal params ==> no parameters\n    } else {\n      formattedParams = {};\n    }\n  // case : no mention of a contextualizer fully implicit contextualizer (no contextualizer specified)\n  } else {\n    formattedParams = {};\n    formattedParams.describedInline = true;\n    formattedParams.fullyImplicit = true;\n  }\n  // case : a contextualizer has been mentionned, with additionnal contextualization params --> contextualizer overloading\n  if (overloading) {\n    formattedParams.overloading = overloading;\n  }\n  formattedParams.citeKey = contextualizerKey;\n  return formattedParams;\n};\n\nconst parseContextualizations = (section)=> {\n  let replaced = section.contents;\n  const contextualizations = [];\n  const newContextualizers = section.contextualizers.slice();\n  const statementsRE = /(\\!)?\\[([^\\]]*)\\]\\(([^\\)]+)\\)/g;\n  let match;\n  let type;\n  let resources;\n  let paramsObject;\n  let contextualizationCount = -1;\n\n  while ((match = statementsRE.exec(replaced)) !== null) {\n    /*\n     * retrieve data from markdown expressions\n     */\n    // hyperlink markdown syntax stands for inline contextualization\n    // image markdown syntax stands for block contextualization\n    // ()[] = inline, !()[] = block\n    type = match[1] ? 'block' : 'inline';\n    // contents\n    // children = match[2];\n    // quoted resources\n    resources = match[3].split(',').map((resKey)=> {\n      const key = resKey.substr(1);\n      return section.resources.find(res=> {\n        return res.citeKey === key;\n      });\n    }).filter(res=>{\n      return res !== undefined;\n    });\n\n    contextualizationCount ++;\n    // following parameters\n    paramsObject = eatParamsObject(replaced.substr(match.index + match[0].length));\n\n    // UPDATE TEXT\n    // delete paramsObject from text\n    if (paramsObject) {\n      replaced = replaced.replace(replaced.substring(match.index + match[0].length, match.index + match[0].length + paramsObject.length), '');\n    }\n    // update reference in <a> link or <image>\n    replaced = replaced.replace(replaced.substring(match.index + match[0].indexOf(match[3]), match.index + match[0].indexOf(match[3]) + match[3].length), 'contextualization_' + contextualizationCount);\n    // UPDATE DATA\n    const contextualizer = parseParamsObject(paramsObject, resources, contextualizationCount, newContextualizers);\n    if (contextualizer) {\n      newContextualizers.push(contextualizer);\n    }\n    contextualizations.push({\n      // 'matchIndex': match.index - matchDisplace,\n      'citeKey': 'contextualization_' + contextualizationCount,\n      contextualizer,\n      resources,\n      type\n    });\n  }\n  return {md: replaced, contextualizations, contextualizers: newContextualizers};\n};\n\n\n// this module does not use a regex-based method\n// because it must catch possible nested content-related \"{\" brackets symbols\n// e.g. : this is an {example inside brackets}\nconst parseNotes = (md, sectionCiteKey)=> {\n  const notes = [];\n  let noteNumber = 1;\n  let index = 0;\n  let displace = 0;\n  let beginIndex;\n  let nestingLevel = 0;\n  let ch;\n  let newMd = md;\n  let noteContent;\n  while (newMd.substr(displace).indexOf('[^]{') > -1) {\n    index = displace + newMd.substring(displace).indexOf('[^]{') + 4;\n    beginIndex = index;\n    nestingLevel = 1;\n\n    while (index < newMd.length && nestingLevel > 0) {\n      ch = newMd.charAt(index);\n      if (ch === '{') {\n        nestingLevel++;\n      } else if (ch === '}') {\n        nestingLevel--;\n      }\n      index++;\n    }\n\n    noteContent = newMd.substring(beginIndex, index - 1);\n    const id = sectionCiteKey + noteNumber;\n    const placeholder = `[footnote](note_${id})`;\n    const initialLength = index - beginIndex + 4;\n    const lengthDif = initialLength - placeholder.length;\n    newMd = newMd.replace(newMd.substring(beginIndex - 4, index), placeholder);\n    notes.push({\n      noteNumber,\n      contents: noteContent,\n      id\n    });\n    noteNumber++;\n    displace = index - lengthDif;\n  }\n  return {\n    notes,\n    newMd\n  };\n};\n\nlet mapMdJsonToPJson = ()=>{return undefined;};\nlet representContents = ()=>{return undefined;};\n\nmapMdJsonToPJson = (inputElement, contextualizations, blockIndex) =>{\n  const element = Object.assign({}, inputElement);\n  element.blockIndex = blockIndex;\n  if (element.text) {\n    element.text = entities.decode(element.text);\n  }\n  if (element.tag === 'a') {\n    if (element.attr.href.indexOf('note_') === 0) {\n      element.tag = 'note';\n      element.target = element.attr.href.substr(5);\n    } else {\n      element.tag = 'inlineC';\n      const contextualizationCitekey = element.attr.href;\n      const contextualization = contextualizations.find(cont =>{\n        return cont.citeKey === contextualizationCitekey;\n      });\n      contextualization.node = element;\n    }\n  } else if (element.tag === 'img') {\n    element.tag = 'blockC';\n    const contextualizationCitekey = element.attr.src;\n    const contextualization = contextualizations.find(cont =>{\n      return cont.citeKey === contextualizationCitekey;\n    });\n    contextualization.node = element;\n    const contents = (element.attr && element.attr.alt) ? element.attr.alt.join(' ') : '';\n    element.child = [representContents(contents)[0]];\n  }\n  if (element.child) {\n    element.child = element.child.map((child)=>{\n      return mapMdJsonToPJson(child, contextualizations, blockIndex);\n    });\n  }\n  return element;\n};\n\nrepresentContents = (mdContent, contextualizations) =>{\n  return html2json(marked(mdContent)).child.map((child, blockIndex)=> {\n    return mapMdJsonToPJson(child, contextualizations, blockIndex);\n  });\n};\n\n/**\n * Parses markdown contents in order to update section data with new contents (as a pseudo-DOM nested javascript object representation), notes, contextualizers and contextualizations\n * @param {Object} section - the section to parse\n * @param {Object} parameters - deprecated - rendering parameters (not used at this step)\n * @param {function(error: error, results: {errors: array, section: Object})} callback - the resulting conversion errors and updated section\n */\nexport const markdownToJsAbstraction = (section, parameters, callback)=> {\n  const errors = [];\n\n  const sectionCiteKey = getMetaValue(section.metadata, 'general', 'citeKey');\n\n  section.markdownContents = section.contents;\n  section.contextualizers = section.contextualizers.map(parseBibNestedValues);\n\n  const {\n    md,\n    contextualizers,\n    contextualizations\n  } = parseContextualizations(section);\n  const {\n    notes,\n    newMd\n  } = parseNotes(md, sectionCiteKey);\n\n  section.contextualizations = contextualizations.slice();\n  section.contextualizers = contextualizers.slice();\n  section.contents = representContents(newMd, section.contextualizations);\n  section.notes = notes.map(note =>{\n    const contents = representContents(note.contents, section.contextualizations);\n    return Object.assign(note, {contents: contents[0].child});\n  });\n\n  callback(null, {errors, section});\n};\n"
  },
  {
    "__docId__": 192,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "entities",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~entities",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "html-entities~XmlEntities"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "eatParamsObject",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~eatParamsObject",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseParamsObject",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~parseParamsObject",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseContextualizations",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~parseContextualizations",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseNotes",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~parseNotes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mapMdJsonToPJson",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~mapMdJsonToPJson",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "representContents",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~representContents",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 220,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "markdownToJsAbstraction",
    "memberof": "src/core/converters/markdownConverter/index.js",
    "longname": "src/core/converters/markdownConverter/index.js~markdownToJsAbstraction",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/markdownConverter/index.js",
    "importStyle": "{markdownToJsAbstraction}",
    "description": "Parses markdown contents in order to update section data with new contents (as a pseudo-DOM nested javascript object representation), notes, contextualizers and contextualizations",
    "lineNumber": 270,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to parse"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parameters",
        "description": "deprecated - rendering parameters (not used at this step)"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, results: {errors: array, section: Object})"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "the resulting conversion errors and updated section"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/markdownIncludesParser/index.js",
    "memberof": null,
    "longname": "src/core/converters/markdownIncludesParser/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module analyses special markdown insertions (includes and resources)\n * Takes a peritext-markdown string + syntax params as input\n * Parses inline resources expressions\n * Parses ``include`` statements\n * Returns cleaned string, plus a list of include statements and resources to parse\n * @module converters/markdownIncludesParser\n */\n\nconst regexEscape = function(str) {\n  return str.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\n/**\n * Parses markdown string for markdown files includes statements and inline resources descriptions\n * @param {string} str - the string to parse\n * @param {Object} expressions - the wrapping expressions to use in order to parse includes and inline resources\n * @param {function(error: error, results: {extracted: array, cleanStr: string})} - callback - returns error, results as an array of extracted statements and clean string (without statements)\n */\nexport const parseMarkdown = (str, {includeWrappingChars, resWrappingChars}, callback) => {\n  const includesRegexp = new RegExp(regexEscape(includeWrappingChars[0]) + 'include:([^\\\\\\}]+)' + regexEscape(includeWrappingChars[1]), 'g');\n  const resourcesRegexp = new RegExp(regexEscape(resWrappingChars[0]) + '\\\\\\n([\\\\\\w\\\\\\W]+)\\\\\\n' + regexEscape(resWrappingChars[1]), 'g');\n  let extracted = [];\n  let cleanStr = str;\n  let match;\n  let extr;\n\n  // recursively check for one of the two substitution expressions\n  while (((match = resourcesRegexp.exec(cleanStr)) !== null) || ((match = includesRegexp.exec(cleanStr)) !== null)) {\n    // if match, swipe out original statement\n    cleanStr = [cleanStr.substr(0, match.index - 1), cleanStr.substr(match.index + match[0].length)].join('');\n    // save statement position and type\n    extr = {\n      index: match.index,\n      statement: match[1]\n    };\n    if (match[0].match(resourcesRegexp)) {\n      extr.type = 'resourceStatement';\n    }else if (match[0].match(includesRegexp)) {\n      extr.type = 'includeStatement';\n    }\n    // update other statements' position that would be further in string\n    extracted = extracted.map((ex) => {\n      if (ex.index > extr.index) {\n        ex.index -= match[0].length + 1;\n      }\n      return ex;\n    });\n    extracted.push(extr);\n  }\n\n  // reverse sort (for further string substitution operations)\n  extracted = extracted.sort((one, two) =>{\n    if (one.index > two.index) {\n      return -1;\n    }\n    return 1;\n  });\n  return callback(null, {extracted, cleanStr});\n};\n"
  },
  {
    "__docId__": 201,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "regexEscape",
    "memberof": "src/core/converters/markdownIncludesParser/index.js",
    "longname": "src/core/converters/markdownIncludesParser/index.js~regexEscape",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownIncludesParser/index.js",
    "importStyle": null,
    "description": "This module analyses special markdown insertions (includes and resources)\nTakes a peritext-markdown string + syntax params as input\nParses inline resources expressions\nParses ``include`` statements\nReturns cleaned string, plus a list of include statements and resources to parse",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@module",
        "tagValue": "converters/markdownIncludesParser"
      }
    ],
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseMarkdown",
    "memberof": "src/core/converters/markdownIncludesParser/index.js",
    "longname": "src/core/converters/markdownIncludesParser/index.js~parseMarkdown",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/markdownIncludesParser/index.js",
    "importStyle": "{parseMarkdown}",
    "description": "Parses markdown string for markdown files includes statements and inline resources descriptions",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the string to parse"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "expressions",
        "description": "the wrapping expressions to use in order to parse includes and inline resources"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, results: {extracted: array, cleanStr: string})"
        ],
        "spread": false,
        "optional": false,
        "name": "-",
        "description": "callback - returns error, results as an array of extracted statements and clean string (without statements)"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/sectionConverter/cleanNaiveTree.js",
    "memberof": null,
    "longname": "src/core/converters/sectionConverter/cleanNaiveTree.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module cleans resources and metadata from a naive (resource concatenated) tree\n * @module converter/sectionConverter/cleanNaiveTree\n */\n\nimport {map as asyncMap} from 'async';\n\n/**\n * Resolves resource and metadata statements from a naive representation of a section\n * @param {Object} params - the cleaning params\n * @param {array} params.errors - the inherited parsing errors to pass along to the next step\n * @param {Object} params.validTree - the tree to clean\n * @param {Object} models - the models to parse the resources with\n * @param {function(error: error, results: {errors: array, validTree: Object})} callback - the possible error, a list of parsing minor errors, and the resulting tree\n */\nexport const cleanNaiveTree = ({errors = [], validTree}, models, callback) =>{\n  const contextualizers = [];\n  const naiveTree = Object.assign({}, validTree);\n  let metadata;\n  const hasResources = naiveTree && naiveTree.resources;\n  if (hasResources) {\n    naiveTree.resources = naiveTree.resources.filter(function(res) {\n      // catch metadata\n      let validated;\n      // extract contextualizer descriptions\n      if (res.bibType === 'contextualizer') {\n        contextualizers.push(res);\n        return false;\n      }\n      for (const type in models.sectionTypeModels.acceptedTypes) {\n        if (res.bibType === 'peritext' + type) {\n          metadata = res;\n          return false;\n        }\n      }\n\n      if (!validated) {\n        // verify that the resource type are known\n        for (const otherType in models.resourceModels.individual) {\n          if (res.bibType === otherType) {\n            return true;\n          }\n        }\n      }\n      // if not validated, record error and don't take resource\n      if (!validated) {\n        errors.push({\n          type: 'error',\n          preciseType: 'invalidResource',\n          resourceCiteKey: res.citeKey,\n          message: 'could not find resource type ' + res.bibType + ' for Resource ID ' + res.citeKey\n        });\n        return false;\n      }\n      return true;\n    });\n  }\n  if (metadata === undefined && naiveTree.name.charAt(0) !== '_') {\n    errors.push({\n      type: 'warning',\n      preciseType: 'metadataNotFound',\n      message: 'no metadata specified for the folder ' + naiveTree.name + ' so it was not taken into account'\n    });\n    const newErrors = (errors.length > 0) ? errors.reverse() : null;\n    return callback(null, {errors: newErrors, validTree: undefined});\n  }else if (naiveTree.children) {\n    return asyncMap(naiveTree.children, function(child, cb) {\n      cleanNaiveTree({validTree: child}, models, cb);\n    }, (err, results) =>{\n      // filter valid children tree leaves\n      const children = results\n                      .filter((result)=>{\n                        return result.validTree !== undefined;\n                      })\n                      .map((result) =>{\n                        return result.validTree;\n                      });\n\n      const newErrors = results.reduce((theseErrors, result)=>{\n        return theseErrors.concat(result.errors);\n      }, errors);\n      return callback(null, {errors: newErrors, validTree: Object.assign({}, naiveTree, {metadata}, {children}, {contextualizers})});\n    });\n  }\n  const newErrors = (errors.length > 0) ? errors.reverse() : null;\n  return callback(null, {errors: newErrors, validTree: Object.assign({}, naiveTree, {metadata}, {contextualizers})});\n};\n"
  },
  {
    "__docId__": 204,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "cleanNaiveTree",
    "memberof": "src/core/converters/sectionConverter/cleanNaiveTree.js",
    "longname": "src/core/converters/sectionConverter/cleanNaiveTree.js~cleanNaiveTree",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/sectionConverter/cleanNaiveTree.js",
    "importStyle": "{cleanNaiveTree}",
    "description": "Resolves resource and metadata statements from a naive representation of a section",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the cleaning params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.errors",
        "description": "the inherited parsing errors to pass along to the next step"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.validTree",
        "description": "the tree to clean"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to parse the resources with"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, results: {errors: array, validTree: Object})"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "the possible error, a list of parsing minor errors, and the resulting tree"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/sectionConverter/concatTree.js",
    "memberof": null,
    "longname": "src/core/converters/sectionConverter/concatTree.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module concatenates fsTree contents according to include statements and resolves cases in which several markdown files are in the same directory\n * @module converter/sectionConverter/concatTree\n */\nimport {parseMarkdown as extractIncludes} from './../../converters/markdownIncludesParser';\nimport {map as asyncMap, waterfall} from 'async';\n\nlet resolveFileIncludes;\n\n// Extracts md includes and inline resources descriptions from a file object\nconst populateElementWithIncludes = (child, params, callback) =>{\n  extractIncludes(child.stringContents,\n    {\n      includeWrappingChars: params.templateWrappingCharacters,\n      resWrappingChars: params.inlineResourceDescriptionWrappingCharacters\n    }, function(err, {extracted, cleanStr}) {\n      if (!err) {\n        child.extracted = extracted;\n        child.stringContents = cleanStr;\n      }\n      callback(err, child);\n    });\n};\n\n\n// Produces a nested structure of the included files in a given file\nconst include = (ex, file, mdFilesWithIncludes) =>{\n  let fileIndex;\n  const fileToInclude = mdFilesWithIncludes\n      .find((otherFile, index)=>{\n        if (otherFile.name === ex.statement) {\n          fileIndex = index;\n          return true;\n        }\n      });\n  if (fileToInclude !== undefined) {\n    const fileHasIncludes = fileToInclude\n                              .extracted\n                                .filter((rawExtracted)=>{\n                                  return rawExtracted.type === 'includeStatement';\n                                }).length > 0;\n    if (fileHasIncludes) {\n      resolveFileIncludes(fileToInclude, mdFilesWithIncludes);\n    }\n    file.includes.push(fileToInclude);\n    mdFilesWithIncludes.splice(fileIndex, 1);\n  }\n};\n\n// Monitors the nested including structure population process of a file\nconst doResolveFilesWithIncludes = (file, mdFilesWithIncludes) =>{\n  file.includes = [];\n  file.includeStatements = [];\n  for (let index = file.extracted.length - 1; index >= 0; index--) {\n    const ex = file.extracted[index];\n    if (ex.type === 'includeStatement') {\n      include(ex, file, mdFilesWithIncludes);\n      file.extracted.splice(index, 1);\n      file.includeStatements.push(ex);\n    }\n  }\n};\n\nresolveFileIncludes = doResolveFilesWithIncludes;\n\n// Turns non nested file object into include-based nested file objects\nconst nestIncludes = ({resourcesStr, mdFilesWithIncludes, params}, cb) =>{\n\n  mdFilesWithIncludes.forEach((mdfile) =>{\n    resolveFileIncludes(mdfile, mdFilesWithIncludes);\n  });\n  cb(null, {resourcesStr, mdFilesWithIncludes});\n};\n\n\n// Consumes the nested property 'include' by populating its string contents with includes contents,\n// resolved recursively\nconst buildFinalMdContent = (file) =>{\n  let content = file.stringContents;\n  const hasIncludes = file.includes && file.includes.length && file.includes.length > 0;\n  if (hasIncludes) {\n    file.includeStatements\n      .filter((ex)=>{\n        return ex.type === 'includeStatement';\n      })\n      .forEach((ex)=>{\n        const targetIncluded = file.includes.find((file2)=>{\n          return file2.name === ex.statement;\n        });\n        const contentToInclude = buildFinalMdContent(targetIncluded);\n        content = [content.substr(0, ex.index), contentToInclude, content.substr(ex.index)].join('');\n      });\n  }\n\n  return content;\n};\n\n// Turns an array of nested file objects into one single string\nconst resolveNestedIncludes = ({resourcesStr, mdFilesWithIncludes, params}, cb) =>{\n  const contentStr = mdFilesWithIncludes\n                      .reduce((str, file) => {\n                        return str + buildFinalMdContent(file);\n                      }, '');\n  cb(null, {contentStr, resourcesStr, params});\n};\n\nconst concatCustomizers = (newTree) =>{\n  return newTree.children\n      .filter((child) => {\n        return child.type === 'directory' && child.name.charAt(0) === '_';\n      })\n      .map((child) => {\n        const contents = {};\n        child.children.forEach((subChild) =>{\n          contents[subChild.name] = subChild.stringContents;\n        });\n        return {\n          type: child.name.substr(1),\n          contents\n        };\n      });\n};\n\n/**\n * Turns a fsTree into a dumTree, that is to say a tree which presents .bib resources and .md files contents concatenated by folder (according to inner 'include' statements and then automatically)\n * @param {Object} tree - the fsTree to concatenate\n * @param {Object} params - the language-related parameters\n * @param {function(error: error, newTree: object)} callback - error and the concatenated tree\n */\nexport const concatTree = (tree, params, callback) =>{\n  const newTree = Object.assign({}, tree);\n  // concat .bib res files\n  const resources = newTree.children\n                    .filter((child) => {\n                      return child.type === 'file' && child.extname === '.bib';\n                    })\n                    .reduce((str, child) => {\n                      if (child.stringContents !== undefined) {\n                        return str + '\\n' + child.stringContents;\n                      }\n                      return str;\n                    }, '');\n\n  const mdContents = newTree.children\n                    .filter((child) => {\n                      return child.type === 'file' && child.extname === '.md';\n                    });\n  const childrenDirs = newTree.children\n                    .filter((child) => {\n                      return child.type === 'directory' && child.name.charAt(0) !== '_';\n                    });\n  const childrenCustomizers = concatCustomizers(newTree);\n  waterfall([\n    // extract md files elements includes statements\n    (cb) =>{\n      asyncMap(mdContents, (child, cback) =>{\n        populateElementWithIncludes(child, params, cback);\n      }, (err, mdFilesWithIncludes) =>{\n        // concat extracted bibtex resources\n        const resourcesStr = mdFilesWithIncludes\n                      .reduce((str, mdFile) => {\n                        let newStr = str;\n                        mdFile.extracted\n                          .filter((ex)=>{\n                            return ex.type === 'resourceStatement';\n                          }).forEach((ex)=>{\n                            newStr += ex.statement;\n                          });\n                        return newStr;\n                      }, resources);\n        cb(null, {resourcesStr, mdFilesWithIncludes, params});\n      });\n    },\n    nestIncludes,\n    resolveNestedIncludes\n  ], (err, {resourcesStr, contentStr}) =>{\n    newTree.resourcesStr = resourcesStr;\n    newTree.contentStr = contentStr;\n    if (childrenCustomizers.length > 0) {\n      newTree.customizers = childrenCustomizers;\n    }\n    // recursively repeat dat stuff with children dirs\n    asyncMap(childrenDirs, (dir, cback) =>{\n      concatTree(dir, params, cback);\n    }, (error, populatedDirs) =>{\n      newTree.children = populatedDirs;\n      callback(error, newTree);\n    });\n  });\n};\n"
  },
  {
    "__docId__": 206,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "populateElementWithIncludes",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~populateElementWithIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "include",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~include",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doResolveFilesWithIncludes",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~doResolveFilesWithIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nestIncludes",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~nestIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "buildFinalMdContent",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~buildFinalMdContent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveNestedIncludes",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~resolveNestedIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "concatCustomizers",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~concatCustomizers",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "concatTree",
    "memberof": "src/core/converters/sectionConverter/concatTree.js",
    "longname": "src/core/converters/sectionConverter/concatTree.js~concatTree",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/sectionConverter/concatTree.js",
    "importStyle": "{concatTree}",
    "description": "Turns a fsTree into a dumTree, that is to say a tree which presents .bib resources and .md files contents concatenated by folder (according to inner 'include' statements and then automatically)",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tree",
        "description": "the fsTree to concatenate"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the language-related parameters"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, newTree: object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "error and the concatenated tree"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/sectionConverter/index.js",
    "memberof": null,
    "longname": "src/core/converters/sectionConverter/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module converts an fsTree flatfile abstraction to a documentTree peritext document abstraction\n * @module converters/sectionConverter\n */\n\nimport {waterfall, map as asyncMap} from 'async';\nimport {concatTree} from './concatTree';\nimport {parseTreeResources} from './parseTreeResources';\nimport {organizeTree} from './organizeTree';\nimport {propagateData} from './propagateData';\nimport {cleanNaiveTree} from './cleanNaiveTree';\nimport {validateResources} from './../../validators/sectionValidator';\nimport {getResourceModel, serializePropAgainstType} from './../../utils/modelUtils';\nimport {getMetaValue} from './../../utils/sectionUtils';\nimport {resolveSectionAgainstModels} from './../../resolvers/resolveSectionAgainstModels';\nimport {resolveBindings} from './../../resolvers/resolveContextualizations';\nimport {markdownToJsAbstraction} from './../markdownConverter';\nimport {serializeBibTexObject} from './../../converters/bibTexConverter';\n\nconst concatSection = ({section, models}, callback) =>{\n  const genuineMeta = section.metadata.filter((metadata)=>{\n    return !metadata.inheritedVerticallyFrom && !metadata.inheritedHorizontallyFrom;\n  });\n  const metadata = genuineMeta.reduce((obj, thatMetadata)=>{\n    const key = (thatMetadata.domain === 'general') ? thatMetadata.key : thatMetadata.domain + '_' + thatMetadata.key;\n    const model = models.metadataModels[thatMetadata.domain][thatMetadata.key];\n    if (model) {\n      obj[key] = serializePropAgainstType(thatMetadata.value, model.valueType, model);\n    } else obj[key] = thatMetadata.value;\n    return obj;\n  }, {});\n  metadata.bibType = 'peritext' + metadata.bibType;\n  let root;\n  if (section.parent) {\n    metadata.parent = section.parent;\n  }else {\n    root = true;\n  }\n\n  if (section.after) {\n    metadata.after = section.after;\n  }\n\n  const resources = section.resources.filter((resource)=>{\n    return !resource.inheritedVerticallyFrom;\n  }).map((resource) =>{\n    const modelList = getResourceModel(resource.bibType, models.resourceModels);\n    if (modelList) {\n      let model;\n      return Object.keys(resource).reduce((obj, key) =>{\n        if (resource[key] !== undefined) {\n          model = modelList.properties.find((thatModel)=>{\n            return thatModel.key === key;\n          });\n          if (model) {\n            obj[key] = serializePropAgainstType(resource[key], model.valueType, model);\n          } else obj[key] = resource[key];\n        }\n\n        return obj;\n      }, {});\n    }\n    return resource;\n  });\n\n\n  const contextualizers = section.contextualizers.filter((contextualizer)=>{\n    return contextualizer && !contextualizer.describedInline;\n  }).map((contextualizer)=>{\n    const modelList = getResourceModel(contextualizer.type, models.contextualizerModels);\n    if (modelList) {\n      let model;\n      const cont = Object.keys(contextualizer).reduce((obj, key) =>{\n        if (contextualizer[key] !== undefined) {\n          model = modelList.properties.find((thatModel)=>{\n            return thatModel.key === key;\n          });\n\n          if (model) {\n            obj[key] = serializePropAgainstType(contextualizer[key], model.valueType, model);\n          } else obj[key] = contextualizer[key];\n        }\n        return obj;\n      }, {});\n      cont.bibType = 'contextualizer';\n      return cont;\n    }\n    contextualizer.bibType = 'contextualizer';\n    return contextualizer;\n  });\n\n  const bibResources = [metadata].concat(resources).concat(contextualizers);\n\n  asyncMap(bibResources, serializeBibTexObject, (err, inputBibStr) =>{\n    let bibStr;\n    if (inputBibStr) {\n      bibStr = inputBibStr.join('\\n\\n');\n    }\n    callback(err, {\n      markdownContent: section.markdownContents,\n      bibResources: bibStr,\n      customizers: section.customizers,\n      citeKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n      root\n    });\n  });\n};\n\nconst sectionListToFsTree = (inputSectionList, basePath, callback) =>{\n  const sectionList = inputSectionList.map((section)=>{\n    const folderTitle = section.citeKey;\n    const relPath = (section.root) ? '' : '/' + folderTitle;\n    const children = [\n      {\n        type: 'file',\n        extname: '.md',\n        name: 'contents.md',\n        path: relPath + '/contents.md',\n        'stringContents': section.markdownContent\n      },\n      {\n        type: 'file',\n        extname: '.bib',\n        name: 'resources.bib',\n        path: relPath + '/resources.bib',\n        'stringContents': section.bibResources\n      }\n      // todo: customizers\n    ];\n    const folder = {\n      type: 'directory',\n      name: section.citeKey,\n      extname: '',\n      path: relPath + '/',\n      root: section.root,\n      children\n    };\n    return folder;\n  });\n\n  const root = sectionList.find((section)=>{\n    return section.root;\n  });\n  const children = sectionList.filter((section)=>{\n    return !section.root;\n  });\n  delete root.root;\n  root.children = root.children.concat(children);\n  root.name = basePath.split('/').pop();\n  callback(null, root);\n};\n\n// from documentSectionsList to fsTree\n/**\n * Converts a sections' list to a fsTree representation of the resulting sourcedata\n * @param {Object} param - serializing params\n * @param {array} param.sectionList - the list of sections to serialize\n * @param {Object} param.models - the models to use for serializing\n * @param {string} param.basePath - the path to use as basis for determining serializing output paths\n * @param {function(error:error, fsTree: Object)} callback - provides the filesystem representation of the data\n */\nexport const serializeSectionList = ({sectionList, models, basePath}, callback) =>{\n  waterfall([\n    (cb) =>{\n      asyncMap(sectionList, (section, callbck) =>{\n        concatSection({section, models}, callbck);\n      }, (err, concatSections) =>{\n        cb(err, concatSections);\n      });\n    },\n    (sections, cb) =>{\n      sectionListToFsTree(sections, basePath, cb);\n    }\n    // all done - return a fsTree\n  ], callback);\n};\n\n// from fsTree (returned by any connector) to a documentSectionsList usable in app\n/**\n * Parses an fsTree representation and renders a list of sections to be used with peritext exporters or as is\n * @param {Object} params - parsing params\n * @param {Object} params.tree - the input fsTree representation\n * @param {Object} params.parameters - language-related parameters\n * @param {Object} params.parent - a possible existing parent section - to use for inheritance phases - suitable for partial document parsing/re-rendering use cases (like with an editor app)\n * @param {Object} params.models - models to use for parsing the data\n * @param {function(error:error, sections: array)} callback - provides an array containing the resources\n */\nexport const parseSection = ({tree, parameters, parent, models}, callback)=> {\n  waterfall([\n    // concat markdown, resources, styles, templates, components, and resolve includes, producing a clean 'dumb tree'\n    (cb) =>{\n      //  console.log(tree);\n      concatTree(tree, parameters, cb);\n    },\n      // parse bibtext to produce resources and metadata props, producing a 'naive tree' of sections\n    (dumbTree, cb) =>{\n      parseTreeResources(dumbTree, cb);\n    },\n    // validate and resolve metadata against their models for all sections\n    (naiveTree, cb) =>{\n      cleanNaiveTree({validTree: naiveTree}, models, cb);\n    },\n    // format objects, normalize metadata, and resolve organization statements\n    ({errors, validTree}, cb) =>{\n      organizeTree({errors, validTree}, cb);\n    },\n    // propagate resources, metadata and customizers vertically (from parents to children sections), metadata lateraly (from metadata models propagation data)\n    ({errors, sections}, cb) =>{\n      propagateData({errors, sections, models, parent}, cb);\n    },\n    // validate each resource against their models to produce errors and warnings from parsing\n    ({errors, sections}, cb) =>{\n\n      asyncMap(sections, (section, cback) =>{\n        validateResources(section, models, cback);\n      }, (err, results) =>{\n        const newSections = results.map((result)=>{\n          return result.section;\n        });\n        const newErrors = results.reduce((total, result) =>{\n          return errors.concat(result.errors);\n        }, errors);\n        cb(err, {errors: newErrors, sections: newSections});\n      });\n    },\n    // resolve section resources and metadata against their models\n    ({errors, sections}, cb) =>{\n      asyncMap(sections, (section, cback) =>{\n        resolveSectionAgainstModels(section, models, cback);\n      }, (err, results) =>{\n        const newSections = results.map((result)=>{\n          return result.section;\n        });\n        const newErrors = results.reduce((total, result) =>{\n          return errors.concat(result.errors);\n        }, errors);\n        cb(err, {errors: newErrors, sections: newSections});\n      });\n    },\n    // parse markdown contents and organize them as blocks lists, and parse+resolve contextualization objects\n    ({errors, sections}, cb) =>{\n      asyncMap(sections, (section, cback) =>{\n        markdownToJsAbstraction(section, parameters, cback);\n      }, (err, results) =>{\n        const newSections = results.map((result)=>{\n          return result.section;\n        });\n        const newErrors = results.reduce((total, result) =>{\n          return errors.concat(result.errors);\n        }, errors);\n        cb(err, {errors: newErrors, sections: newSections});\n      });\n    },\n    // resolve contextualizers statements with their models\n    ({errors, sections}, cb) =>{\n      asyncMap(sections, (section, cback) =>{\n        resolveBindings({section, models}, cback);\n      }, (err, results) =>{\n        const newSections = results.map((result)=>{\n          return result.section;\n        });\n        const newErrors = results.reduce((total, result) =>{\n          return errors.concat(result.errors);\n        }, errors);\n        cb(err, {errors: newErrors, sections: newSections});\n      });\n    }\n    // all done - return a documentTree to use as data state in the app\n  ], callback);\n};\n"
  },
  {
    "__docId__": 215,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "concatSection",
    "memberof": "src/core/converters/sectionConverter/index.js",
    "longname": "src/core/converters/sectionConverter/index.js~concatSection",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "sectionListToFsTree",
    "memberof": "src/core/converters/sectionConverter/index.js",
    "longname": "src/core/converters/sectionConverter/index.js~sectionListToFsTree",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializeSectionList",
    "memberof": "src/core/converters/sectionConverter/index.js",
    "longname": "src/core/converters/sectionConverter/index.js~serializeSectionList",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/sectionConverter/index.js",
    "importStyle": "{serializeSectionList}",
    "description": "Converts a sections' list to a fsTree representation of the resulting sourcedata",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "param",
        "description": "serializing params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "param.sectionList",
        "description": "the list of sections to serialize"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "param.models",
        "description": "the models to use for serializing"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "param.basePath",
        "description": "the path to use as basis for determining serializing output paths"
      },
      {
        "nullable": null,
        "types": [
          "function(error:error, fsTree: Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "provides the filesystem representation of the data"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseSection",
    "memberof": "src/core/converters/sectionConverter/index.js",
    "longname": "src/core/converters/sectionConverter/index.js~parseSection",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/sectionConverter/index.js",
    "importStyle": "{parseSection}",
    "description": "Parses an fsTree representation and renders a list of sections to be used with peritext exporters or as is",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "parsing params"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.tree",
        "description": "the input fsTree representation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.parameters",
        "description": "language-related parameters"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.parent",
        "description": "a possible existing parent section - to use for inheritance phases - suitable for partial document parsing/re-rendering use cases (like with an editor app)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.models",
        "description": "models to use for parsing the data"
      },
      {
        "nullable": null,
        "types": [
          "function(error:error, sections: array)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "provides an array containing the resources"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/sectionConverter/organizeTree.js",
    "memberof": null,
    "longname": "src/core/converters/sectionConverter/organizeTree.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module organizes relations between sections (order, inheritance, generality level)\n * @module converter/sectionConverter/organizeTree\n */\nimport {map as asyncMap, waterfall} from 'async';\n\nimport {getMetaValue, deleteMeta} from './../../utils/sectionUtils';\n\nconst formatMetadata = (metadataObj) =>{\n  const output = [];\n  let value;\n  let keydetail;\n  let domain;\n  for (let key in metadataObj) {\n    if (metadataObj[key] !== undefined) {\n      value = metadataObj[key];\n      keydetail = key.split('_');\n      domain = (keydetail.length > 1) ? keydetail.shift() : 'general';\n      key = keydetail.join('_');\n      output.push({\n        domain,\n        key,\n        value\n      });\n    }\n  }\n  return output;\n};\n\nconst flattenSections = (tree, callback) =>{\n\n  if (tree.children) {\n    asyncMap(tree.children, flattenSections, (err, children) =>{\n      const newTree = Object.assign({}, tree);\n      const newChildren = children.map((child)=>{\n        return Object.assign({}, child[0], {parent: tree.metadata.citeKey});\n      });\n\n      return callback(null, [newTree, ...newChildren]);\n    });\n  }else return callback(null, tree);\n};\n\n\nconst formatSection = (section) =>{\n  const metadata = formatMetadata(section.metadata);\n  let keyedCustomizers;\n  if (section.customizers) {\n    keyedCustomizers = {};\n    section.customizers.forEach((customizer) => {\n      keyedCustomizers[customizer.type] = customizer.contents;\n    });\n  }\n  return {\n    metadata,\n    contents: section.contentStr,\n    resources: section.resources,\n    parent: section.parent,\n    customizers: keyedCustomizers,\n    contextualizers: section.contextualizers\n  };\n};\n\nconst formatSections = (sections, callback) =>{\n  const formatted = sections.map(formatSection);\n  return callback(null, formatted);\n};\n\nconst makeRelations = (inputSections, callback) =>{\n  // find parents and predecessors\n  const sections = inputSections.map((inputSection) =>{\n    const section = Object.assign({}, inputSection);\n    const parent = getMetaValue(section.metadata, 'general', 'parent');\n    const after = getMetaValue(section.metadata, 'general', 'after');\n    if (parent) {\n      section.parent = parent;\n      section.metadata = deleteMeta(section.metadata, 'general', 'parent');\n    }\n    if (after) {\n      section.after = after;\n      section.metadata = deleteMeta(section.metadata, 'general', 'after');\n    }\n    return section;\n  });\n  // order sections\n  for (let index = sections.length - 1; index >= 0; index--) {\n    const section = sections[index];\n    if (section.after) {\n      let indexAfter;\n      sections.some((sec, id) =>{\n        const citeKey = sec.metadata.find((meta)=>{\n          return meta.domain === 'general' && meta.key === 'citeKey';\n        }).value;\n\n        if (section.after === citeKey) {\n          indexAfter = id;\n          return true;\n        }\n      });\n      sections.splice(indexAfter + 1, 0, section);\n      sections.splice(index + 1, 1);\n    }\n  }\n\n  callback(null, sections);\n};\n\n/**\n * Organizes relations betwwen sections\n * @param {Object} params - the organization params\n * @param {array} params.errors - the inherited parsing errors to pass along to next step\n * @param {Object} params.validTree - the tree to process\n * @param {function(error: error, results: {errors: array, sections: array})} callback - an updated list of parsing errors and updated sections\n */\nexport const organizeTree = ({errors, validTree}, callback) => {\n\n  waterfall([\n    function(cb) {\n      flattenSections(validTree, cb);\n    },\n    function(sections, cb) {\n      formatSections(sections, cb);\n    },\n    function(sections, cb) {\n      makeRelations(sections, cb);\n    },\n  ], function(err, sections) {\n    callback(err, {sections, errors});\n  });\n};\n"
  },
  {
    "__docId__": 220,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "formatMetadata",
    "memberof": "src/core/converters/sectionConverter/organizeTree.js",
    "longname": "src/core/converters/sectionConverter/organizeTree.js~formatMetadata",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "flattenSections",
    "memberof": "src/core/converters/sectionConverter/organizeTree.js",
    "longname": "src/core/converters/sectionConverter/organizeTree.js~flattenSections",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "formatSection",
    "memberof": "src/core/converters/sectionConverter/organizeTree.js",
    "longname": "src/core/converters/sectionConverter/organizeTree.js~formatSection",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "formatSections",
    "memberof": "src/core/converters/sectionConverter/organizeTree.js",
    "longname": "src/core/converters/sectionConverter/organizeTree.js~formatSections",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "makeRelations",
    "memberof": "src/core/converters/sectionConverter/organizeTree.js",
    "longname": "src/core/converters/sectionConverter/organizeTree.js~makeRelations",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "organizeTree",
    "memberof": "src/core/converters/sectionConverter/organizeTree.js",
    "longname": "src/core/converters/sectionConverter/organizeTree.js~organizeTree",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/sectionConverter/organizeTree.js",
    "importStyle": "{organizeTree}",
    "description": "Organizes relations betwwen sections",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the organization params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.errors",
        "description": "the inherited parsing errors to pass along to next step"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.validTree",
        "description": "the tree to process"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, results: {errors: array, sections: array})"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "an updated list of parsing errors and updated sections"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/sectionConverter/parseTreeResources.js",
    "memberof": null,
    "longname": "src/core/converters/sectionConverter/parseTreeResources.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module parses resources expressions in .bib files representations\n * @module converter/sectionConverter/parseTreeResources\n */\nimport {parseBibTexStr} from './../../converters/bibTexConverter/';\nimport {map as asyncMap} from 'async';\n\n/**\n * Converts dumbTree resources representations (as string) to js objects - recursively do the same for tree's children\n * @param {Object} dumbTree - a semi-parsed representation inbetween an fsTree and a more structured representation\n * @param {function(error: error, dumbTree: Object)} callback - the output representation\n */\nexport const parseTreeResources = (dumbTree, callback) => {\n  if (dumbTree.resourcesStr) {\n    parseBibTexStr(dumbTree.resourcesStr, function(err, resources) {\n      if (dumbTree.children) {\n        asyncMap(dumbTree.children, parseTreeResources, function(error, children) {\n          callback(error, Object.assign({}, dumbTree, {resources}, {children}));\n        });\n      }\n    });\n  }else callback(null, Object.assign({}, dumbTree));\n};\n"
  },
  {
    "__docId__": 227,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseTreeResources",
    "memberof": "src/core/converters/sectionConverter/parseTreeResources.js",
    "longname": "src/core/converters/sectionConverter/parseTreeResources.js~parseTreeResources",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/sectionConverter/parseTreeResources.js",
    "importStyle": "{parseTreeResources}",
    "description": "Converts dumbTree resources representations (as string) to js objects - recursively do the same for tree's children",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "dumbTree",
        "description": "a semi-parsed representation inbetween an fsTree and a more structured representation"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, dumbTree: Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "the output representation"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/sectionConverter/propagateData.js",
    "memberof": null,
    "longname": "src/core/converters/sectionConverter/propagateData.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module handles metadata propagation within and between sections\n * @module converter/sectionConverter/propagateData\n */\nimport {getMetaValue, setMetaValue, hasMeta, findByMetadata, metaStringToCouple, hasResource} from './../../utils/sectionUtils';\n\nconst inheritMetadataFromParent = (section, sectionTypeModels, sections, parentMetadata) => {\n  if (parentMetadata === undefined) {\n    return section;\n  }\n  // inherit metadata props\n  // discriminated inedit propert\n  const inherited = parentMetadata.filter((pmeta) =>{\n    if (hasMeta(section.metadata, pmeta)) {\n      return false;\n    }\n    return true;\n  });\n\n  const parentKey = getMetaValue(parentMetadata, 'general', 'citeKey');\n  section.metadata = section.metadata.concat(inherited.map((meta) =>{\n    return Object.assign({}, meta, {inheritedVerticallyFrom: {domain: 'general', key: 'citeKey', value: parentKey}});\n  }));\n\n  // set final bibType\n  const bibType = getMetaValue(section.metadata, 'general', 'bibType');\n  if (bibType === 'section') {\n    const parentBibType = getMetaValue(parentMetadata, 'general', 'bibType');\n    const parentModel = sectionTypeModels.acceptedTypes[parentBibType];\n    if (parentModel) {\n      section.metadata = setMetaValue(section.metadata, 'general', 'bibType', parentModel.childrenType);\n    }\n  }\n\n  // set hierarchical level (parent + 1 or parent + own level)\n  const parentLevel = getMetaValue(parentMetadata, 'general', 'generalityLevel');\n  const ownLevel = getMetaValue(section.metadata, 'general', 'generalityLevel');\n  if (parentLevel && ownLevel) {\n    section.metadata = setMetaValue(section.metadata, 'general', 'generalityLevel', parentLevel + ownLevel);\n  }else if (parentLevel) {\n    section.metadata.push({\n      domain: 'general',\n      key: 'generalityLevel',\n      value: parentLevel + 1\n    });\n  }else {\n    section.metadata.push({\n      domain: 'general',\n      key: 'generalityLevel',\n      value: 1\n    });\n  }\n  return section;\n};\n\n\nconst doInheritMetadataFromParent = (section, sectionTypeModels, sections) => {\n  if (section.parent && !section.metadataInherited) {\n\n    section.metadataInherited = true;\n\n    let parent = findByMetadata(sections, 'general', 'citeKey', section.parent);\n    // first, make your parent inherit from its parent\n    if (!parent.metadataInherited) {\n      parent = doInheritMetadataFromParent(section, sectionTypeModels, sections);\n    }\n    // then inherit yourself from your parent\n    return inheritMetadataFromParent(section, sectionTypeModels, sections, parent.metadata);\n  }\n  // if(getMetaValue(section.metadata, 'general', 'citeKey') === 'mybook'){\n  //   console.log(section.metadata);\n  // }\n  section.metadataInherited = true;\n  return section;\n};\n\n\nconst inheritResourcesFromParent = (section, sections, parentResources, parentKey) => {\n  if (parentResources === undefined) {\n    return section;\n  }\n\n  // inherit meta props - take anything that you don't already have\n  const inherited = parentResources.filter((presource) =>{\n    return !hasResource(section.resources, presource);\n  });\n  section.resources = section.resources.concat(inherited.map((meta) =>{\n    return Object.assign({}, meta, {inheritedVerticallyFrom: parentKey});\n  }));\n  return section;\n};\n\n\nconst doInheritResourcesFromParent = (section, sections) => {\n  if (section.parent && !section.resourcesInherited) {\n    section.resourcesInherited = true;\n    let parent = findByMetadata(sections, 'general', 'citeKey', section.parent);\n    // first, make your parent inherit from its parent\n    if (!parent.resourcesInherited) {\n      parent = doInheritResourcesFromParent(section, sections);\n    }\n    // then inherit yourself from your parent\n    return inheritResourcesFromParent(section, sections, parent.resources, getMetaValue(parent.metadata, 'general', 'citeKey'));\n  }\n  section.resourcesInherited = true;\n  return section;\n};\n\nconst inheritContextualizersFromParent = (section, sections, parentContextualizers, parentKey) => {\n  if (parentContextualizers === undefined) {\n    return section;\n  }\n  // inherit context props - take anything that you don't already have\n  const inherited = parentContextualizers.filter((presource) =>{\n    return !hasResource(section.contextualizers, presource);\n  });\n\n  section.contextualizers = section.contextualizers.concat(inherited.map((meta) =>{\n    return Object.assign({}, meta, {inheritedVerticallyFrom: parentKey});\n  }));\n  return section;\n};\n\n\nconst doInheritContextualizersFromParent = (section, sections) => {\n  if (section.parent && !section.contextualizersInherited) {\n    section.contextualizersInherited = true;\n    let parent = findByMetadata(sections, 'general', 'citeKey', section.parent);\n    // first, make your parent inherit from its parent\n    if (!parent.contextualizersInherited) {\n      parent = doInheritResourcesFromParent(section, sections);\n    }\n    // then inherit yourself from your parent\n    return inheritContextualizersFromParent(section, sections, parent.contextualizers, getMetaValue(parent.metadata, 'general', 'citeKey'));\n  }\n  section.contextualizersInherited = true;\n  return section;\n};\n\nconst inheritCustomizersFromParent = (section, sections, parentCustomizers, parentKey) => {\n  if (parentCustomizers === undefined) {\n    return section;\n  }else if (section.customizers === undefined) {\n    section.customizers = Object.assign({}, parentCustomizers);\n  }else {\n    for (const index in section.customizers) {\n      if (parentCustomizers[index] !== undefined) {\n        // if customizer is a string (e.g. : css data) append child data after parent data\n        if (typeof section.customizers[index] === 'string') {\n          section.customizers[index] = parentCustomizers[index] + '\\n\\n\\n' + section.customizers[index];\n        }else {\n          for (const jindex in parentCustomizers[index]) {\n            // add customizer from parent (e.g. : template) if not defined in child\n            if (section.customizers[index][jindex] === undefined) {\n              section.customizers[index][jindex] = parentCustomizers[index][jindex];\n            }\n          }\n        }\n      }\n    }\n  }\n  return section;\n};\n\nconst doInheritCustomizersFromParent = (section, sections) => {\n  if (section.parent && !section.customizersInherited) {\n    section.customizersInherited = true;\n    let parent = findByMetadata(sections, 'general', 'citeKey', section.parent);\n    // first, make your parent inherit from its parent\n    if (!parent.customizersInherited) {\n      parent = doInheritCustomizersFromParent(section, sections);\n    }\n    // then inherit yourself from your parent\n    return inheritCustomizersFromParent(section, sections, parent.customizers, getMetaValue(parent.metadata, 'general', 'citeKey'));\n  }\n  section.customizersInherited = true;\n  return section;\n};\n\nconst populateLaterally = (section, models) => {\n  const toInclude = [];\n\n  section.metadata.forEach((meta) => {\n    const model = models[meta.domain][meta.key];\n    if (model) {\n      const spreaded = model.propagatesTo.map(metaStringToCouple);\n      spreaded.forEach((sp) =>{\n        const existantProp = hasMeta(section.metadata, sp);\n        if (!existantProp) {\n          toInclude.push(Object.assign({}, sp, {value: meta.value}, {inheritedHorizontallyFrom: {domain: meta.domain, key: meta.key}}));\n        }\n      });\n    }\n  });\n  section.metadata = section.metadata.concat(toInclude);\n  return section;\n};\n\n/**\n * Populate the metadatas of a list of sections, by applying propagation from parents or inbetween metadata values (e.g. : from twitter domain to open graph domain)\n * @param {Object} params - the params of propagation\n * @param {array} params.errors - the list of errors possibly inherited from previous steps\n * @param {array} params.sections - the list of sections to transform\n * @param {Object} params.models - the models to parse the sections with\n * @param {Object} params.parent - if specified, sections that don't have a parent will all be considered as children of this one (but it won't be parsed itself)\n * @param {function(error: error, result: {errors: array, sections: array})} callback - the new transformation errors and updated sections\n */\nexport const propagateData = ({errors, sections, models, parent}, callback) => {\n  let noParents = sections.filter((section) =>{\n    return !section.parent;\n  });\n  if (parent) {\n    // inherit metadata from args\n    const inheritedMetadata = parent.metadata;\n    const inheritedResources = parent.resources;\n    const inheritedContextualizations = parent.contextualizers;\n    const parentKey = getMetaValue(inheritedMetadata, 'general', 'citeKey');\n\n    noParents = noParents.map((inputSection) =>{\n      let section = Object.assign({}, inputSection);\n      section.metadataInherited = true;\n      section.resourcesInherited = true;\n      section.contextualizersInherited = true;\n      section = inheritResourcesFromParent(section, sections, inheritedResources, parentKey);\n      section = inheritContextualizersFromParent(section, sections, inheritedContextualizations, parentKey);\n      section = inheritMetadataFromParent(section, models.sectionTypeModels, sections, inheritedMetadata);\n      return section;\n    });\n    // inherit resources from arguments\n  } else {\n    noParents.forEach((section) =>{\n      // hierarchical level bootstrapping\n      section.metadata.push({\n        domain: 'general',\n        key: 'generalityLevel',\n        value: 1\n      });\n      section.resourcesInherited = true;\n      section.metadataInherited = true;\n      section.customizersInherited = true;\n      section.contextualizersInherited = true;\n    });\n  }\n  let outputSections = [].concat(sections);\n  // clean bibType\n  outputSections = sections.map((section) =>{\n    let newBibType = getMetaValue(section.metadata, 'general', 'bibType');\n    newBibType = newBibType ? newBibType.split('peritext') : [];\n    newBibType = newBibType.length > 1 ? newBibType[1] : newBibType[0];\n    section.metadata = setMetaValue(section.metadata, 'general', 'bibType', newBibType);\n    return section;\n  });\n\n  // inherit metadata from parents to children\n  outputSections = sections.map((section) =>{\n    return doInheritMetadataFromParent(section, models.sectionTypeModels, sections);\n  });\n\n  // inherit resources from parents to children\n  outputSections = sections.map((section) =>{\n    return doInheritResourcesFromParent(section, sections);\n  });\n\n  // inherit contextualizers from parents to children\n  outputSections = sections.map((section) =>{\n    return doInheritContextualizersFromParent(section, sections);\n  });\n\n  // inherit customizers form parents to children\n  outputSections = sections.map((section) =>{\n    return doInheritCustomizersFromParent(section, sections);\n  });\n\n  // inherit metadata laterally, from one property to another\n  outputSections = sections.map((section) =>{\n    return populateLaterally(section, models.metadataModels);\n  });\n\n  // cleaning control properties\n  outputSections.forEach((section) =>{\n    delete section.metadataInherited;\n    delete section.customizersInherited;\n    delete section.resourcesInherited;\n    delete section.contextualizersInherited;\n  });\n\n  callback(null, {errors, sections: outputSections});\n};\n"
  },
  {
    "__docId__": 229,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "inheritMetadataFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~inheritMetadataFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doInheritMetadataFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~doInheritMetadataFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "inheritResourcesFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~inheritResourcesFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doInheritResourcesFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~doInheritResourcesFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "inheritContextualizersFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~inheritContextualizersFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doInheritContextualizersFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~doInheritContextualizersFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "inheritCustomizersFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~inheritCustomizersFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doInheritCustomizersFromParent",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~doInheritCustomizersFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 165,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "populateLaterally",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~populateLaterally",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "propagateData",
    "memberof": "src/core/converters/sectionConverter/propagateData.js",
    "longname": "src/core/converters/sectionConverter/propagateData.js~propagateData",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/sectionConverter/propagateData.js",
    "importStyle": "{propagateData}",
    "description": "Populate the metadatas of a list of sections, by applying propagation from parents or inbetween metadata values (e.g. : from twitter domain to open graph domain)",
    "lineNumber": 208,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the params of propagation"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.errors",
        "description": "the list of errors possibly inherited from previous steps"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.sections",
        "description": "the list of sections to transform"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.models",
        "description": "the models to parse the sections with"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.parent",
        "description": "if specified, sections that don't have a parent will all be considered as children of this one (but it won't be parsed itself)"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, result: {errors: array, sections: array})"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "the new transformation errors and updated sections"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/models/index.js",
    "memberof": null,
    "longname": "src/core/models/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Models - default models used along the library\n * @module models\n */\n\n/**\n * models of peritext sections metadata\n */\nexport const metadataModels = require('./metadataModels.json');\n/**\n * models of peritext resources\n */\nexport const resourceModels = require('./resourceModels.json');\n/**\n * models of possible peritext sections bibType and their inheritance rules\n */\nexport const sectionTypeModels = require('./sectionTypeModels.json');\n/**\n * models of peritext contextualizers\n */\nexport const contextualizerModels = require('./contextualizerModels.json');\n/**\n * models of peritext (possible, and default) rendering settings\n */\nexport const settingsModels = require('./settingsModels.json');\n"
  },
  {
    "__docId__": 240,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "metadataModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~metadataModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{metadataModels}",
    "description": "models of peritext sections metadata",
    "lineNumber": 9,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resourceModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~resourceModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{resourceModels}",
    "description": "models of peritext resources",
    "lineNumber": 13,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "sectionTypeModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~sectionTypeModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{sectionTypeModels}",
    "description": "models of possible peritext sections bibType and their inheritance rules",
    "lineNumber": 17,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizerModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~contextualizerModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{contextualizerModels}",
    "description": "models of peritext contextualizers",
    "lineNumber": 21,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "settingsModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~settingsModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{settingsModels}",
    "description": "models of peritext (possible, and default) rendering settings",
    "lineNumber": 25,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/htmlMetaTemplateSerializer/index.js",
    "memberof": null,
    "longname": "src/core/resolvers/htmlMetaTemplateSerializer/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve metadata templates against their data\n * @module resolvers/htmlMetaTemplateSerializer\n */\n\n// templates have two variables : ${key} and ${value}\n// if value is an array\n// modificators are specifed after commas\n// modificators : join(), personsToString\n\n/**\n * Consumes a metadata object against an html metadata node template\n * @param {Object} metadata - the metadata object\n * @param {string} template - the template to consumes\n * @return {string} htmlMeta - the representation of the html metadata as string\n */\nexport const serializeHtmlMeta = (metadata, template) => {\n  let transformationAction = template.match(/\\${value:([^}]*)/);\n  let transformationArgument;\n  let value;\n  if (transformationAction) {\n    transformationAction = transformationAction[1];\n    if (transformationAction.indexOf('join(') === 0) {\n      try {\n        transformationArgument = transformationAction.match(/join\\(([^\\)]*)\\)/)[1];\n      }catch (exception) {\n        transformationArgument = ', ';\n      }\n    }\n  }\n\n  if (transformationAction === 'join' && Array.isArray(metadata.value)) {\n    value = metadata.value.join(transformationArgument);\n  }else if (transformationAction === 'personsToString' && Array.isArray(metadata.value)) {\n    const persons = metadata.value.map((person)=>{\n      return (person.firstName) ? person.firstName + ' ' + person.lastName : person.lastName;\n    });\n    value = persons.join(', ');\n  }else value = metadata.value;\n  let output = template;\n  while (output.indexOf('${value') > -1) {\n    output = output.replace('${key}', metadata.key).replace(/\\${value:?([^}]*)?}/, value);\n  }\n  return output;\n};\n"
  },
  {
    "__docId__": 246,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializeHtmlMeta",
    "memberof": "src/core/resolvers/htmlMetaTemplateSerializer/index.js",
    "longname": "src/core/resolvers/htmlMetaTemplateSerializer/index.js~serializeHtmlMeta",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/htmlMetaTemplateSerializer/index.js",
    "importStyle": "{serializeHtmlMeta}",
    "description": "Consumes a metadata object against an html metadata node template",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "metadata",
        "description": "the metadata object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "template",
        "description": "the template to consumes"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "htmlMeta - the representation of the html metadata as string"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/resolveContextualizations/index.js",
    "memberof": null,
    "longname": "src/core/resolvers/resolveContextualizations/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve  contextualization statements\n * @module resolvers/resolveContextualizations\n */\n\nimport {getMetaValue} from './../../utils/sectionUtils';\nimport {getResourceModel, getContextualizerModel, resolvePropAgainstType} from './../../utils/modelUtils';\nimport * as contextualizers from './../../../contextualizers/';\n\n/**\n * Transforms 1, 2, 3 ordinally used number into a, b, c ordinally used letters\n * @param {number} num - the number to transform\n * @return {string} letter - the output letter\n */\nexport const numbersToLetters = (num) =>{\n  const mod = num % 26;\n  let pow = num / 26 | 0;\n  const out = mod ? String.fromCharCode(64 + mod) : (--pow, 'Z');\n  return pow ? numbersToLetters(pow) + out : out.toLowerCase();\n};\n\n/**\n * Resolves a contextualizer object against its model and context, and records errors\n * @param {object} contextualizer - the contextualizer to resolve\n * @param {object} contextualization - the contextualization to use as a clue-giver if the contextualizer is implicit\n * @param {object} section - the section to which the contextualizer belongs\n * @param {object} models - the models to parse the contextualizer against\n * @return {{err: error, contextualizer: Object}} result - parsing errors and final contextualizer\n */\nconst resolveContextualizer = (contextualizer, contextualization, section, models) =>{\n  const err = [];\n  let newContextualizer = Object.assign({}, contextualizer);\n  // if overloading, first fetch the existing contextualizer\n  if (newContextualizer.overloading) {\n    const overload = newContextualizer.overloading.replace(/^@/, '');\n    // find original\n    const original = section.contextualizers.find((cont) =>{\n      return cont.citeKey === overload;\n    });\n    // resolve original first\n    if (original) {\n      const originalFormatted = resolveContextualizer(original, contextualization, section, models).finalContextualizer;\n      newContextualizer = Object.assign(originalFormatted, newContextualizer);\n    } else {\n      // no original found ==> overloading reference error\n      err.push({\n        type: 'error',\n        preciseType: 'invalidContextualizer',\n        sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n        message: 'overloading reference error: contextualizer ' + newContextualizer.citeKey + ' should overload ' + overload + ' but the original contextualizer does not exist'\n      });\n    }\n  }\n  // guess contextualizer type if needed\n  if (!newContextualizer.type) {\n    if (contextualization.resources.length > 0) {\n      const source = contextualization.resources[0];\n      if (source === undefined) {\n        err.push({\n          type: 'error',\n          preciseType: 'invalidContextualizer',\n          sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n          message: 'contextualizer ' + newContextualizer.citeKey + ' (' + newContextualizer.type + ') does not provide a valid resource'\n        });\n        return {err, undefined};\n      }\n      const sourceModel = getResourceModel(source.bibType, models.resourceModels);\n      newContextualizer.type = sourceModel.defaultContextualizer;\n    }\n  }\n  // resolve contextualizer object against its model\n  const contextualizerModel = getContextualizerModel(newContextualizer.type, models.contextualizerModels);\n  const finalContextualizer = contextualizerModel.properties.reduce((obj, thatModel) =>{\n    obj[thatModel.key] = resolvePropAgainstType(newContextualizer[thatModel.key], thatModel.valueType, thatModel);\n    // record error if required field is undefined\n    if (obj[thatModel.key] === undefined && thatModel.required === true) {\n      err.push({\n        type: 'error',\n        preciseType: 'invalidContextualizer',\n        sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n        message: 'contextualizer ' + newContextualizer.citeKey + ' (' + newContextualizer.type + ') does not provide required type ' + thatModel.key\n      });\n    }\n    return obj;\n  }, {});\n  return {err, finalContextualizer};\n};\n\n/**\n * Resolves contextualizations' contextualizer and resource, verifying that contextualization will be possible\n * @param {object} contextualizer - the contextualizer to resolve\n * @param {object} section - the section to resolve\n * @param {object} models - the models to use to validate data\n * @param {function(err: error, results: {errors: array, newSection: Object})} callback - callbacks updated section and possible errors as an array\n */\nexport const resolveBindings = ({section, models}, cb) =>{\n  let errors = [];\n  // find implicit contextualizers types\n  section.contextualizations = section.contextualizations.map(contextualization =>{\n    // populate contextualizers against their models\n    const {err, finalContextualizer} = resolveContextualizer(contextualization.contextualizer, contextualization, section, models);\n    if (err.length) {\n      errors = errors.concat(err);\n    } else {\n      contextualization.contextualizer = finalContextualizer;\n    }\n    return contextualization;\n  // verify that all required resources exist\n  }).filter((contextualization) =>{\n    let ok = true;\n    if (contextualization.contextualizer === undefined) {\n      errors.push({\n        type: 'error',\n        preciseType: 'invalidContextualization',\n        sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n        message: 'contextualizer was not found for contextualization ' + contextualization\n      });\n      return cb(null, {errors, section});\n    }\n    const acceptedResourceTypes = getContextualizerModel(contextualization.contextualizer.type, models.contextualizerModels).acceptedResourceTypes;\n    // resources compatibility and existence check\n    contextualization.resources.some((res) =>{\n      // resource exists, check if it is accepted for the contextualizerType\n      if (res !== undefined) {\n        let accepted = false;\n        acceptedResourceTypes.some((type) => {\n          if (type === '*' || type === res.bibType) {\n            accepted = true;\n            return true;\n          }\n        });\n        if (!accepted) {\n          ok = false;\n          errors.push({\n            type: 'error',\n            preciseType: 'invalidContextualization',\n            sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n            message: 'resource ' + res + ' was asked in a contextualization but is not handled by the contextualizer ' + contextualization.contextualizer\n          });\n        }\n      } else {\n        ok = false;\n        errors.push({\n          type: 'error',\n          preciseType: 'invalidContextualization',\n          sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n          message: 'resource ' + res + ' was asked in a contextualization but was not found'\n        });\n      }\n      return ok;\n    });\n    return ok;\n  });\n  cb(null, {errors, section});\n};\n\n/**\n * Resolves relations of recurrence, order, and similarity between contextualizations in a section\n * @param {array} sections - the sections array to resolve\n * @param {object} settings - the rendering settings to apply\n * @return {array} newSections - the udpated sections\n */\nexport const resolveContextualizationsRelations = (sections, settings) =>{\n  let opCitIndex;\n  let sameResPrint;\n  return sections.reduce((inputSections, sectio, index)=> {\n    sectio.contextualizations = sectio.contextualizations.reduce((conts, contextualization, contIndex) => {\n      contextualization.resPrint = contextualization.resources.map(res =>{\n        return res.citeKey;\n      }).join('-');\n      // opcit section\n      sameResPrint = conts.find((cont2, cont2Index)=> {\n        if (cont2.resPrint === contextualization.resPrint) {\n          opCitIndex = cont2Index;\n          contextualization.precursorCiteKey = cont2.citeKey;\n          return true;\n        }\n      });\n\n      if (sameResPrint !== undefined) {\n        contextualization.sectionOpCit = true;\n      }\n      // todo opcit document\n\n      // ibid section\n      if (opCitIndex) {\n        const substrate = conts.slice(opCitIndex, contIndex).filter(oCont=> {\n          return oCont.contextualizer.type === contextualization.contextualizer.type;\n        });\n        if (substrate.length === 2) {\n          contextualization.sectionIbid = true;\n        }\n      }\n\n      // todo ibid document\n\n      if (contextualization.contextualizer.type === 'citation') {\n        // same authors but different work in year - section scale\n        contextualization.authorsPrint = contextualization.resources[0].author.reduce((str, author)=> {\n          return str + author.lastName + '-' + author.firstName;\n        }, '');\n\n        conts.find((cont2)=> {\n          if (cont2.authorsPrint === contextualization.authorsPrint && cont2.resPrint !== contextualization.resPrint && (cont2.year === contextualization.year || cont2.date === contextualization.date)) {\n            cont2.sameAuthorInYear = cont2.sameAuthorInYear !== undefined ? cont2.sameAuthorInYear ++ : 1;\n            contextualization.sameAuthorInYear = cont2.sameAuthorInYear + 1;\n            contextualization.yearSuffix = numbersToLetters(contextualization.sameAuthorInYear);\n            cont2.yearSuffix = numbersToLetters(cont2.sameAuthorInYear);\n            return true;\n          }\n        });\n        // todo same authors in year but different work - at document scale\n      }\n\n      opCitIndex = undefined;\n      return conts.concat(contextualization);\n    }, []);\n\n    return inputSections.concat(sectio);\n  }, []);\n};\n\n/**\n * Resolves all the contextualizations of a section by updating its contents pseudo-DOM representation\n * @param {object} section - the section to resolve\n * @param {string} renderingMode - whether rendering is static or dynamic\n * @param {object} settings - the rendering settings to take into account when resolving contextualizations\n * @return {Object} newSection - the updated section\n */\nexport const resolveContextualizationsImplementation = (section, renderingMode, settings) =>{\n  let contextualizer;\n  const sectio = section.contextualizations.reduce((inputSection, contextualization) => {\n    // rebind resources\n    contextualization.resources = contextualization.resources.map(res1 =>{\n      return inputSection.resources.find(res2 =>{\n        return res1.citeKey === res2.citeKey;\n      });\n    });\n    contextualizer = contextualizers[contextualization.contextualizer.type];\n    if (contextualizer === undefined) {\n      console.log('no contextualizer function was found for type ', contextualization.contextualizer.type);\n      return Object.assign({}, inputSection);\n    }\n    switch (renderingMode) {\n    case 'static':\n      switch (contextualization.type) {\n      case 'inline':\n        return contextualizer.contextualizeInlineStatic(inputSection, contextualization, settings);\n      case 'block':\n        return contextualizer.contextualizeBlockStatic(inputSection, contextualization, settings);\n      default:\n        break;\n      }\n      break;\n    case 'dynamic':\n      switch (contextualization.type) {\n      case 'inline':\n        return contextualizer.contextualizeInlineDynamic(inputSection, contextualization, settings);\n      case 'block':\n        return contextualizer.contextualizeBlockDynamic(inputSection, contextualization, settings);\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    return Object.assign({}, inputSection);\n  }, Object.assign({}, section));\n\n  return sectio;\n};\n"
  },
  {
    "__docId__": 248,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "numbersToLetters",
    "memberof": "src/core/resolvers/resolveContextualizations/index.js",
    "longname": "src/core/resolvers/resolveContextualizations/index.js~numbersToLetters",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations/index.js",
    "importStyle": "{numbersToLetters}",
    "description": "Transforms 1, 2, 3 ordinally used number into a, b, c ordinally used letters",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": "the number to transform"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "letter - the output letter"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveContextualizer",
    "memberof": "src/core/resolvers/resolveContextualizations/index.js",
    "longname": "src/core/resolvers/resolveContextualizations/index.js~resolveContextualizer",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations/index.js",
    "importStyle": null,
    "description": "Resolves a contextualizer object against its model and context, and records errors",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualizer",
        "description": "the contextualizer to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualization",
        "description": "the contextualization to use as a clue-giver if the contextualizer is implicit"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to which the contextualizer belongs"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to parse the contextualizer against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{err: error, contextualizer: Object}"
      ],
      "spread": false,
      "description": "result - parsing errors and final contextualizer"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveBindings",
    "memberof": "src/core/resolvers/resolveContextualizations/index.js",
    "longname": "src/core/resolvers/resolveContextualizations/index.js~resolveBindings",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations/index.js",
    "importStyle": "{resolveBindings}",
    "description": "Resolves contextualizations' contextualizer and resource, verifying that contextualization will be possible",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualizer",
        "description": "the contextualizer to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to use to validate data"
      },
      {
        "nullable": null,
        "types": [
          "function(err: error, results: {errors: array, newSection: Object})"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "callbacks updated section and possible errors as an array"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveContextualizationsRelations",
    "memberof": "src/core/resolvers/resolveContextualizations/index.js",
    "longname": "src/core/resolvers/resolveContextualizations/index.js~resolveContextualizationsRelations",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations/index.js",
    "importStyle": "{resolveContextualizationsRelations}",
    "description": "Resolves relations of recurrence, order, and similarity between contextualizations in a section",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "sections",
        "description": "the sections array to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the rendering settings to apply"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "newSections - the udpated sections"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 252,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveContextualizationsImplementation",
    "memberof": "src/core/resolvers/resolveContextualizations/index.js",
    "longname": "src/core/resolvers/resolveContextualizations/index.js~resolveContextualizationsImplementation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations/index.js",
    "importStyle": "{resolveContextualizationsImplementation}",
    "description": "Resolves all the contextualizations of a section by updating its contents pseudo-DOM representation",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to resolve"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "renderingMode",
        "description": "whether rendering is static or dynamic"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the rendering settings to take into account when resolving contextualizations"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSection - the updated section"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 253,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/resolveDataDependencies/index.js",
    "memberof": null,
    "longname": "src/core/resolvers/resolveDataDependencies/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve @assets statements and @res statements\n * @module resolvers/resolveDataDependencies\n */\nimport {map as asyncMap, mapSeries as asyncMapSeries, waterfall} from 'async';\nconst CsvConverter = require('csvtojson').Converter;\nconst csvConverter = new CsvConverter({});\n\n/**\n * Resolves interpolations ni metadata, resources, and contextualizations, and possibly fetches stores necessary data for rendering\n * @param {array} inputSections - the sections to resolve\n * @param {Object} assetsController - the assets controller module to use to communicate with assets\n * @param {Object} assetsParams - the params to use for accessing the assets\n * @param {boolean} resolveData - whether to fetch and store necessary data right away or to store methods for later lazy-loading\n * @param {function(err: error, finalSections: array)} callback - callbacks a possible errors and the updated list of sections\n */\nexport default function resolveDataDependencies(inputSections, assetsController, assetsParams, resolveData, callback) {\n  let res;\n  let match;\n  const data = {};// this object stores resolved and unresolved promises about resources data\n  const resRe = /@res([\\d]+)?.(.*)/g;\n  const assetsRe = /@assets\\/([^']+)/g;\n  asyncMap(inputSections, (section, allSectionsCallback)=> {\n    waterfall([\n      // styles resolution\n      (stylesResolutionCallback)=> {\n        if (section.customizers && section.customizers.styles) {\n          const styles = [];\n          for (const prop in section.customizers.styles) {\n            if (section.customizers.styles[prop]) {\n              styles.push({key: prop, value: section.customizers.styles[prop]});\n            }\n          }\n          // map each style customizer\n          asyncMap(styles, (styleCouple, singleStyleCallback)=> {\n            let style = styleCouple.value;\n            // get all expressions\n            const matches = [];\n            do {\n              match = assetsRe.exec(style);\n              if (match) {\n                matches.push(match);\n              }\n            } while (match);\n            // some assets interpolations to do\n            if (matches.length) {\n              // reverse array to begin with last matches and not mess around with indexes\n              matches.reverse();\n              asyncMap(matches, (thisMatch, matchCallback)=> {\n                assetsController.getAssetUri(thisMatch[1], assetsParams, (err4, uri)=> {\n                  style = style.substr(0, thisMatch.index) + uri + style.substr(thisMatch.index + thisMatch[0].length);\n                  matchCallback(err4, thisMatch);\n                });\n              }, (matchErrors, theseMatches)=> {\n                styleCouple.value = style;\n                singleStyleCallback(matchErrors, styleCouple);\n              });\n            // no interpolations to do\n            } else {\n              styleCouple.value = style;\n              singleStyleCallback(null, styleCouple);\n            }\n          }, (stylesErrors, styleCouples)=> {\n            styleCouples.forEach((styleCouple) =>{\n              section.customizers.styles[styleCouple.key] = styleCouple.value;\n            });\n            stylesResolutionCallback(stylesErrors, section);\n          });\n        } else stylesResolutionCallback(null, section);\n      },\n      // resolve metadata\n      (sectio, metadataCallback)=> {\n        asyncMap(sectio.metadata, (metadata, singleMetadataCallback)=> {\n          if (typeof metadata.value === 'string' && metadata.value.indexOf('@assets/') === 0) {\n            assetsController.getAssetUri(metadata.value.split('@assets/')[1], assetsParams, (err4, uri)=> {\n              metadata.value = uri;\n              singleMetadataCallback(err4, metadata);\n            });\n          } else {\n            singleMetadataCallback(null, metadata);\n          }\n        }, (metadataErrors, newMetadata)=>{\n          sectio.metadata = newMetadata;\n          metadataCallback(metadataErrors, sectio);\n        });\n      },\n      // resolve resources\n      (sectio, resourcesCallback)=> {\n        asyncMap(sectio.resources, (resource, singleResourceCallback)=> {\n          const props = [];\n          // format props as array for performing an async map\n          for (const prop in resource) {\n            if (resource[prop]) {\n              props.push({key: prop, value: resource[prop]});\n            }\n          }\n          asyncMap(props, (prop, resourcePropCallback)=> {\n            if (typeof prop.value === 'string' && prop.value.indexOf('@assets/') === 0) {\n              assetsController.getAssetUri(prop.value.split('@assets/')[1], assetsParams, (err4, uri)=> {\n                prop.value = uri;\n                resourcePropCallback(err4, prop);\n              });\n            } else {\n              resourcePropCallback(null, prop);\n            }\n          }, (singleResourceError, newProps)=> {\n            const newResource = newProps.reduce((obj, prop) =>{\n              obj[prop.key] = prop.value;\n              return obj;\n            }, {});\n            singleResourceCallback(singleResourceError, newResource);\n          });\n        }, (resourcesErrors, resources)=> {\n          sectio.resources = resources;\n          resourcesCallback(resourcesErrors, sectio);\n        });\n      },\n      (sectio, contextualizationsCallback)=> {\n        asyncMap(sectio.contextualizations, (contextualization, contextualizationCallback)=> {\n          res = undefined;\n          const props = [];\n          // format props as array for performing an async map\n          for (const prop in contextualization.contextualizer) {\n            if (contextualization.contextualizer[prop]) {\n              props.push({key: prop, value: contextualization.contextualizer[prop]});\n            }\n          }\n          /**\n           * First level props\n           */\n          // resolve async. props\n          asyncMap(props, (prop, contextualizationPropCallback)=> {\n            const val = prop.value;\n            // if prop is itself an array, need for another nested async resolution\n            if (Array.isArray(val) && prop.key !== 'resources') {\n              // loop through propArray members\n              asyncMap(val, (prop2, propArrayMembersCallback)=> {\n                // prepare for asyncMap for propArray member\n                const nestedProps = [];\n                for (const nestedProp in prop2) {\n                  if (prop2[nestedProp]) {\n                    nestedProps.push({key: nestedProp, value: prop2[nestedProp]});\n                  }\n                }\n                // Second level props (contextualization.arrayProp[array member].prop)\n                asyncMap(nestedProps, (nestedProp, nestedPropCallback)=> {\n                  // resolve nested props here\n                  const val3 = nestedProp.value;\n                  if (('' + val3).indexOf('@res') === 0) {\n                    while ((match = resRe.exec(val3)) !== null) {\n                      // Identify which resource is targetted (handling multi-resource contextualizations)\n                      const rank = match[1] ? (+match[1] - 1) : 0;\n                      // find resource data\n                      res = contextualization.resources[rank];\n                      if (res === undefined) {\n                        console.log('res is undefined, expression: ', val3);\n                        return nestedPropCallback(undefined, nestedProp);\n                      }\n                      // case: metadata call\n                      const resProp = match[match.length - 1];\n                      if (resProp.indexOf('data') !== 0) {\n                        // interpolate w/ resource value thanks to resourceProp path\n                        nestedProp.value = res[resProp];\n                        // contextualizationPropCallback(null, prop);\n                      // case : data call\n                      } else {\n                        const dataPath = ('' + val3).split('.').filter(path=>{\n                          return path.length;\n                        });\n                        nestedProp.value = {\n                          type: 'path',\n                          target: 'data',\n                          path: dataPath\n                        };\n                        const defined = data[res.citeKey];\n                        if (!defined) {\n                          const accessor = res.data || res.url;\n                          if (('' + accessor).indexOf('@assets/') === 0) {\n                            const toResolve = {};\n                            toResolve.params = {\n                              path: accessor.split('@assets/')[1],\n                              params: assetsParams,\n                              acceptedExtensions: '*'\n                            };\n                            toResolve.read = assetsController.getReader(assetsParams);\n                            data[res.citeKey] = toResolve;\n                          } else {\n                            console.log('unhandled data accessor : ', accessor);\n                          }\n                        }\n                      }\n                    }\n                    nestedPropCallback(null, nestedProp);\n                  } else if (('' + val3).indexOf('@assets/') === 0) {\n                    assetsController.getAssetUri(val3.split('@assets/')[1], assetsParams, (err4, uri)=> {\n                      nestedProp.value = uri;\n                      nestedPropCallback(err4, nestedProp);\n                    });\n                  } else {\n                    nestedPropCallback(null, nestedProp);\n                  }\n                }, (err3, propsOut2)=> {\n                  const newProp2 = propsOut2.reduce((newCont, newContProp) =>{\n                    newCont[newContProp.key] = newContProp.value;\n                    return newCont;\n                  }, {});\n                  propArrayMembersCallback(err3, newProp2);\n                });\n              // resolve arrayed prop\n              }, (err2, arrayMembers)=> {\n                prop.value = arrayMembers;\n                contextualizationPropCallback(null, prop);\n              });\n            } else if (typeof val !== undefined && prop.key !== 'resources') {\n              if (('' + val).indexOf('@res') === 0) {\n                while ((match = resRe.exec(val)) !== null) {\n                  // Identify which resource is targetted (handling multi-resource contextualizations)\n                  const rank = match[1] ? (+match[1] - 1) : 0;\n                  // find resource data\n                  res = contextualization.resources[rank];\n                  if (res === undefined) {\n                    console.log('res is undefined, expression: ', val);\n                    return contextualizationPropCallback(undefined, prop);\n                  }\n                  const resProp = match[match.length - 1];\n                  // case: metadata call\n                  if (resProp.indexOf('data') !== 0) {\n                    // interpolate w/ resource value thanks to resourceProp path\n                    prop.value = res[resProp];\n                    // contextualizationPropCallback(null, prop);\n                  // case : data call\n                  } else {\n                    const dataPath = ('' + val).split('.').filter(path=>{\n                      return path.length;\n                    });\n                    prop.value = {\n                      type: 'path',\n                      target: 'data',\n                      path: dataPath\n                    };\n                    const defined = data[res.citeKey];\n                    if (!defined) {\n                      const accessor = res.data || res.url;\n                      if (('' + accessor).indexOf('@assets/') === 0) {\n                        const toResolve = {};\n                        toResolve.params = {\n                          path: accessor.split('@assets/')[1],\n                          params: assetsParams,\n                          acceptedExtensions: '*'\n                        };\n                        toResolve.read = assetsController.getReader(assetsParams);\n                        data[res.citeKey] = toResolve;\n                      } else {\n                        console.log('unhandled data accessor : ', accessor);\n                      }\n                    }\n                  }\n                }\n                contextualizationPropCallback(null, prop);\n              } else if (('' + val).indexOf('@assets/') === 0) {\n                assetsController.getAssetUri(val.split('@assets/')[1], assetsParams, (err3, uri)=> {\n                  prop.value = uri;\n                  contextualizationPropCallback(err3, prop);\n                });\n              } else {\n                contextualizationPropCallback(null, prop);\n              }\n            } else {\n              contextualizationPropCallback(null, prop);\n            }\n          }, (err1, propsOut1)=> {\n            const newContextualizer = propsOut1.reduce((newCont, propOut) =>{\n              newCont[propOut.key] = propOut.value;\n              return newCont;\n            }, {});\n\n            // console.log('new contextualization', Object.assign(contextualization, newContextualizer));\n            // pass contextualizer's resolved values to contextualization object\n            newContextualizer.contextualizerType = newContextualizer.type;\n            delete newContextualizer.type;// contextualization has a type also\n            const newContextualization = Object.assign(contextualization, newContextualizer);\n            contextualizationCallback(err1, newContextualization);\n          });\n        }, (contextualizationsError, contextualizations)=> {\n          sectio.contextualizations = contextualizations;\n          contextualizationsCallback(contextualizationsError, sectio);\n        });\n      }\n    // waterfall callback for all sections\n    ], (errs, sectios)=> {\n      allSectionsCallback(errs, sectios);\n    });\n  // global & final callback\n  }, (err, sections)=> {\n    if (resolveDataDependencies) {\n      asyncMapSeries(Object.keys(data), (key, dataCallback) =>{\n        const toResolve = data[key];\n        toResolve.read(toResolve.params, (dataErr, dataResult) =>{\n          if (dataErr) {\n            data[key] = dataErr;\n            dataCallback(null, key);\n          } else {\n            const raw = dataResult && dataResult.stringContents;\n            const ext = dataResult.extname;\n            // todo : handle other file formats\n            if (raw && ext === '.csv') {\n              csvConverter.fromString(raw, (parseErr, json)=>{\n                data[key] = {\n                  format: 'json',\n                  data: json\n                };\n                dataCallback(parseErr, key);\n              });\n            }else {\n              console.log('unhandled file format ', ext);\n              dataCallback(null, key);\n            }\n          }\n        });\n      }, (finalErr, keys) =>{\n        const finalSections = sections.map(sectio =>{\n          return Object.assign(sectio, {data: data});\n        });\n        callback(finalErr, finalSections);\n      });\n    } else {\n      const finalSections = sections.map(sectio =>{\n        return Object.assign(sectio, {data});\n      });\n      callback(err, finalSections);\n    }\n  });\n}\n"
  },
  {
    "__docId__": 254,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "CsvConverter",
    "memberof": "src/core/resolvers/resolveDataDependencies/index.js",
    "longname": "src/core/resolvers/resolveDataDependencies/index.js~CsvConverter",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/resolvers/resolveDataDependencies/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "csvConverter",
    "memberof": "src/core/resolvers/resolveDataDependencies/index.js",
    "longname": "src/core/resolvers/resolveDataDependencies/index.js~csvConverter",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/resolvers/resolveDataDependencies/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "CsvConverter"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "resolveDataDependencies",
    "memberof": "src/core/resolvers/resolveDataDependencies/index.js",
    "longname": "src/core/resolvers/resolveDataDependencies/index.js~resolveDataDependencies",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveDataDependencies/index.js",
    "importStyle": "resolveDataDependencies",
    "description": "Resolves interpolations ni metadata, resources, and contextualizations, and possibly fetches stores necessary data for rendering",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSections",
        "description": "the sections to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsController",
        "description": "the assets controller module to use to communicate with assets"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsParams",
        "description": "the params to use for accessing the assets"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "resolveData",
        "description": "whether to fetch and store necessary data right away or to store methods for later lazy-loading"
      },
      {
        "nullable": null,
        "types": [
          "function(err: error, finalSections: array)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "callbacks a possible errors and the updated list of sections"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 257,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/resolveSectionAgainstModels/index.js",
    "memberof": null,
    "longname": "src/core/resolvers/resolveSectionAgainstModels/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve sections against metadata models\n * @module resolvers/resolveSectionAgainstModels\n */\nimport {getResourceModel, resolvePropAgainstType} from './../../utils/modelUtils';\nimport {getMetaValue} from './../../utils/sectionUtils';\nimport {serializeHtmlMeta} from './../../resolvers/htmlMetaTemplateSerializer';\n\n/**\n * Consumes and normalize the metadata of a section\n * @param {Object} section - the section to resolve\n * @param {Object} models - the models to use for resolution\n * @param {function(err:error, result: {errors: array, section: Object})} callback - the resulting resolution errors and updated section\n */\nexport const resolveSectionAgainstModels = (section, models, callback) => {\n  const errors = [];\n  // validate resources\n  section.resources = section.resources.map((resource) =>{\n    const model = getResourceModel(resource.bibType, models.resourceModels);\n    if (model) {\n      // populate resource model with input resource data\n      return model.properties.reduce((resolvedResource, propModel) => {\n        const key = propModel.key;\n        if (propModel.required && !resource[key]) {\n          errors.push({\n            type: 'error',\n            preciseType: 'invalidResource',\n            sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n            message: 'property ' + key + ' is required in resource ' + resource.citeKey + '(bibType: ' + resource.bibType + ') and not present'\n          });\n        }else if (resource[key]) {\n          resolvedResource[key] = resolvePropAgainstType(resource[key], propModel.valueType, propModel);\n        } else if (propModel.default) {\n          resource[key] = propModel.default;\n        }\n        return resolvedResource;\n      }, {});\n    }\n    errors.push({\n      type: 'error',\n      preciseType: 'invalidResource',\n      sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n      message: 'Could not find suitable data model for resource ' + resource.citeKey\n    });\n    return {};\n  });\n\n  // validate metadata\n  section.metadata = section.metadata.map((metadata) => {\n    // resolve unicity\n    const model = models.metadataModels[metadata.domain][metadata.key];\n    if (model) {\n      const uniquePb = model.unique && Array.isArray(metadata.value) && metadata.value.length > 1;\n      if (uniquePb) {\n        errors.push({\n          type: 'error',\n          preciseType: 'invalidMetadata',\n          sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n          message: metadata.key + ' value was set more than once for section ' + getMetaValue(section.metadata, 'general', 'title')\n        });\n        metadata.value = metadata.value[0];\n      }\n\n      if (Array.isArray(metadata.value)) {\n        metadata.value = metadata.value.map((val)=> {\n          if (typeof metadata.value === 'string') {\n            return resolvePropAgainstType(val, model.valueType, model);\n          }\n          return val;\n        });\n\n      }else if (typeof metadata.value === 'string') {\n        metadata.value = resolvePropAgainstType(metadata.value, model.valueType, model);\n      }\n\n      if (model.headTemplate) {\n        metadata.htmlHead = serializeHtmlMeta(metadata, model.headTemplate);\n      }\n\n    }else {\n      errors.push({\n        type: 'warning',\n        preciseType: 'invalidMetadata',\n        sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n        message: metadata.domain + ' metadata property ' + metadata.key + ' is invalid in section ' + getMetaValue(section.metadata, 'general', 'title') + ' and therefore was not taken into account'\n      });\n    }\n\n    return metadata;\n  });\n\n  // defaults\n  for (const key in models.metadataModels.general) {\n    if (models.metadataModels.general[key].default) {\n      const present = getMetaValue(section.metadata, 'general', key);\n      if (!present) {\n        section.metadata.push({\n          domain: 'general',\n          key,\n          value: models.metadataModels.general[key].default\n        });\n      }\n    }\n  }\n  return callback(null, {errors, section});\n};\n"
  },
  {
    "__docId__": 258,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveSectionAgainstModels",
    "memberof": "src/core/resolvers/resolveSectionAgainstModels/index.js",
    "longname": "src/core/resolvers/resolveSectionAgainstModels/index.js~resolveSectionAgainstModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveSectionAgainstModels/index.js",
    "importStyle": "{resolveSectionAgainstModels}",
    "description": "Consumes and normalize the metadata of a section",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to use for resolution"
      },
      {
        "nullable": null,
        "types": [
          "function(err:error, result: {errors: array, section: Object})"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "the resulting resolution errors and updated section"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/citationUtils/citationModels.js",
    "memberof": null,
    "longname": "src/core/utils/citationUtils/citationModels.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to create a super abstract class for producing citation style specific, citation components\n * @module utils/citationModels\n */\nimport React, {PropTypes} from 'react';\nimport {\n  StructuredCOinS\n} from './../../components';\nimport * as formatter from './../microDataUtils/';\n\n/**\n * Virtual component class for rendering generic block citations\n */\nexport class BlockCitationModel extends React.Component {\n  /**\n   * propTypes\n   * @property {object} resource - the resource to use for making the citation\n   * @property {object} contextualization - the details of contextualization (e.g. page)\n   * @property {boolean} ibid - immediately recurrent citation ?\n   * @property {boolean} opCit - not immediately recurent citation ?\n   * @property {string} schemaType - microformat type fo the item\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    contextualization: PropTypes.object,\n    ibid: PropTypes.bool,\n    opCit: PropTypes.bool,\n    schemaType: PropTypes.string\n  };\n\n  /**\n   * Gets the schematype of the citation, from contextualization statement or from the resource bibType\n   * @return schemaType - the schematype of the citation\n  */\n  getSchemaType() {\n    return this.props.schemaType || formatter.bibToSchema(this.props.resource.bibType);\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <p\n      id={this.props.contextualization.citeKey}\n      className=\"peritext-block-citation\"\n      itemProp=\"citation\"\n      property=\"citation\"\n      itemScope\n      itemType={'http://schema.org/' + this.getSchemaType()}\n      typeof={this.getSchemaType()}\n    >\n      <StructuredCOinS resource={this.props.resource} />\n      {this.renderReference()}\n      {this.renderAdditionnal(this.props)}\n    </p>);\n  }\n}\n\n/**\n * Virtual component class for rendering generic inline citations\n */\nexport class InlineCitationModel extends React.Component {\n  /**\n   * propTypes\n   * @property {object} resource the resource to use for making the citation\n   * @property {object} contextualization the details of contextualization (e.g. page)\n   * @property {boolean} ibid immediately recurent citation ?\n   * @property {boolean} opCit not immediately recurent citation ?\n   * @property {string} schemaType microformat type fo the item\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    contextualization: PropTypes.object,\n    ibid: PropTypes.bool,\n    opCit: PropTypes.bool,\n    schemaType: PropTypes.string\n  };\n\n  /**\n   * Gets the schematype of the citation, from contextualization statement or from the resource bibType\n   * @return schemaType - the schematype of the citation\n  */\n  getSchemaType() {\n    return this.props.schemaType || formatter.bibToSchema(this.props.resource.bibType);\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (<span\n      id={this.props.contextualization.citeKey}\n      className=\"peritext-inline-citation\"\n      itemProp=\"citation\"\n      property=\"citation\"\n      itemScope\n      itemType={'http://schema.org/' + this.getSchemaType()}\n      typeof={this.getSchemaType()}\n    >\n      {this.renderReference()}\n      {this.renderAdditionnal(this.props)}\n    </span>);\n  }\n}\n"
  },
  {
    "__docId__": 260,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "BlockCitationModel",
    "memberof": "src/core/utils/citationUtils/citationModels.js",
    "longname": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/citationUtils/citationModels.js",
    "importStyle": "{BlockCitationModel}",
    "description": "Virtual component class for rendering generic block citations",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 261,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSchemaType",
    "memberof": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel#getSchemaType",
    "access": null,
    "description": "Gets the schematype of the citation, from contextualization statement or from the resource bibType",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "schemaType - the schematype of the citation"
    },
    "generator": false
  },
  {
    "__docId__": 262,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel#render",
    "access": null,
    "description": "render",
    "lineNumber": 43,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 263,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "InlineCitationModel",
    "memberof": "src/core/utils/citationUtils/citationModels.js",
    "longname": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/citationUtils/citationModels.js",
    "importStyle": "{InlineCitationModel}",
    "description": "Virtual component class for rendering generic inline citations",
    "lineNumber": 64,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 264,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSchemaType",
    "memberof": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel#getSchemaType",
    "access": null,
    "description": "Gets the schematype of the citation, from contextualization statement or from the resource bibType",
    "lineNumber": 85,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "schemaType - the schematype of the citation"
    },
    "generator": false
  },
  {
    "__docId__": 265,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel#render",
    "access": null,
    "description": "render",
    "lineNumber": 93,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 266,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/componentsFactory/index.js",
    "memberof": null,
    "longname": "src/core/utils/componentsFactory/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to consuming peritext contents' pseudo-dom representations by returning React markup\n * @module utils/modelUtils\n */\nimport React from 'react';\n\n/**\n * Consumes a peritext content's pseudo-dom node (described as a js object) and returns a react component\n * @param {Object} node - the pseudo-dom node\n * @param {number} index - the index of the node (used for providing react keys)\n * @return {ReactElement} markup describing the node\n */\nexport const jsToComponent = (node, index)=> {\n  if (node.node === 'text') {\n    return node.text;\n  }\n  if (node.special) {\n    // Component class stored as referenced object\n    const Component = node.tag;\n    return <Component key={index} {...node.props} />;\n  }\n  // plain string tag name\n  const Tag = node.tag;\n  return (<Tag key={index} id={node.attr && node.attr.id} href={node.attr && node.attr.href}>\n    {node.child && node.child.map(jsToComponent)}\n  </Tag>);\n};\n\n/**\n * Consumes a peritext content's pseudo-dom nodes list to produce react markup\n * @param {Object} contents - the pseudo-dom nodes array\n * @return {ReactElement|string} markup or string contents\n */\nexport default function renderContents(contents) {\n  if (Array.isArray(contents)) {\n    return contents.map(jsToComponent);\n  } else if (typeof contents === 'string') {\n    return contents;\n  }\n  return '';\n}\n"
  },
  {
    "__docId__": 267,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "jsToComponent",
    "memberof": "src/core/utils/componentsFactory/index.js",
    "longname": "src/core/utils/componentsFactory/index.js~jsToComponent",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/componentsFactory/index.js",
    "importStyle": "{jsToComponent}",
    "description": "Consumes a peritext content's pseudo-dom node (described as a js object) and returns a react component",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "the pseudo-dom node"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": "the index of the node (used for providing react keys)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup describing the node"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 268,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "renderContents",
    "memberof": "src/core/utils/componentsFactory/index.js",
    "longname": "src/core/utils/componentsFactory/index.js~renderContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/componentsFactory/index.js",
    "importStyle": "renderContents",
    "description": "Consumes a peritext content's pseudo-dom nodes list to produce react markup",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "the pseudo-dom nodes array"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement",
        "string"
      ],
      "spread": false,
      "description": "markup or string contents"
    },
    "generator": false
  },
  {
    "__docId__": 269,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/microDataUtils/index.js",
    "memberof": null,
    "longname": "src/core/utils/microDataUtils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - Collection of utils for formatting scholarly citations in html+schema+RDFa+COiNS elements\n * @module utils/microDataUtils\n */\n\n/**\n * Translates a peritext bibType to a schema.org Type\n * @param {string} bib - the peritext bibType\n * @return {string} SchemaType - the corresponding SchemaType\n */\nexport const bibToSchema = (bib) => {\n  switch (bib) {\n  case 'book':\n    return 'Book';\n  case 'article':\n    return 'ScholarlyArticle';\n  case 'booklet':\n    return 'CreativeWork';\n  case 'conference':\n    return 'Chapter';\n  case 'incollection':\n    return 'Chapter';\n  case 'inherits':\n    return 'Chapter';\n  case 'inbook':\n    return 'Chapter';\n  case 'mastersthesis':\n    return 'Thesis';\n  case 'phdthesis':\n    return 'Thesis';\n  case 'proceedings':\n    return 'Book';\n  case 'image':\n    return 'ImageObject';\n  case 'online':\n    return 'WebSite';\n  case 'vectorsImage':\n    return 'ImageObject';\n  case 'tabularData':\n    return 'Dataset';\n  case 'video':\n    return 'VideoObject';\n  case 'audio':\n    return 'AudioObject';\n  case 'person':\n    return 'Person';\n  case 'place':\n    return 'Place';\n  case 'organization':\n    return 'Organization';\n  // not very accurate\n  case 'artefact':\n    return 'Product';\n  // no schematype for these ones (too abstract)\n  case 'topic':\n  case 'concept':\n  case 'technology':\n    return 'Thing';\n  default:\n    return 'CreativeWork';\n  }\n};\n\n/*\n  Context Objects in Spans (COiNS) related functions\n*/\n\nconst addPropToCOinSData = (key, value) => {\n  return {\n    key: key,\n    value: value\n  };\n};\n\nconst urify = (key, value) => {\n  return key + '=' + encodeURIComponent(value);\n};\n\nconst assembleUri = (infos) => {\n  const vals = [];\n  infos.forEach(function(info) {\n    vals.push(urify(info.key, info.value));\n  });\n  return vals.join('&amp;');\n};\n\nconst baseMap = {\n  'rft.date': 'date',\n  'rft.pages': 'pages',\n  'rft.issn': 'ISSN',\n  'rft.isbn': 'ISBN',\n  'rft_id': 'url',\n  'rft.place': 'address',\n  'rft.pub': 'publisher'\n};\n\nconst journalMap = {\n  'rft.atitle': 'title',\n  'rft.jtitle': 'journal',\n  'rft.volume': 'volume',\n  'rft.issue': 'issue'\n};\n\nconst chapterMap = {\n  'rft.atitle': 'title',\n  'rft.btitle': 'booktitle'\n};\n\nconst translate = (data, item, map) => {\n  for (const key in map) {\n    if (item[map[key]]) {\n      data.push(addPropToCOinSData(key, item[map[key]]));\n    }\n  }\n  return data;\n};\n\n/**\n * Generates an openUrl URI describing the resource, and aimed at being used in a ContextObjectInSpan (COinS)\n * @param {Object} resource - the resource to describe with an openUrl\n * @return {string} uri - the uri describing the resource\n */\nexport const generateOpenUrl = (resource) => {\n  let data = [];\n  data.push(addPropToCOinSData('ctx_ver', 'Z39.88-2004'));\n\n  if (resource.author && resource.author.length) {\n    resource.author.forEach(function(author) {\n      data.push(addPropToCOinSData('rft.au', author.lastName + ', ' + author.firstName));\n    });\n  }\n  data = translate(data, resource, baseMap);\n  if (resource.bibType === 'journal' || resource.bibType === 'article') {\n    data = translate(data, resource, journalMap);\n    data.push(addPropToCOinSData('rft.genre', 'article'));\n    data.push(addPropToCOinSData('rft_val_fmt', 'info:ofi/fmt:kev:mtx:journal'));\n  }else if (resource.bibType === 'proceedings' || resource.bibType === 'conferencePaper') {\n    data = translate(data, resource, journalMap);\n    data.push(addPropToCOinSData('rft.genre', 'conference'));\n    data.push(addPropToCOinSData('rft_val_fmt', 'info:ofi/fmt:kev:mtx:book'));\n  }else if (resource.bibType === 'chapter') {\n    data = translate(data, resource, chapterMap);\n    data.push(addPropToCOinSData('rft.genre', 'bookitem'));\n    data.push(addPropToCOinSData('rft_val_fmt', 'info:ofi/fmt:kev:mtx:book'));\n  }else {\n    data.push(addPropToCOinSData('rft.genre', 'document'));\n  }\n  return assembleUri(data);\n};\n"
  },
  {
    "__docId__": 270,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "bibToSchema",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~bibToSchema",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": "{bibToSchema}",
    "description": "Translates a peritext bibType to a schema.org Type",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bib",
        "description": "the peritext bibType"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "SchemaType - the corresponding SchemaType"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "addPropToCOinSData",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~addPropToCOinSData",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "urify",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~urify",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 273,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "assembleUri",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~assembleUri",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "baseMap",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~baseMap",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "journalMap",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~journalMap",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "chapterMap",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~chapterMap",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "generateOpenUrl",
    "memberof": "src/core/utils/microDataUtils/index.js",
    "longname": "src/core/utils/microDataUtils/index.js~generateOpenUrl",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/microDataUtils/index.js",
    "importStyle": "{generateOpenUrl}",
    "description": "Generates an openUrl URI describing the resource, and aimed at being used in a ContextObjectInSpan (COinS)",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "the resource to describe with an openUrl"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "uri - the uri describing the resource"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/modelUtils/index.js",
    "memberof": null,
    "longname": "src/core/utils/modelUtils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to everything that deals with models (composing, translating values, ...)\n * @module utils/modelUtils\n */\nimport {parseBibAuthors} from './../../converters/bibTexConverter';\n\n/**\n * Builds a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType\n * @param {string} bibType - the bibType of the resource\n * @param {Object} resourceModels - the models describing resources data\n * @return {Object} model - the model corresponding to the input bibType\n */\nexport const getResourceModel = (bibType, resourceModels) =>{\n  const model = resourceModels.individual[bibType];\n  if (model) {\n    // first set highestly specific props\n    let properties = model.properties;\n    let defaultContextualizer = model.defaultContextualizer;\n    let otherProps;\n    let existing;\n    // then parse related categories\n    model.categories.forEach((category) => {\n      otherProps = resourceModels.collective[category]\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n      properties = properties.concat(otherProps);\n\n      // inherit default contextualizer\n      if (resourceModels.collective[category].defaultContextualizer && !defaultContextualizer) {\n        defaultContextualizer = resourceModels.collective[category].defaultContextualizer;\n      }\n    });\n    // then finally parse common props\n    otherProps = resourceModels.collective.common\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n    properties = properties.concat(otherProps);\n\n    return Object.assign({}, model, {properties: model.properties.concat(properties)}, {defaultContextualizer});\n  }\n  return undefined;\n};\n\n/**\n * Build a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType\n * @param {string} bibType - the bibType of the contextualizer\n * @param {Object} contextualizerModels - the models describing contextualizer possible data\n * @return {Object} model - the model corresponding to the input bibType\n */\nexport const getContextualizerModel = (bibType, contextualizerModels) =>{\n  const model = contextualizerModels.individual[bibType];\n  if (model) {\n    // first set highestly specific props\n    let properties = model.properties;\n    let otherProps;\n    let existing;\n    // then parse related categories\n    model.categories.forEach((category) => {\n      otherProps = contextualizerModels.collective[category]\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n      properties = properties.concat(otherProps);\n\n    });\n\n    // then finally parse common props\n    otherProps = contextualizerModels.collective.common\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n    properties = properties.concat(otherProps);\n    return Object.assign({}, model, {properties});\n  }\n  return undefined;\n};\n\n/**\n * Transforms a (possibly not primitive : array, object, bibAuthor) value to a string-friendly value, thanks to its model's type\n * @param {Object} prop - the prop to serialize\n * @param {string} valueType - the type of the value ('string', 'stringArray', 'bibAuthor', ...)\n * @param {Object} model - the model to parse the prop against\n * @return {string} newValue - the serialized value\n */\nexport const serializePropAgainstType = (prop, valueType, model) => {\n  if (prop === undefined) {\n    return undefined;\n  }\n  switch (valueType) {\n  case 'string':\n    return prop;\n\n  case 'stringArray':\n    return prop.join(', ');\n\n  case 'bibAuthorsArray':\n    return prop.map((author) =>{\n      if (author.firstName) {\n        return author.firstName + ' {' + author.lastName + '}';\n      }\n      return author.lastName;\n    }).join('; ');\n\n  case 'objectArray' : {\n    if (model.children && Array.isArray(prop)) {\n      const newProp = prop.map((obj)=>{\n        if (typeof obj === 'object') {\n          const vals = Object.keys(obj).map((key)=>{\n            if (obj[key] !== undefined) {\n              return key + '=' + obj[key];\n            }\n            return '';\n          });\n          return vals.filter((part)=>{return part.length;}).join(',');\n        }\n        return undefined;\n      });\n      return newProp;\n    }\n    break;\n  }\n\n  default:\n    return prop;\n  }\n\n};\n\n/**\n * Transforms a string value to a complex and type-compliant value, thanks to its model's type\n * @param {Object} prop - the prop to resolve\n * @param {string} valueType - the type of the value ('string', 'stringArray', 'bibAuthor', ...)\n * @param {Object} model - the model to parse the prop against\n * @return {string|array|number|Object} newValue - the resolved value\n */\nexport const resolvePropAgainstType = (prop, valueType, model) => {\n  if (prop === undefined) {\n    // looking for a default value if no value specified\n    if (model.default) {\n      return model.default;\n    }\n    return undefined;\n  // looking for restricted values\n  } else if (model.values) {\n    const validValue = model.values.find((value) => {\n      return value === prop;\n    });\n    // value not allowed\n    if (validValue === undefined) {\n      // look for default\n      if (model.default) {\n        return model.default;\n      }\n      // or return undefined\n      return undefined;\n    }\n  }\n  switch (valueType) {\n  case 'number':\n    return +prop;\n\n  case 'numberArray':\n    return prop.split(',').map((number)=> {\n      return +number.trim();\n    });\n\n  case 'string':\n    /*\n    if (model.values) {\n      // nominal set of possible values\n      val = model.values.some((mval)=>{\n        return mval === prop;\n      });\n      console.log('val : ', val);\n      return val;\n    }\n    */\n    return prop;\n\n  case 'stringArray':\n    return prop.split(/,|;/).map((value)=>{return value.trim();});\n\n  case 'bibAuthorsArray':\n    return parseBibAuthors(prop);\n\n  case 'objectArray' : {\n    if (model.children && Array.isArray(prop)) {\n      const newProp = prop.map((obj)=>{\n        if (typeof obj === 'object') {\n          const newObj = model.children.reduce((thatObj, childModel) =>{\n            thatObj[childModel.key] = resolvePropAgainstType(obj[childModel.key], childModel.valueType, childModel);\n            return thatObj;\n          }, {});\n          return newObj;\n        }\n        return undefined;\n      });\n      return newProp;\n    }\n  }\n\n  default:\n    return prop;\n  }\n};\n\n/**\n * Populate rendering settings according to default bibtype-related settings\n * @param {Object} settings - the settings provided as input\n * @param {string} bibType - the bibType of the root section to render\n * @param {Object} settingsModel - the model to use for populating the settings\n * @return {Object} newSettings - the populated settings\n */\nexport const resolveSettings = (settings = {}, bibType, settingsModel) =>{\n  const typeModel = {};\n  for (const param in settingsModel) {\n    if (settingsModel[param].default[bibType]) {\n      typeModel[param] = settingsModel[param].default[bibType];\n    } else {\n      typeModel[param] = settingsModel[param].default.default;\n    }\n  }\n  return Object.assign(typeModel, settings);\n};\n"
  },
  {
    "__docId__": 280,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getResourceModel",
    "memberof": "src/core/utils/modelUtils/index.js",
    "longname": "src/core/utils/modelUtils/index.js~getResourceModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils/index.js",
    "importStyle": "{getResourceModel}",
    "description": "Builds a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the resource"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "resourceModels",
        "description": "the models describing resources data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "model - the model corresponding to the input bibType"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getContextualizerModel",
    "memberof": "src/core/utils/modelUtils/index.js",
    "longname": "src/core/utils/modelUtils/index.js~getContextualizerModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils/index.js",
    "importStyle": "{getContextualizerModel}",
    "description": "Build a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the contextualizer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualizerModels",
        "description": "the models describing contextualizer possible data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "model - the model corresponding to the input bibType"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializePropAgainstType",
    "memberof": "src/core/utils/modelUtils/index.js",
    "longname": "src/core/utils/modelUtils/index.js~serializePropAgainstType",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils/index.js",
    "importStyle": "{serializePropAgainstType}",
    "description": "Transforms a (possibly not primitive : array, object, bibAuthor) value to a string-friendly value, thanks to its model's type",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "prop",
        "description": "the prop to serialize"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "valueType",
        "description": "the type of the value ('string', 'stringArray', 'bibAuthor', ...)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "the model to parse the prop against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "newValue - the serialized value"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolvePropAgainstType",
    "memberof": "src/core/utils/modelUtils/index.js",
    "longname": "src/core/utils/modelUtils/index.js~resolvePropAgainstType",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils/index.js",
    "importStyle": "{resolvePropAgainstType}",
    "description": "Transforms a string value to a complex and type-compliant value, thanks to its model's type",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "prop",
        "description": "the prop to resolve"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "valueType",
        "description": "the type of the value ('string', 'stringArray', 'bibAuthor', ...)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "the model to parse the prop against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string",
        "array",
        "number",
        "Object"
      ],
      "spread": false,
      "description": "newValue - the resolved value"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveSettings",
    "memberof": "src/core/utils/modelUtils/index.js",
    "longname": "src/core/utils/modelUtils/index.js~resolveSettings",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils/index.js",
    "importStyle": "{resolveSettings}",
    "description": "Populate rendering settings according to default bibtype-related settings",
    "lineNumber": 244,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the settings provided as input"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the root section to render"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settingsModel",
        "description": "the model to use for populating the settings"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSettings - the populated settings"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/referenceUtils/index.js",
    "memberof": null,
    "longname": "src/core/utils/referenceUtils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to representing a reference/bibliography section\n * @module utils/referenceUtils\n */\n\nconst bibliographicTypes = [\n  'article',\n  'book',\n  'booklet',\n  'collection',\n  'conference',\n  'inbook',\n  'incollection',\n  'inproceedings',\n  'manual',\n  'mastersthesis',\n  'phdthesis',\n  'proceedings',\n  'techreport',\n  'unpublished'\n];\n\n/**\n * Checks whether a given references belongs to a \"traditional\" bibliographical reference (journal article, book, ...)\n * @param {string} bibType - the bibType of the resource\n * @return {boolean} isBibliographical\n */\nconst isBibliographical = (bibType) =>{\n  const bibliType = bibliographicTypes.find((type)=> {\n    return bibType === type;\n  });\n  return bibliType !== undefined;\n};\n\n/**\n * Filter and order a list of resources against bibliography settings\n * @param {array} sections - the sections to handle for building the list\n * @param {Object} settings - the rendering settings, among which are bibliography-making related settings\n * @return {array} references - the resulting list\n */\nexport const computeReferences = (sections, settings) =>{\n  if (settings.referenceScope === 'document') {\n    const references = sections.reduce((refs, section)=> {\n      return refs.concat(section.resources.filter((resource)=> {\n        return resource.inheritedVerticallyFrom === undefined;\n      }));\n    }, []);\n\n    // handle filters\n    const filters = (settings.referenceFilters || []) && settings.referenceFilters.split(' ');\n    const filteredReferences = filters.reduce((outputReferences, filter)=> {\n      switch (filter) {\n      case 'has-title':\n        return outputReferences.filter((ref)=> {\n          return ref.title !== undefined;\n        });\n      case 'bibliographical':\n        return outputReferences.filter((ref)=> {\n          return isBibliographical(ref.bibType);\n        });\n      // todo : document filters\n      // todo : design new filters\n      default:\n        return outputReferences;\n      }\n    }, references);\n\n    // order references\n    const order = settings.referenceSortBy;\n    const sortedReferences = filteredReferences.sort((ref1, ref2)=> {\n      switch (order) {\n      case 'title':\n        return (ref1.title && ref1.title.toLowerCase()) > (ref2.title && ref2.title.toLowerCase()) ? 1 : -1;\n      case 'authors':\n        const print1 = ref1.author && ref1.author.reduce((str1, author1)=> {\n          return str1 + author1.lastName + '-';\n        }, '');\n        const print2 = ref2.author && ref2.author.reduce((str2, author2)=> {\n          return str2 + author2.lastName + '-';\n        }, '');\n        return print1 > print2 ? 1 : -1;\n      case 'year':\n        return ref1.year > ref2.year ? 1 : -1;\n      case 'type':\n        return ref1.bibType > ref2.bibType ? 1 : -1;\n      default:\n        return 1;\n      }\n    });\n    return sortedReferences;\n  }\n};\n"
  },
  {
    "__docId__": 286,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "bibliographicTypes",
    "memberof": "src/core/utils/referenceUtils/index.js",
    "longname": "src/core/utils/referenceUtils/index.js~bibliographicTypes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/referenceUtils/index.js",
    "importStyle": null,
    "description": "Utils - dedicated to representing a reference/bibliography section",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@module",
        "tagValue": "utils/referenceUtils"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "isBibliographical",
    "memberof": "src/core/utils/referenceUtils/index.js",
    "longname": "src/core/utils/referenceUtils/index.js~isBibliographical",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/referenceUtils/index.js",
    "importStyle": null,
    "description": "Checks whether a given references belongs to a \"traditional\" bibliographical reference (journal article, book, ...)",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the resource"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "isBibliographical"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "computeReferences",
    "memberof": "src/core/utils/referenceUtils/index.js",
    "longname": "src/core/utils/referenceUtils/index.js~computeReferences",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/referenceUtils/index.js",
    "importStyle": "{computeReferences}",
    "description": "Filter and order a list of resources against bibliography settings",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "sections",
        "description": "the sections to handle for building the list"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the rendering settings, among which are bibliography-making related settings"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "references - the resulting list"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/sectionUtils/index.js",
    "memberof": null,
    "longname": "src/core/utils/sectionUtils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - section metadata & resources utils : access, filter, deletion, ...\n * @module utils/sectionUtils\n */\n\n/**\n * Gets a value in metadata props array by its domain and key\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @return {string} value - the value\n */\nexport const getMetaValue = (metaList, domain, key) =>{\n  const prop = metaList.find((meta) =>{\n    return meta.domain === domain && meta.key === key;\n  });\n  if (prop) {\n    return prop.value;\n  }\n  return undefined;\n};\n\n/**\n * Sets a value in metadata props array after localized it by its domain and key\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @param {string} newValue - the new value to assign to the prop\n * @return {array} newlist - the updated list\n */\nexport const setMetaValue = (metaList, domain, key, newValue) =>{\n  const newMetaList = metaList.map((meta) =>{\n    if (meta.domain === domain && meta.key === key) {\n      meta.value = newValue;\n    }\n    return meta;\n  });\n  return newMetaList;\n};\n\n/**\n * Checks if the value has a metadata property\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @return {boolean} hasMeta - whether the prop is there\n */\nexport const hasMeta = (metaList, domain, key) =>{\n  if (typeof domain === 'string') {\n    return getMetaValue(metaList, domain, key) !== undefined;\n  }else if (domain.domain) {\n    return getMetaValue(metaList, domain.domain, domain.key) !== undefined;\n  }\n  throw new Error('error in couple ' + domain + '_' + key + ': hasMeta method needs either a domain+key pair or a metadata prop object');\n};\n\n/**\n * Finds a specific section in a sections list through one of its metadata\n * @param {array} sections - the sections array to search in\n * @param {string} domain - the domain of the prop used to search the section, stored in its \"domain\" prop\n * @param {string} key - the key of the prop used to search the section, stored in its \"key\" prop\n * @return {Object} section - the resulting section\n */\nexport const findByMetadata = (sections, domain, key, value) =>{\n  return sections.find((section) =>{\n    const meta = getMetaValue(section.metadata, domain, key);\n    return meta === value;\n  });\n};\n\n/**\n * Checks if two metadata props have the same scope (domain and key)\n * @param {Object} meta1 - the first metadata prop\n * @param {Object} meta1 - the second metadata prop\n * @return {boolean} sameScope - whether the two props have the same scope\n */\nexport const sameMetaScope = (meta1, meta2) =>{\n  return meta1.domain === meta2.domain && meta1.key === meta2.key;\n};\n\n/**\n * Delete a specific metadata prop\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @return {array} updatedMetaList - the new metadata list, without the deleted prop\n */\nexport const deleteMeta = (metaList, domain, key) =>{\n  return metaList.filter((meta)=>{\n    return !(domain === meta.domain && key === meta.key);\n  });\n};\n\n/**\n * Converts a bibtex metadata expression (e.g. \"title\", \"twitter_twitter\") to an object prop\n * @param {string} str - the bibtex metadata expression\n * @return {Object} metadata - the metadata prop object, without value\n */\nexport const metaStringToCouple = (str) =>{\n  const parts = str.split('_');\n  const domain = (parts.length > 1) ? parts.shift() : 'general';\n  const key = parts.join('_');\n  return {domain, key};\n};\n\n/**\n * Checks if a resource list contains a resource, by citeKey\n * @param {array} resourcesList - the resources list in which looking for\n * @param {Object} resource - the resource to look for\n * @return {boolean} hasResource - whether resource is present in the list\n */\nexport const hasResource = (resourcesList, resource) =>{\n  return resourcesList.find((res) =>{\n    return resource.citeKey === res.citeKey;\n  }) !== undefined;\n};\n\n/**\n * Filter resources that have a specific value\n * @param {array} resourcesList - the list of resource sto filter\n * @param {string} key - the key by which filtering the resources\n * @param {string} value - the value by which filtering the resources\n * @return {array} updatedResourceList - the filtered resources list\n */\nexport const filterResources = (resourcesList, key, value) =>{\n  return resourcesList.filter((res) =>{\n    return res[key] === value;\n  });\n};\n\n"
  },
  {
    "__docId__": 290,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getMetaValue",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~getMetaValue",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{getMetaValue}",
    "description": "Gets a value in metadata props array by its domain and key",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "metaList",
        "description": "the list of metadata objects in which looking for the value"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "the domain of the prop, stored in its \"domain\" prop"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key of the prop, stored in its \"key\" prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "value - the value"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "setMetaValue",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~setMetaValue",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{setMetaValue}",
    "description": "Sets a value in metadata props array after localized it by its domain and key",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "metaList",
        "description": "the list of metadata objects in which looking for the value"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "the domain of the prop, stored in its \"domain\" prop"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key of the prop, stored in its \"key\" prop"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value to assign to the prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "newlist - the updated list"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "hasMeta",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~hasMeta",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{hasMeta}",
    "description": "Checks if the value has a metadata property",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "metaList",
        "description": "the list of metadata objects in which looking for the value"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "the domain of the prop, stored in its \"domain\" prop"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key of the prop, stored in its \"key\" prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "hasMeta - whether the prop is there"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "findByMetadata",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~findByMetadata",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{findByMetadata}",
    "description": "Finds a specific section in a sections list through one of its metadata",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "sections",
        "description": "the sections array to search in"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "the domain of the prop used to search the section, stored in its \"domain\" prop"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key of the prop used to search the section, stored in its \"key\" prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "section - the resulting section"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "sameMetaScope",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~sameMetaScope",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{sameMetaScope}",
    "description": "Checks if two metadata props have the same scope (domain and key)",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "meta1",
        "description": "the first metadata prop"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "meta1",
        "description": "the second metadata prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "sameScope - whether the two props have the same scope"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "deleteMeta",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~deleteMeta",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{deleteMeta}",
    "description": "Delete a specific metadata prop",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "metaList",
        "description": "the list of metadata objects in which looking for the value"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "the domain of the prop, stored in its \"domain\" prop"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key of the prop, stored in its \"key\" prop"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "updatedMetaList - the new metadata list, without the deleted prop"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "metaStringToCouple",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~metaStringToCouple",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{metaStringToCouple}",
    "description": "Converts a bibtex metadata expression (e.g. \"title\", \"twitter_twitter\") to an object prop",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the bibtex metadata expression"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "metadata - the metadata prop object, without value"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "hasResource",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~hasResource",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{hasResource}",
    "description": "Checks if a resource list contains a resource, by citeKey",
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "resourcesList",
        "description": "the resources list in which looking for"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "the resource to look for"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "hasResource - whether resource is present in the list"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "filterResources",
    "memberof": "src/core/utils/sectionUtils/index.js",
    "longname": "src/core/utils/sectionUtils/index.js~filterResources",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils/index.js",
    "importStyle": "{filterResources}",
    "description": "Filter resources that have a specific value",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "resourcesList",
        "description": "the list of resource sto filter"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key by which filtering the resources"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value by which filtering the resources"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "updatedResourceList - the filtered resources list"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/validators/index.js",
    "memberof": null,
    "longname": "src/core/validators/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Validators check some data against some models.\n * They should record errors and return them in a callback along with input data, either in first argument or in a {errors, data} second argument.\n * They should not modify/correct input data.\n * @module validators\n */\n\nexport {validateResources} from './sectionValidator';\n"
  },
  {
    "__docId__": 300,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/validators/sectionValidator/index.js",
    "memberof": null,
    "longname": "src/core/validators/sectionValidator/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Section-related validation functions\n * @todo lighten sectionConverter by putting more utils there\n * @module validators/sectionValidator\n */\n\nimport {getMetaValue, filterResources} from './../../utils/sectionUtils';\n\n/**\n * Validates the resources of a section against resources models\n * @param {Object} section - the section to validate\n * @param {Object} models - the models to use for validation\n * @param {function(err: null, output: Object)} callback - callbacks a list of validation errors descriptions, and unmodified sections\n */\nexport const validateResources = (section, models, callback) =>{\n  const errors = [];\n\n  section.resources.forEach((resource) =>{\n    // validate resources unicity\n    const other = filterResources(section.resources, 'citeKey', resource.citeKey);\n    if (other.length > 1) {\n      errors.push({\n        type: 'error',\n        preciseType: 'invalidResource',\n        sectionCiteKey: getMetaValue(section.metadata, 'general', 'citeKey'),\n        resourceCiteKey: resource.citeKey,\n        message: 'Resource ID ' + resource.citeKey + 'is not unique'\n      });\n    }\n  });\n  return callback(null, {errors, section});\n};\n"
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "validateResources",
    "memberof": "src/core/validators/sectionValidator/index.js",
    "longname": "src/core/validators/sectionValidator/index.js~validateResources",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/validators/sectionValidator/index.js",
    "importStyle": "{validateResources}",
    "description": "Validates the resources of a section against resources models",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to validate"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to use for validation"
      },
      {
        "nullable": null,
        "types": [
          "function(err: null, output: Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "callbacks a list of validation errors descriptions, and unmodified sections"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/exporters/index.js",
    "memberof": null,
    "longname": "src/exporters/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Exporters - pure functions that export contents in different formats\n * @module exporters\n */\n\nexport {default as exportSectionToPdf} from './pdfExporter';\n"
  },
  {
    "__docId__": 303,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/exporters/pdfExporter/index.js",
    "memberof": null,
    "longname": "src/exporters/pdfExporter/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Prince PDF exporter\n * @module exporters/pdfExporter\n */\n\n\n/**\n * This module inputs a specific peritext section, including possibly its children sections\n * and outputs a pdf file ready to display.\n * The converter used is PrinceXML non-commercial version.\n * After endless trials with free software converters such as wkhtmltopdf, weasyprint or phantomjs-pdf,\n * I could not find a way to use a free (gratis & open) tech. to produce & sufficiently reliable and user-customizable pdf output (notably via css3 @paged-media props).\n * For instance, wkhtmltopdf (and webkit-based converters in general) does not support 'float:footnotes' feature which is mandatory for scholarly outputs like peritext's ones\n * Therefore I chose proprietary software PrinceXML, which works wonderfully well. It is used in its free version for now (which is why Prince logo is added on the first page, no commercial use license)\n */\n\nconst Prince = require('prince');\nimport {resolve} from 'path';\nimport {waterfall} from 'async';\nimport {\n  writeFile,\n  exists,\n  mkdir\n} from 'fs';\n\nimport {getMetaValue} from './../../core/utils/sectionUtils';\nimport {renderSection} from './../../renderers/renderToStaticHtml';\n\n/**\n * Exports a section representation to a pdf file\n * @param {Object} params - The params of the export\n * @param {Object} params.section - the (root) section to export\n * @param {array} params.sectionList - the section context (if necessary)\n * @param {Object} params.settings - the specific rendering settings to use in order to produce the output\n * @param {boolean} params.includeChildren - whether to include section's children sections\n * @param {string} params.destinationFolder - where to output the file\n * @params {Object} assetsController - the module to use in order to communicate with assets\n * @param {Object} assetsParams - the assets parameters to use while communicating with assetsController\n * @param {function(err:error)} callback - the possible errors encountered during export\n */\nexport const exportSectionToPdf = ({\n  section,\n  sectionList,\n  settings,\n  includeChildren,\n  destinationFolder,\n}, assetsController, assetsParams, finalCallback) =>{\n\n  const motherKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  const path = destinationFolder || resolve(__dirname + './temp/');\n  console.log('path', path);\n  waterfall([\n    // get or create destination folder\n    (existsCb)=> {\n      exists(path, (isThere)=> {\n        if (!isThere) {\n          return mkdir(path, existsCb);\n        }\n        return existsCb(null);\n      });\n    },\n    // render the section to static html\n    (renderCb)=> {\n      renderSection({section, sectionList, includeChildren, destinationFolder}, assetsController, assetsParams, renderCb);\n    },\n    // write the section to a static html file\n    (html, writeCb)=> {\n      writeFile(path + '/' + motherKey + '.html', html, 'utf-8', writeCb);\n    }\n  ], (err)=> {\n    if (!err) {\n      Prince()\n      .inputs(path + '/' + motherKey + '.html')\n      .output(path + '/' + motherKey + '.pdf')\n      .execute()\n      .then(function() {\n        console.log('saved to pdf with PrinceXML');\n        return finalCallback();\n      }, function(error) {\n        console.log('Prince ERROR: ', error);\n        return finalCallback(error);\n      });\n    } else {\n      console.error('error during rendering to static html : ', err);\n      return finalCallback(err);\n    }\n  });\n};\n"
  },
  {
    "__docId__": 304,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "Prince",
    "memberof": "src/exporters/pdfExporter/index.js",
    "longname": "src/exporters/pdfExporter/index.js~Prince",
    "access": null,
    "export": false,
    "importPath": "peritext/src/exporters/pdfExporter/index.js",
    "importStyle": null,
    "description": "This module inputs a specific peritext section, including possibly its children sections\nand outputs a pdf file ready to display.\nThe converter used is PrinceXML non-commercial version.\nAfter endless trials with free software converters such as wkhtmltopdf, weasyprint or phantomjs-pdf,\nI could not find a way to use a free (gratis & open) tech. to produce & sufficiently reliable and user-customizable pdf output (notably via css3 @paged-media props).\nFor instance, wkhtmltopdf (and webkit-based converters in general) does not support 'float:footnotes' feature which is mandatory for scholarly outputs like peritext's ones\nTherefore I chose proprietary software PrinceXML, which works wonderfully well. It is used in its free version for now (which is why Prince logo is added on the first page, no commercial use license)",
    "lineNumber": 17,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "exportSectionToPdf",
    "memberof": "src/exporters/pdfExporter/index.js",
    "longname": "src/exporters/pdfExporter/index.js~exportSectionToPdf",
    "access": null,
    "export": true,
    "importPath": "peritext/src/exporters/pdfExporter/index.js",
    "importStyle": "{exportSectionToPdf}",
    "description": "Exports a section representation to a pdf file",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@params",
        "tagValue": "{Object} assetsController - the module to use in order to communicate with assets"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "The params of the export"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.section",
        "description": "the (root) section to export"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.sectionList",
        "description": "the section context (if necessary)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.settings",
        "description": "the specific rendering settings to use in order to produce the output"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "params.includeChildren",
        "description": "whether to include section's children sections"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "params.destinationFolder",
        "description": "where to output the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsParams",
        "description": "the assets parameters to use while communicating with assetsController"
      },
      {
        "nullable": null,
        "types": [
          "function(err:error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "the possible errors encountered during export"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/index.js",
    "memberof": null,
    "longname": "src/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Peritext library entrypoint\n * @module peritext\n */\n\nimport * as assetsC from './core/controllers/assetsController';\nimport * as contentsC from './core/controllers/contentsController';\nimport * as models from './core/models';\nimport * as parameters from './config/defaultParameters';\n\n/**\n * Exposes assets communication methods\n * @property {Object} assetsController\n */\nexport const assetsController = assetsC;\n/**\n * Exposes contents communication methods\n * @property {Object} contentsController\n */\nexport const contentsController = contentsC;\n/**\n * Exposes peritext default models for metadata, resources, contextualizers, and rendering settings\n * @property {Object} defaultModels\n */\nexport const defaultModels = models;\n/**\n * Exposes default language parameters for includes and templates\n * @property {Object} defaultParameters\n */\nexport const defaultParameters = parameters;\n\n/**\n * Exposes section export to pdf with print renderer function\n * @property {function} exportSectionToPdf\n */\nexport {exportSectionToPdf} from './exporters/pdfExporter';\n"
  },
  {
    "__docId__": 307,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "assetsController",
    "memberof": "src/index.js",
    "longname": "src/index.js~assetsController",
    "access": null,
    "export": true,
    "importPath": "peritext/src/index.js",
    "importStyle": "{assetsController}",
    "description": "Exposes assets communication methods",
    "lineNumber": 15,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsController",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 308,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contentsController",
    "memberof": "src/index.js",
    "longname": "src/index.js~contentsController",
    "access": null,
    "export": true,
    "importPath": "peritext/src/index.js",
    "importStyle": "{contentsController}",
    "description": "Exposes contents communication methods",
    "lineNumber": 20,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "contentsController",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 309,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultModels",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaultModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/index.js",
    "importStyle": "{defaultModels}",
    "description": "Exposes peritext default models for metadata, resources, contextualizers, and rendering settings",
    "lineNumber": 25,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultModels",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultParameters",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaultParameters",
    "access": null,
    "export": true,
    "importPath": "peritext/src/index.js",
    "importStyle": "{defaultParameters}",
    "description": "Exposes default language parameters for includes and templates",
    "lineNumber": 30,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultParameters",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/referencers/index.js",
    "memberof": null,
    "longname": "src/referencers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Set of citation style-specific components\n * @module referencers\n */\nimport * as iso690frLib from './iso690fr.js';\n\n/**\n * ISO 690 style citation - formatted in french language\n * @todo : try to internationalize it from scratch in order to have language-agnostic citation modules ?\n */\nexport const iso690fr = iso690frLib;\n"
  },
  {
    "__docId__": 312,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "iso690fr",
    "memberof": "src/referencers/index.js",
    "longname": "src/referencers/index.js~iso690fr",
    "access": null,
    "export": true,
    "importPath": "peritext/src/referencers/index.js",
    "importStyle": "{iso690fr}",
    "description": "ISO 690 style citation - formatted in french language",
    "lineNumber": 11,
    "todo": [
      ": try to internationalize it from scratch in order to have language-agnostic citation modules ?"
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/referencers/iso690fr.js",
    "memberof": null,
    "longname": "src/referencers/iso690fr.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * iso690 bibliographic norm formatter (lang: fr)\n * @module referencers/iso690fr\n * @todo Not finished resourceType-to-citation mapping (documented properly only books and journal articles - setup a default presentation for others)\n * Doc 1 : http://revues.refer.org/telechargement/fiche-bibliographie.pdf\n * Doc 2 : https://www.mpl.ird.fr/documentation/download/FormBibliog.pdf\n */\n\nimport React, {PropTypes} from 'react';\nimport {InlineCitationModel, BlockCitationModel} from './../core/utils/citationUtils/citationModels.js';\nimport {\n  StructuredPerson,\n  StructuredDate,\n  StructuredParentJournal,\n  StructuredSpan,\n  StructuredPublisher,\n  StructuredCite\n} from './../core/components/';\nimport Radium from 'radium';\n\n/**\n * Renders additionnal citation information, such as pages mentions, translations, etc.\n * @param {Object} propsObj - the React element props\n * @return {ReactElement} markup\n */\nconst renderAdditionnal = (propsObj) =>{\n  const details = propsObj.contextualization.contextualizer;\n  if (!details) {\n    return '';\n  }\n  return (\n    <span className=\"peritext-citation-details\">\n      {details.page || details.pages || propsObj.resource.caption || propsObj.resource.note || propsObj.resource.translation || propsObj.resource.original ? ', ' : ''}\n      {details.page ?\n        <span className=\"peritext-citation-quote-pages\">\n        p. {details.page}\n        </span>\n       : ''}\n       {details.pages ?\n        <span className=\"peritext-citation-quote-pages\">\n        pp. {details.pages}\n        </span>\n       : ''}\n       {(details.page || details.pages) && propsObj.resource.caption ? ', ' : ''}\n       {propsObj.resource.caption ?\n        <StructuredSpan htmlClass=\"peritext-citation-comment\" property=\"comment\" value={propsObj.resource.caption} />\n       : ''}\n       {(details.page || details.pages) && propsObj.resource.note ? ', ' : ''}\n       {propsObj.resource.note ?\n        <StructuredSpan htmlClass=\"peritext-citation-comment\" property=\"comment\" value={propsObj.resource.note} />\n       : ''}\n       {propsObj.resource.translation ?\n          <span className=\"peritext-citation-translation\">\n            . Traduction : <q>details.translation</q>\n          </span>\n          : ''\n        }\n       {propsObj.resource.translation ?\n          <span className=\"peritext-citation-original\">\n            . Citation originale : <q>details.original</q>\n          </span>\n          : ''\n        }\n    </span>\n  );\n};\n\n/**\n * Dumb component for rendering a iso690fr block citation\n */\n@Radium\nexport class BlockCitation extends BlockCitationModel {\n  /**\n   * constructor\n   * @param {object} props\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource to build the citation with\n   * @property {object} contextualization - the contextualization to build the citation with\n   */\n  static propTypes = {\n    contextualization: PropTypes.object,\n    resource: PropTypes.object\n  }\n  /**\n   * Renders additionnal citation information, such as pages mentions, translations, etc.\n   */\n  renderAdditionnal = renderAdditionnal;\n  /**\n   * Renders the representation of involved author (from resource), for long citations outputs\n   * @return {ReactElement} markup\n   */\n  renderAuthors() {\n    const pattern = '${lastName:capitals}, ${firstName}';\n    if (this.props.resource.author && this.props.resource.author.length <= 2) {\n\n      return (<span className=\"peritext-citation-authors\">\n          {this.props.resource.author.map((author, index) => {\n            return (\n                <span key={author.citeKey}>\n                  <StructuredPerson resource={author} pattern={pattern} property=\"author\" />\n                  {(index < this.props.resource.author.length - 1) ? ' et ' : ''}\n                </span>\n              );\n          })}\n      </span>);\n    } else if (this.props.resource.author) {\n      return (\n          <span className=\"peritext-citation-authors\">\n            <StructuredPerson resource={this.props.resource.author[0]} pattern={pattern} property=\"author\" />\n            <i className=\"peritext-citation-etal\">et al.</i>\n          </span>\n      );\n    }\n    return '';\n  }\n\n  /**\n   * Renders the complete reference of a resource\n   * @return {ReactElement} markup\n   */\n  renderCompleteReference() {\n    switch (this.props.resource.bibType) {\n    /* case book not set because is default for now\n    case 'book':\n    break;*/\n    case 'article':\n      if (this.props.opCit === true) {\n        return (\n          <span className=\"peritext-citation-detailed-reference-container\">\n            {this.renderAuthors()}, <i className=\"peritext-citation-opcit\">op.cit.</i>\n          </span>\n        );\n      }\n      const pages = (Array.isArray(this.props.resource.pages)) ? this.props.resource.pages : this.props.resource.pages.split('-');\n      return (\n        <span className=\"peritext-citation-detailed-reference-container\">\n          {this.renderAuthors()}\n          <span>. </span>\n          <StructuredCite value={this.props.resource.title} />\n          <span>. </span>\n          <StructuredParentJournal resource={this.props.resource} pattern=\"${journal}, ${date}, vol. ${volume}, n° ${issue}, ISSN : ${issn}\" />\n          {this.props.resource.pages ? ', pp. ' : ''}\n          {this.props.resource.pages ? <StructuredSpan htmlClass=\"peritext-citation-pages-in-publication\" property=\"pageStart\" value={pages[0]} /> : ''}\n          {this.props.resource.pages ? '-' : ''}\n          {this.props.resource.pages ? <StructuredSpan htmlClass=\"peritext-citation-pages-in-publication\" property=\"pageEnd\" value={pages[1]} /> : ''}\n        </span>\n      );\n    default:\n      if (this.props.opCit === true) {\n        return (\n          <span className=\"peritext-citation-detailed-reference-container\">\n            {this.renderAuthors()}, <i className=\"peritext-citation-opcit\">op.cit.</i>\n          </span>\n        );\n      }\n      return (\n        <span className=\"peritext-citation-detailed-reference-container\">\n          {this.renderAuthors()}\n          {this.props.resource.author ? <span>. </span> : ''}\n          <StructuredCite value={this.props.resource.title} />\n          {this.props.resource.edition ? '. ' : ''}\n          {this.props.resource.edition ? <StructuredSpan htmlClass=\"peritext-citation-publication-edition\" property=\"bookEdition\" value={this.props.resource.edition} /> : ''}\n          {this.props.resource.publisher ? '. ' : ''}\n          {this.props.resource.publisher ? <StructuredPublisher resource={this.props.resource} /> : ''}\n          {this.props.resource.year || this.props.resource.date ? ', ' : ''}\n          {this.props.resource.year || this.props.resource.date ? <StructuredSpan htmlClass=\"peritext-citation-publication-edition\" property=\"datePublished\" value={(this.props.resource.year || this.props.resource.date)} /> : ''}\n        </span>\n      );\n    }\n  }\n\n  /**\n   * Renders additionnal reference information (isbn, doi, url)\n   * @return {ReactElement} markup\n   */\n  renderReferenceDecoration() {\n    if (this.props.resource.isbn || this.props.resource.url || this.props.resource.doi) {\n      return (\n        <span className=\"peritext-citation-reference-decoration-container\">\n          {this.props.resource.isbn ? '. ISBN : ' : ''}\n          {this.props.resource.isbn ? <StructuredSpan htmlClass=\"peritext-citation-isbn\" property=\"isbn\" value={this.props.resource.isbn} /> : ''}\n          {this.props.resource.doi ? '. DOI : ' : ''}\n          {this.props.resource.doi ?\n            <a className=\"peritext-citation-doi\" target=\"blank\" itemProp=\"sameAs\" property=\"sameAs\" href={this.props.resource.doi}>\n              {this.props.resource.doi}\n            </a> : ''}\n          {this.props.resource.doi ? '. Accessible en ligne : ' : ''}\n          {this.props.resource.doi ?\n            <a className=\"peritext-citation-url\" target=\"blank\" itemProp=\"url\" property=\"url\" href={this.props.resource.url}>\n              {this.props.resource.url}\n            </a> : ''}\n        </span>\n      );\n    }\n  }\n\n  /**\n   * Renders final markup of the contextualization\n   * @return {ReactElement} markup\n   */\n  renderReference() {\n    return (\n      <span\n        className=\"peritext-citation-reference-container\"\n      >\n        {this.props.ibid === true ?\n          <i\n            className=\"peritext-citation-ibid\"\n          >\n            ibid.\n          </i> : ''}\n        {this.renderCompleteReference()}\n        {this.renderReferenceDecoration()}\n        <span>.</span>\n      </span>\n    );\n  }\n}\n\n\n/**\n * Dumb component for rendering a iso690fr inline citation\n */\n@Radium\nexport class InlineCitation extends InlineCitationModel {\n  /**\n   * constructor\n   * @param {object} props\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource to build the citation with\n   * @property {object} contextualization - the contextualization to build the citation with\n   */\n  static propTypes = {\n    contextualization: PropTypes.object,\n    resource: PropTypes.object\n  }\n\n  /**\n   * Renders additionnal citation information, such as pages mentions, translations, etc.\n   */\n  renderAdditionnal = renderAdditionnal;\n\n  /**\n   * Renders the representation of involved author (from resource), for short citations outputs\n   * @return {ReactElement} markup\n   */\n  renderAuthors() {\n    if (this.props.resource.author.length <= 2) {\n      return this.props.resource.author.map((author, index) => {\n        return (\n          <span key={author.citeKey} className=\"peritext-citation-authors\">\n            <StructuredPerson resource={author} pattern=\"${lastName:capitals}\" property=\"author\" />\n            {(index < this.props.resource.author.length - 1) ? ' et ' : ''}\n          </span>\n        );\n      });\n    }\n    return (\n        <span className=\"peritext-citation-authors\">\n          <StructuredPerson resource={this.props.resource.author[0]} pattern=\"${lastName:capitals}\" property=\"author\" />\n          <i className=\"peritext-citation-et-al\">et al.</i>\n        </span>\n    );\n  }\n\n  /**\n   * Renders final markup of the contextualization\n   * @return {ReactElement} markup\n   */\n  renderReference() {\n    if (this.props.ibid === true) {\n      return (\n        <span className=\"peritext-citation-brief-reference\">\n          <i\n            className=\"peritext-citation-ibid\"\n          >\n            ibid.\n          </i>\n        </span>\n      );\n    } else if (this.props.opCit === true) {\n      return (\n        <span className=\"peritext-citation-brief-reference\">\n          {this.renderAuthors()}\n          <span>, </span>\n          <i\n            className=\"peritext-citation-opcit\"\n          >\n            op.cit.\n          </i>\n        </span>\n      );\n    } else if (this.props.resource.date !== undefined || this.props.resource.year !== undefined) {\n      const value = this.props.resource.date || this.props.resource.year;\n      return (\n        <span className=\"peritext-citation-brief-reference\">\n          {this.renderAuthors()}\n          <span>, </span>\n          <StructuredDate value={value} modificator=\"year\" />\n          <span className=\"peritext-citation-year-suffix\">{this.props.contextualization.yearSuffix}</span>\n        </span>\n      );\n    }\n    return (\n      <span className=\"peritext-citation-brief-reference\">\n        {this.renderAuthors()}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 314,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "renderAdditionnal",
    "memberof": "src/referencers/iso690fr.js",
    "longname": "src/referencers/iso690fr.js~renderAdditionnal",
    "access": null,
    "export": false,
    "importPath": "peritext/src/referencers/iso690fr.js",
    "importStyle": null,
    "description": "Renders additionnal citation information, such as pages mentions, translations, etc.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "propsObj",
        "description": "the React element props"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "BlockCitation",
    "memberof": "src/referencers/iso690fr.js",
    "longname": "src/referencers/iso690fr.js~BlockCitation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/referencers/iso690fr.js",
    "importStyle": "{BlockCitation}",
    "description": "Dumb component for rendering a iso690fr block citation",
    "lineNumber": 72,
    "interface": false,
    "extends": [
      "src/core/utils/citationUtils/citationModels.js~BlockCitationModel"
    ]
  },
  {
    "__docId__": 316,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#constructor",
    "access": null,
    "description": "constructor",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "props",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 317,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderAuthors",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderAuthors",
    "access": null,
    "description": "Renders the representation of involved author (from resource), for long citations outputs",
    "lineNumber": 98,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 318,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderCompleteReference",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderCompleteReference",
    "access": null,
    "description": "Renders the complete reference of a resource",
    "lineNumber": 127,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 319,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderReferenceDecoration",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderReferenceDecoration",
    "access": null,
    "description": "Renders additionnal reference information (isbn, doi, url)",
    "lineNumber": 182,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 320,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderReference",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderReference",
    "access": null,
    "description": "Renders final markup of the contextualization",
    "lineNumber": 207,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 321,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "InlineCitation",
    "memberof": "src/referencers/iso690fr.js",
    "longname": "src/referencers/iso690fr.js~InlineCitation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/referencers/iso690fr.js",
    "importStyle": "{InlineCitation}",
    "description": "Dumb component for rendering a iso690fr inline citation",
    "lineNumber": 231,
    "interface": false,
    "extends": [
      "src/core/utils/citationUtils/citationModels.js~InlineCitationModel"
    ]
  },
  {
    "__docId__": 322,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/referencers/iso690fr.js~InlineCitation",
    "longname": "src/referencers/iso690fr.js~InlineCitation#constructor",
    "access": null,
    "description": "constructor",
    "lineNumber": 236,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "props",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 323,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderAuthors",
    "memberof": "src/referencers/iso690fr.js~InlineCitation",
    "longname": "src/referencers/iso690fr.js~InlineCitation#renderAuthors",
    "access": null,
    "description": "Renders the representation of involved author (from resource), for short citations outputs",
    "lineNumber": 259,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 324,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderReference",
    "memberof": "src/referencers/iso690fr.js~InlineCitation",
    "longname": "src/referencers/iso690fr.js~InlineCitation#renderReference",
    "access": null,
    "description": "Renders final markup of the contextualization",
    "lineNumber": 282,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 325,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/renderers/index.js",
    "memberof": null,
    "longname": "src/renderers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Renderers - pure functions that render peritext contents in a specific data format\n * @module renderers\n */\n\n export {default as renderToStaticHtml} from './renderToStaticHtml/index.js';\n"
  },
  {
    "__docId__": 326,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/renderers/renderToStaticHtml/index.js",
    "memberof": null,
    "longname": "src/renderers/renderToStaticHtml/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Render to static html\n * @module renderers/renderToStaticHtml\n */\n\nimport {waterfall} from 'async';\nimport {readFile} from 'fs';\nimport {resolve} from 'path';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport {IntlProvider} from 'react-intl';\n\nimport resolveDataDependencies from './../../core/resolvers/resolveDataDependencies';\nimport {getMetaValue} from './../../core/utils/sectionUtils';\nimport {resolveSettings} from './../../core/utils/modelUtils';\nimport {settingsModels} from './../../core/models';\nimport {resolveContextualizationsImplementation, resolveContextualizationsRelations} from './../../core/resolvers/resolveContextualizations';\nimport {composeRenderedSections} from './../sharedStaticUtils';\nimport {\n  StaticDocument,\n  StaticFootnote,\n  StaticNotePointer\n} from './../../core/components';\n\nconst defaultStylesPath = './../../config/defaultStyles/';\n\nconst listChildren = (sections, key)=> {\n  let output = [];\n  sections.forEach((thatSection) =>{\n    if (thatSection.parent === key) {\n      output = output.concat(thatSection);\n      const thatKey = getMetaValue(thatSection.metadata, 'general', 'citeKey');\n      output = output.concat(listChildren(sections, thatKey));\n    }\n  });\n  return output;\n};\n\nconst resolveNode = (node, section, settings) =>{\n  if (node.tag === 'note') {\n    const note = section.notes.find(thatNote =>{\n      return thatNote.id === node.target;\n    });\n    node.props = {note};\n    if (settings.notesPosition === 'footnotes') {\n      node.tag = StaticFootnote;\n    } else {\n      node.tag = StaticNotePointer;\n    }\n    node.special = true;\n  }\n  if (node.child) {\n    node.child = node.child.map(child =>{\n      return resolveNode(child, section, settings);\n    });\n  }\n  return node;\n};\n\nconst setSectionContents = (section, settings) =>{\n  return section.contents.map(node => {\n    return resolveNode(node, section, settings);\n  });\n};\n\n/**\n * Renders a section representation as a string representation of an html page\n * @param {Object} params - The params of the export\n * @param {Object} params.section - the (root) section to export\n * @param {array} params.sectionList - the section context (if necessary)\n * @param {Object} params.settings - the specific rendering settings to use in order to produce the output\n * @param {boolean} params.includeChildren - whether to include section's children sections\n * @param {string} params.destinationFolder - where to output the file\n * @params {Object} assetsController - the module to use in order to communicate with assets\n * @param {Object} assetsParams - the assets parameters to use while communicating with assetsController\n * @param {function(err:error, result:string)} rendererCallback - the possible errors encountered during rendering, and the resulting html data as a string\n */\nexport const renderSection = ({\n  section,\n  sectionList,\n  settings = {},\n  includeChildren = true\n}, assetsController, assetsParams, rendererCallback) =>{\n\n  // populate rendering params with defaults if needed\n  // todo : resolve in a separate file (modelUtils)\n  const finalSettings = resolveSettings(settings, getMetaValue(section.metadata, 'general', 'bibType'), settingsModels);\n\n  // always work with a list of sections, even if just one\n  let sectios = [section];\n  let style = '';\n  const motherKey = getMetaValue(section.metadata, 'general', 'citeKey');\n  // delimitate the sections to render - if includeChildren is enabled filter parented\n  if (includeChildren) {\n    sectios = sectios.concat(listChildren(sectionList, motherKey));\n  }\n  waterfall([\n    // load default css rules\n    (cback) =>{\n      readFile(resolve(__dirname + defaultStylesPath + 'global.css'), (err, contents)=> {\n        if (!err) {\n          style += contents;\n        }\n        cback(err, sectios);\n      });\n    // load default paged-related css rules\n    }, (sections, cback) =>{\n      readFile(resolve(__dirname + defaultStylesPath + 'page.css'), (err, contents)=> {\n        if (!err) {\n          style += contents;\n        }\n        cback(err, sections);\n      });\n    }, (inputSections, depCallback) =>{\n      resolveDataDependencies(inputSections, assetsController, assetsParams, true, depCallback);\n    // build html code\n    }, (inputSections, cback) =>{\n      let sections = inputSections.slice();\n      // build final css code (default + user-generated customizers)\n      const cssCustomizers = sections[0].customizers && sections[0].customizers.styles;\n      if (cssCustomizers !== undefined) {\n        for (const name in cssCustomizers) {\n          if (name !== 'screen.css') {\n            style += '\\n\\n' + cssCustomizers[name];\n          }\n        }\n      }\n       // prepare translations\n      const lang = getMetaValue(sections[0].metadata, 'general', 'language') || 'en';\n      const messages = require('./../../../translations/locales/' + lang + '.json');\n      // build metadata (todo : check if react-based helmet lib could cover \"rare\" metadata props like dublincore ones)\n      const metaHead = sections[0].metadata\n                    .filter((meta) =>{\n                      return meta.htmlHead;\n                    })\n                    .reduce((exp, meta) =>{\n                      return exp + meta.htmlHead;\n                    }, '') + '<meta name=\"generator\" content=\"peritext\"/>';\n      // order contextualizations (ibid/opCit, ...)\n      sections = resolveContextualizationsRelations(sections, finalSettings);\n      // resolve contextualizations js representation according to settings\n      let figuresCount = 0;\n      sections = sections.map((sectio, index) =>{\n        sectio.figuresCount = figuresCount;\n        const newSection = resolveContextualizationsImplementation(sectio, 'static', finalSettings);\n        figuresCount = newSection.figuresCount;\n        return newSection;\n      });\n      // transform input js abstraction of contents to a js abstraction specific to rendering settings\n      sections = sections.map(section1 => {\n        const contents = setSectionContents(section1, finalSettings);\n        return Object.assign(section1, contents, {type: 'contents'});\n      });\n      const {renderedSections, finalStyle} = composeRenderedSections(sections, finalSettings, style, messages);\n      // render document\n      const renderedContents = ReactDOMServer.renderToStaticMarkup(\n        <IntlProvider locale={lang} messages={messages}>\n          <StaticDocument sections={renderedSections} rootSection={sections[0]} settings={finalSettings} />\n        </IntlProvider>);\n      const html = `\n<!doctype:html>\n<html>\n  <head>\n    ${metaHead}\n    <style>\n      ${finalStyle}\n    </style>\n  </head>\n  <body>\n    ${renderedContents}\n   </body>\n</html>`.replace(/itemscope=\"\"/g, 'itemscope');\n      cback(null, html);\n    }\n  ], rendererCallback);\n};\n"
  },
  {
    "__docId__": 327,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultStylesPath",
    "memberof": "src/renderers/renderToStaticHtml/index.js",
    "longname": "src/renderers/renderToStaticHtml/index.js~defaultStylesPath",
    "access": null,
    "export": false,
    "importPath": "peritext/src/renderers/renderToStaticHtml/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "listChildren",
    "memberof": "src/renderers/renderToStaticHtml/index.js",
    "longname": "src/renderers/renderToStaticHtml/index.js~listChildren",
    "access": null,
    "export": false,
    "importPath": "peritext/src/renderers/renderToStaticHtml/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveNode",
    "memberof": "src/renderers/renderToStaticHtml/index.js",
    "longname": "src/renderers/renderToStaticHtml/index.js~resolveNode",
    "access": null,
    "export": false,
    "importPath": "peritext/src/renderers/renderToStaticHtml/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "setSectionContents",
    "memberof": "src/renderers/renderToStaticHtml/index.js",
    "longname": "src/renderers/renderToStaticHtml/index.js~setSectionContents",
    "access": null,
    "export": false,
    "importPath": "peritext/src/renderers/renderToStaticHtml/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "renderSection",
    "memberof": "src/renderers/renderToStaticHtml/index.js",
    "longname": "src/renderers/renderToStaticHtml/index.js~renderSection",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderToStaticHtml/index.js",
    "importStyle": "{renderSection}",
    "description": "Renders a section representation as a string representation of an html page",
    "lineNumber": 78,
    "unknown": [
      {
        "tagName": "@params",
        "tagValue": "{Object} assetsController - the module to use in order to communicate with assets"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "The params of the export"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.section",
        "description": "the (root) section to export"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.sectionList",
        "description": "the section context (if necessary)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.settings",
        "description": "the specific rendering settings to use in order to produce the output"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "params.includeChildren",
        "description": "whether to include section's children sections"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "params.destinationFolder",
        "description": "where to output the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsParams",
        "description": "the assets parameters to use while communicating with assetsController"
      },
      {
        "nullable": null,
        "types": [
          "function(err:error, result:string)"
        ],
        "spread": false,
        "optional": false,
        "name": "rendererCallback",
        "description": "the possible errors encountered during rendering, and the resulting html data as a string"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/renderers/sharedStaticUtils/index.js",
    "memberof": null,
    "longname": "src/renderers/sharedStaticUtils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Shared static rendering utils\n * @module renderers/sharedStaticUtils\n */\n\nimport {computeReferences} from './../../core/utils/referenceUtils';\nimport {getMetaValue} from './../../core/utils/sectionUtils';\n\n/**\n * Resolves a sections' list against rendering settings by modifying contents, adding output-related pseudo-sections, and updating css styles\n * @param {array} sections - the sections to render\n * @param {Object} settings - the specific rendering settings to use in order to produce the output\n * @param {string} inputStyle - the css style data to use\n * @param {array} messages - the intl messages to use for some sections localization (e.g. : translation of \"Table of contents\")\n * @return {Object} results - an object composed of an array of rendered sections and a string with the updated css styles\n */\nexport const composeRenderedSections = (sections = [], settings = {}, inputStyle = '', messages = []) =>{\n  const renderedSections = sections.slice();\n  let style = typeof inputStyle === 'string' ? inputStyle : '';\n  // transform regarding notes display settings\n  if (settings.notesPosition === 'footnotes') {\n    style += `.peritext-static-note-content-container\n            {\n                display: prince-footnote;\n                counter-increment: footnote;\n            }`;\n  } else if (settings.notesPosition === 'document-end') {\n    let noteNumber = 0;\n    const contents = sections.reduce((notes, section2) =>{\n      return notes.concat(section2.notes.map(note =>{\n        return Object.assign(note, {noteNumber: ++noteNumber});\n      }));\n    }, []);\n    if (contents.length) {\n      renderedSections.push({\n        type: 'endnotes',\n        contents,\n        title: messages.end_notes,\n        id: 'peritext-end-notes'\n      });\n    }\n  }\n\n  // handle figures\n  if (settings.figuresPosition === 'document-end') {\n    const figures = sections.reduce((figs, section3)=>{\n      if (section3.figures) {\n        return figs.concat(section3.figures);\n      }\n      return figs;\n    }, []);\n    if (figures.length) {\n      renderedSections.push({\n        type: 'endfigures',\n        contents: figures,\n        title: messages.end_figures,\n        id: 'peritext-end-figures'\n      });\n    }\n  }\n\n  // build references/bibliography\n  if (settings.referenceScope === 'document') {\n    const refs = computeReferences(sections, settings);\n    if (refs.length) {\n      renderedSections.push({\n        type: 'references',\n        contents: refs,\n        title: messages.references_title,\n        id: 'peritext-end-references'\n      });\n    }\n  }\n  // handle glossary\n  if (settings.glossaryPosition !== 'none') {\n    // prepare glossary\n    const glossaryPointers = sections.reduce((results, thatSection)=>{\n      const sectionCitekey = getMetaValue(thatSection.metadata, 'general', 'citeKey');\n      return results.concat(\n        thatSection.contextualizations\n        .filter((thatContextualization)=> {\n          return thatContextualization.contextualizer.type === 'glossary';\n        })\n        .reduce((localResults, contextualization)=> {\n          return localResults.concat({\n            mentionId: '#peritext-content-entity-inline-' + sectionCitekey + '-' + contextualization.citeKey,\n            entity: contextualization.resources[0].citeKey,\n            alias: contextualization.contextualizer.alias\n          });\n        }, []));\n    }, []);\n\n    const entitiesTypes = ['person', 'place', 'subject', 'concept', 'organization', 'technology', 'artefact'];\n\n    const glossaryData = sections.reduce((results, thatSection)=>{\n      return results.concat(\n        thatSection.resources\n        .filter((thatResource)=> {\n          return thatResource.inheritedVerticallyFrom === undefined\n                  && entitiesTypes.indexOf(thatResource.bibType) > -1;\n        })\n      );\n    }, []).map((glossaryEntry)=> {\n      glossaryEntry.aliases = glossaryPointers.filter((pointer)=> {\n        return pointer.entity === glossaryEntry.citeKey;\n      }).reduce((aliases, entry)=> {\n        const alias = entry.alias || 'no-alias';\n        aliases[alias] = aliases[alias] ? aliases[alias].concat(entry) : [entry];\n        return aliases;\n      }, {});\n      return glossaryEntry;\n    }).sort((entry1, entry2)=> {\n      return (entry1.name || entry1.lastname) > (entry2.name || entry2.lastname) ? 1 : -1;\n    });\n\n    const glossary = {\n      type: 'glossary',\n      contents: glossaryData,\n      title: messages.glossary,\n      id: 'peritext-end-glossary'\n    };\n    if (settings.glossaryPosition === 'begining' && glossary.contents.length) {\n      renderedSections.splice(0, 0, glossary);\n    } else if (glossary.contents.length) {\n      renderedSections.push(glossary);\n    }\n  }\n\n  // handle table of figures\n  if (settings.figuresTablePosition !== 'none') {\n    // making figures table data\n    const figuresTableData = sections.reduce((figures, section4)=> {\n      // 1. take numbered figures\n      const figuresL = section4.contextualizations.filter((cont)=> {\n        return cont.figureNumber !== undefined;\n      })\n      // 2. filter uniques\n      .filter((figure, index, self) => self.findIndex((other) => {\n        return other.figureNumber === figure.figureNumber;\n      }) === index)\n      // 3. make table array\n      .map((cont)=> {\n        return {\n          id: 'peritext-figure-' + cont.figureId,\n          number: cont.figureNumber\n        };\n      });\n      return figures.concat(figuresL);\n    }, []);\n    const figuresTable = {\n      type: 'table-of-figures',\n      contents: figuresTableData,\n      title: messages.table_of_figures,\n      id: 'peritext-end-table-of-figures'\n    };\n    if (settings.figuresTablePosition === 'begining' && figuresTable.contents.length) {\n      renderedSections.splice(0, 0, figuresTable);\n    } else if (figuresTable.contents.length) {\n      renderedSections.push(figuresTable);\n    }\n  }\n\n  // handle toc\n  if (settings.contentsTablePosition !== 'none') {\n    const tocData = renderedSections.filter((sectio, index) =>{\n      return index > 0;\n    }).map((thisSection) => {\n      return {\n        id: thisSection.metadata ? getMetaValue(thisSection.metadata, 'general', 'citeKey') : thisSection.id,\n        title: thisSection.metadata ? getMetaValue(thisSection.metadata, 'general', 'title') : thisSection.title,\n        level: thisSection.metadata ? getMetaValue(thisSection.metadata, 'general', 'generalityLevel') : 0\n      };\n    });\n    const toc = {type: 'table-of-contents', contents: tocData};\n    if (settings.contentsTablePosition === 'begining' && toc.contents.length) {\n      renderedSections.splice(0, 0, toc);\n    } else if (toc.contents.length) {\n      renderedSections.push(toc);\n    }\n  }\n  // handle cover\n  if (settings.showCovers === 'yes') {\n    renderedSections.splice(0, 0, {\n      type: 'front-cover',\n      metadata: sections[0].metadata\n    });\n    renderedSections.push({\n      type: 'back-cover',\n      metadata: sections[0].metadata\n    });\n  }\n  return {\n    renderedSections,\n    finalStyle: style\n  };\n};\n"
  },
  {
    "__docId__": 333,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "composeRenderedSections",
    "memberof": "src/renderers/sharedStaticUtils/index.js",
    "longname": "src/renderers/sharedStaticUtils/index.js~composeRenderedSections",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/sharedStaticUtils/index.js",
    "importStyle": "{composeRenderedSections}",
    "description": "Resolves a sections' list against rendering settings by modifying contents, adding output-related pseudo-sections, and updating css styles",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "sections",
        "description": "the sections to render"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use in order to produce the output"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputStyle",
        "description": "the css style data to use"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "messages",
        "description": "the intl messages to use for some sections localization (e.g. : translation of \"Table of contents\")"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "results - an object composed of an array of rendered sections and a string with the updated css styles"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 336,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 337,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 338,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 339,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 340,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 341,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 342,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 343,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 344,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 345,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 346,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 347,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 348,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 349,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 350,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 351,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 352,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 353,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 354,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 355,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 356,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 357,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 358,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 359,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 360,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 361,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 362,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 363,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 364,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 365,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 366,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 367,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 368,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 369,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 370,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 371,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 372,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 373,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 374,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 375,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 376,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 377,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 378,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 379,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 380,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 381,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 383,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 384,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 385,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 386,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 387,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 388,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 389,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 390,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "builtinExternal": true
  }
]