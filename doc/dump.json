[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/config/defaultParameters/index.js",
    "memberof": null,
    "longname": "src/config/defaultParameters/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "export default require('./defaultParameters.json');\n"
  },
  {
    "__docId__": 1,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/connectors/filesystem/index.js",
    "memberof": null,
    "longname": "src/connectors/filesystem/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Filesystem connector\n * @module connectors/filesystem\n */\n\nimport fs, {\n  readFile,\n  readdir,\n  lstatSync,\n  exists,\n  writeFile,\n  unlink\n} from 'fs';\nimport {\n  resolve,\n  extname,\n  basename,\n  join as joinPath\n} from 'path';\nimport {\n  map as asyncMap\n} from 'async';\nimport mkdirp from 'mkdirp';\n// import removeFolderRecursively from 'rmdir';\n\nconst removeFolderRecursively = function(path) {\n  if ( fs.existsSync(path) ) {\n    fs.readdirSync(path).forEach(function(file, index) {\n      const curPath = path + '/' + file;\n      if (fs.lstatSync(curPath).isDirectory()) { // recurse\n        removeFolderRecursively(curPath);\n      } else {\n        // delete file\n        fs.unlinkSync(curPath);\n      }\n    });\n    fs.rmdirSync(path);\n  }\n};\n\n// I get meta information about an fs element\nconst analyseElement = (fileName, absPath) =>{\n  const path = joinPath(absPath, fileName);\n  return {\n    name: fileName,\n    path,\n    type: (lstatSync(path).isDirectory()) ? 'directory' : 'file',\n    extname: extname(path)\n  };\n};\n\n// I get meta information about several fs elements\nconst analyseContents = (filesList, absPath) =>{\n  if (!filesList) {\n    return undefined;\n  }\n  return filesList.map((fileName) => {\n    return analyseElement(fileName, absPath);\n  });\n};\n\n\n// I recursively parse an fs element\nconst parseElement = ({path = '', element, parseFiles, depth, actualDepth, acceptedExtensions}, callback) =>{\n  // file to parse\n  if (element.type === 'file' && parseFiles === true && acceptedExtensions.indexOf(element.extname) > -1) {\n    try {\n      readFile(path, 'utf8', function(err, str) {\n        if (err) {\n          return callback(err, undefined);\n        }\n        return callback(null, Object.assign({}, element, {stringContents: str}));\n      });\n    } catch (exception) {\n      callback(null, element);\n    }\n  // dir to parse\n  } else if (element.type === 'directory' && (actualDepth < depth || depth === true)) {\n    readdir(element.path + '/', function(err, files) {\n      const children = analyseContents(files, path)\n                      .filter((child)=>{\n                        return child.type === 'directory' || acceptedExtensions.indexOf(child.extname) > -1;\n                      });\n      const newDepth = actualDepth + 1;\n      asyncMap(children, function(elem, colback) {\n        parseElement({element: elem, path: path + '/' + elem.name, parseFiles, depth, actualDepth: newDepth, acceptedExtensions}, colback);\n      }, function(error, otherChildren) {\n        return callback(error, Object.assign({}, element, {children: otherChildren}));\n      });\n    });\n  // default return element as it was input\n  } else {\n    return callback(null, Object.assign({}, element));\n  }\n};\n\n/**\n * Reads a file from a certain path (cRud)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {number} requestParams.depth - if the target is a \"folder\" that contains other \"subfolders\", specifies the parsing level\n * @param {boolean} requestParams.parseFiles - Whether to parse files if the target is a \"folder\"\n * @param {Array|string} obj.acceptedExtensions - The list of accepted files extensions (or \"*\") if all must be accepted\n * @param {function(error: error)} callback - returns error and a filesystem representation of the file metadata and contents\n */\nexport const readFromPath = ({\n    path = [],\n    params,\n    depth = 1,\n    parseFiles = false,\n    acceptedExtensions = ['.md', '.bib', '.css', '.js']\n  }, callback) =>{\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  let element;\n  const name = basename(finalPath);\n\n  try {\n    element = {\n      name: name,\n      path: finalPath,\n      type: (lstatSync(finalPath).isDirectory()) ? 'directory' : 'file',\n      extname: extname(name)\n    };\n  }catch (err) {\n    return callback(err, undefined);\n  }\n\n  if (element.type === 'directory') {\n    return parseElement({path: finalPath, element, parseFiles, depth, actualDepth: 0, acceptedExtensions}, callback);\n  } else if (acceptedExtensions === '*' || acceptedExtensions.indexOf(element.extname) > -1) {\n    readFile(finalPath, 'utf8', (err, str) => {\n      if (err) {\n        return callback(err, undefined);\n      }\n      return callback(null, Object.assign({}, element, {stringContents: str}));\n    });\n  } else {\n    return callback(new Error('the file extension is not accepted'), undefined);\n  }\n};\n\n/**\n * Creates a file from a certain path and possibly some contents (Crud)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {string} requestParams.stringContents - the contents to be created\n * @param {boolean} requestParams.overwrite - Whether to overwrite existing entity already present at path\n * @param {function(error: error, returnedPath: string)} callback - returns error and the path of created entity\n */\nexport const createFromPath = ({path = '', params, type = 'file', stringContents = '', overwrite = false}, callback) =>{\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  const pathSteps = finalPath.split('/').filter((thatPath)=> {return thatPath.length > 0;});\n  // first check-or-create path folders\n  let folderPath = type === 'file' ? pathSteps.slice(0, pathSteps.length - 1) : pathSteps.slice();\n  folderPath = '/' + folderPath.join('/');\n  if (type === 'file') {\n    return exists(finalPath, (isThere)=> {\n      // either file is not there or we don't care overwriting\n      if (overwrite || !isThere) {\n        writeFile(finalPath, stringContents, 'utf8');\n        return callback(null);\n      // file is there and overwrite set to false\n      }\n      return callback(new Error('File/directory already exists and overwrite option is set to false'));\n    });\n  }\n  return exists(folderPath, (isThere)=> {\n    if (isThere) {\n      return callback(null);\n    }\n    return mkdirp(folderPath, (err)=>{\n      return callback(err);\n    });\n  });\n};\n\n/**\n * Updates a file from a certain path and possibly some contents (crUd)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {string} requestParams.stringContents - the contents to be created\n * @param {function(error: error)} callback - returns possible error\n */\nexport const updateFromPath = ({path = '', params, stringContents = ''}, callback) => {\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath + '/' + resolvedPath);\n  exists(finalPath, (isThere) =>{\n    if (isThere) {\n      const pathSteps = finalPath.split('/').filter((thatPath)=> {return thatPath.length > 0;});\n      const elementName = pathSteps.pop();\n      const element = analyseElement(elementName, '/' + pathSteps.join('/'));\n      if (element.type === 'directory') {\n        callback(new Error('cannot update directories'));\n      } else if (element.type === 'file') {\n        writeFile(finalPath, stringContents, (err) =>{\n          callback(err);\n        });\n      }\n    }else {\n      callback(new Error('Path does not exists'));\n    }\n  });\n};\n\n/**\n * Deletes a file from a certain path and possibly some contents (cruD)\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {function(error: error)} callback - returns potential errors\n */\nexport const deleteFromPath = ({path = '', params}, callback) => {\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  exists(finalPath, function(isThere) {\n    if (isThere) {\n      const pathSteps = finalPath.split('/').filter((thatPath) => {return thatPath.length > 0;});\n      const elementName = pathSteps.pop();\n      const element = analyseElement(elementName, '/' + pathSteps.join('/'));\n      if (element.type === 'directory') {\n        removeFolderRecursively(finalPath /*\n        , (err) =>{\n          callback(err);\n        }\n        */);\n        callback(null);\n      }else if (element.type === 'file') {\n        unlink(finalPath, (err) =>{\n          callback(err);\n        });\n      }\n    }else {\n      callback(new Error('Path does not exists'));\n    }\n  });\n};\n\n/**\n * Gets the absolute uri of an asset\n * @param {Object} requestParams - The object containing request parameters\n * @param {array|string} requestParams.path - The detailed path (as a succession of \"folders\" or as a plain string) to attain the file\n * @param {Object} requestParams.params - The connection parameters\n * @param {string} requestParams.params.basePath - The path base to use in order to fetch files\n * @param {function(error: error, finalPath: string)} callback - returns error and the asset's uri\n * @todo question : should it check for resource availability ?\n */\nexport const getAssetUri = ({path, params}, callback) => {\n  const resolvedPath = (Array.isArray(path)) ? path.join('/') : path;\n  const finalPath = resolve(params.basePath) + '/' + resolvedPath;\n  return callback(null, finalPath);\n};\n"
  },
  {
    "__docId__": 2,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "removeFolderRecursively",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~removeFolderRecursively",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 3,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "analyseElement",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~analyseElement",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "analyseContents",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~analyseContents",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseElement",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~parseElement",
    "access": null,
    "export": false,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "readFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~readFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{readFromPath}",
    "description": "Reads a file from a certain path (cRud)",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.depth",
        "description": "if the target is a \"folder\" that contains other \"subfolders\", specifies the parsing level"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.parseFiles",
        "description": "Whether to parse files if the target is a \"folder\""
      },
      {
        "nullable": null,
        "types": [
          "Array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.acceptedExtensions",
        "description": "The list of accepted files extensions (or \"*\") if all must be accepted"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns error and a filesystem representation of the file metadata and contents"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~createFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{createFromPath}",
    "description": "Creates a file from a certain path and possibly some contents (Crud)",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.stringContents",
        "description": "the contents to be created"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.overwrite",
        "description": "Whether to overwrite existing entity already present at path"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, returnedPath: string)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns error and the path of created entity"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~updateFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{updateFromPath}",
    "description": "Updates a file from a certain path and possibly some contents (crUd)",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.stringContents",
        "description": "the contents to be created"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns possible error"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 9,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "deleteFromPath",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~deleteFromPath",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{deleteFromPath}",
    "description": "Deletes a file from a certain path and possibly some contents (cruD)",
    "lineNumber": 221,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns potential errors"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getAssetUri",
    "memberof": "src/connectors/filesystem/index.js",
    "longname": "src/connectors/filesystem/index.js~getAssetUri",
    "access": null,
    "export": true,
    "importPath": "peritext/src/connectors/filesystem/index.js",
    "importStyle": "{getAssetUri}",
    "description": "Gets the absolute uri of an asset",
    "lineNumber": 256,
    "todo": [
      "question : should it check for resource availability ?"
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams",
        "description": "The object containing request parameters"
      },
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.path",
        "description": "The detailed path (as a succession of \"folders\" or as a plain string) to attain the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params",
        "description": "The connection parameters"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestParams.params.basePath",
        "description": "The path base to use in order to fetch files"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, finalPath: string)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "returns error and the asset's uri"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/citation/index.js",
    "memberof": null,
    "longname": "src/contextualizers/citation/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Citation contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/citation\n */\n\nimport { get as getByPath } from 'object-path';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputDocument, inputContextualization, settings) => {\n  const formatter = require('./../../referencers/' + settings.citationStyle + '.js');\n  const document = Object.assign({}, inputDocument);\n  const contextualization = Object.assign({}, inputContextualization);\n  const path = ['sections', ...contextualization.nodePath.slice()];\n  const node = getByPath(document, path);\n\n  const props = {\n    contextualization,\n    resource: document.resources[contextualization.resources[0]],\n    ibid: contextualization.sectionIbid,\n    opCit: contextualization.sectionOpCit\n  };\n  // citation text --> wrap in span > q + citation\n  if (node.children) {\n    const citation = {\n      node: 'element',\n      special: true,\n      tag: formatter.InlineCitation,\n      props\n    };\n    const children = node.children.slice();\n    const quote = {\n      attr: {\n        class: 'peritext-quote-container',\n        id: contextualization.id\n      },\n      node: 'element',\n      tag: 'q',\n      children\n    };\n    node.node = 'element';\n    node.tag = 'span';\n    node.children = [\n      quote,\n      {\n        node: 'text',\n        text: ' ('\n      },\n      citation,\n      {\n        node: 'text',\n        text: ')'\n      }\n    ];\n  } else {\n    node.special = true;\n    node.node = 'element';\n    node.tag = formatter.InlineCitation;\n    node.props = props;\n  }\n  return document;\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputDocument, inputContextualization, settings) => {\n  const formatter = require('./../../referencers/' + settings.citationStyle + '.js');\n  const document = Object.assign({}, inputDocument);\n  const contextualization = Object.assign({}, inputContextualization);\n  const path = ['sections', ...contextualization.nodePath.slice()];\n  const node = getByPath(document, path);\n\n  const props = {\n    contextualization,\n    resource: contextualization.resources[0],\n    ibid: contextualization.sectionIbid,\n    opCit: contextualization.sectionOpCit\n  };\n  node.special = true;\n  node.tag = formatter.BlockCitation;\n  node.props = props;\n\n  return document;\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = contextualizeInlineStatic;\n/*\n(inputDocument, contextualization, settings) => {\n  return inputDocument;\n}\n*/\n\n/**\n * Handle an block contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = contextualizeBlockStatic;\n/*\n(inputDocument, contextualization, settings) => {\n  return inputDocument;\n};\n*/\n"
  },
  {
    "__docId__": 12,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 13,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 15,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/citation/index.js",
    "longname": "src/contextualizers/citation/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/citation/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle an block contextualization for dynamic outputs",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 16,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/glossary/StaticEntityBlock.js",
    "memberof": null,
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {bibToSchema} from './../../core/utils/microDataUtils';\n\n/**\n * dumb component and placeholder for rendering the structured representation of an entity long citation (in a glossary for example)\n */\nexport default class StaticEntityBlock extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} entity - the entity resource to contextualize\n   * @property {object} contextualizer - the contextualizer params to use for contextualization\n   * @property {object} contextualization - the contextualization object\n   * @property {object} settings - the set of settings to use for rendering\n   */\n  static propTypes = {\n    entity: PropTypes.object,\n    contextualizer: PropTypes.object,\n    contextualization: PropTypes.object,\n    settings: PropTypes.object\n  };\n\n  static defaultProps = {\n    contextualizer: {\n      showdescription: 'yes'\n    }\n  };\n\n  /**\n   * render a structured representation of the entities mentions, sorted by aliases\n   * @return {ReactElement} markup\n   */\n  renderMentions() {\n    const self = this;\n    return Object.keys(this.props.entity.aliases).map(function(alias, aliasIndex) {\n      return (<p key={alias} className=\"peritext-static-entity-block-page-mentions-container\">\n        <span>{alias === 'no-alias' ? '' : alias + ' : '}</span>\n        {self.props.entity.aliases[alias].map((entry, index)=> {\n          return (<span key={entry.mentionId}>\n              p. <a className=\"peritext-static-entity-block-page-pointer\" href={entry.mentionId}></a>\n            </span>);\n        }).reduce((accu, elem) => {\n          return accu === null ? [elem] : [...accu, ', ', elem];\n        }, null)}\n      </p>);\n    });\n  }\n\n  /**\n   * render component\n   * @return {ReactElement} markup\n   */\n  render() {\n    const itemType = bibToSchema(this.props.entity.bibType);\n    return (\n      <section\n        className=\"peritext-static-entity-block-container\"\n        name={'peritext-static-entity-block-' + this.props.entity.id}\n        id={'peritext-static-entity-block-' + this.props.entity.id}\n        itemProp=\"mentions\"\n        value=\"mentions\"\n        itemScope\n        itemType={'http://schema.org/' + itemType}\n        typeof={itemType}\n        resource={this.props.entity.id}\n      >\n        <h5\n          className=\"peritext-static-entity-block-name\">\n          {itemType === 'Person' ?\n            [<span\n              itemProp=\"familyName\"\n              property=\"familyName\"\n              key=\"familyName\"\n            >{this.props.entity.lastname}</span>,\n            <span key=\"separator1\"> (</span>,\n            <span\n              itemProp=\"givenName\"\n              property=\"givenName\"\n              key=\"givenName\"\n            >{this.props.entity.firstname}</span>,\n            <span key=\"separator2\">)</span>]\n            :\n            <span\n              property=\"name\"\n              itemProp=\"name\"\n            >{this.props.entity.name}</span>\n          }\n        </h5>\n\n        {this.props.entity.aliases ?\n            this.renderMentions()\n            : ''}\n\n        {this.props.entity.description && this.props.contextualizer.showdescription === 'yes' ?\n          <p className=\"peritext-static-entity-block-description\">\n            {this.props.entity.description}\n          </p>\n          : ''}\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 17,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEntityBlock",
    "memberof": "src/contextualizers/glossary/StaticEntityBlock.js",
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/StaticEntityBlock.js",
    "importStyle": "StaticEntityBlock",
    "description": "dumb component and placeholder for rendering the structured representation of an entity long citation (in a glossary for example)",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 18,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderMentions",
    "memberof": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock",
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock#renderMentions",
    "access": null,
    "description": "render a structured representation of the entities mentions, sorted by aliases",
    "lineNumber": 33,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 19,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock",
    "longname": "src/contextualizers/glossary/StaticEntityBlock.js~StaticEntityBlock#render",
    "access": null,
    "description": "render component",
    "lineNumber": 53,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 20,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/glossary/StaticEntityInline.js",
    "memberof": null,
    "longname": "src/contextualizers/glossary/StaticEntityInline.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\nimport {bibToSchema} from './../../core/utils/microDataUtils';\nimport renderContents from './../../core/utils/componentsFactory';\n\n/**\n * dumb component and placeholder for rendering the structured representation of an entity citation\n */\nexport default class StaticEntityInline extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} entity - the entity resource to contextualize\n   * @property {string} sectionId - the host section id (used for identifying the element)\n   * @property {object} contextualization - the contextualization object\n   * @property {array} contents - the pseudo-dom js representation of contextualization's pointer contents\n   */\n  static propTypes = {\n    entity: PropTypes.object,\n    sectionId: PropTypes.string,\n    contextualization: PropTypes.object,\n    contents: PropTypes.array\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const itemType = bibToSchema(this.props.entity.bibType);\n    return (\n      <a\n        className=\"peritext-static-entity-container-inline\"\n        name={'peritext-content-entity-inline-' + this.props.sectionId + '-' + this.props.contextualization.id}\n        id={'peritext-static-entity-inline-' + this.props.sectionId + '-' + this.props.contextualization.id}\n        href={'#peritext-static-entity-block-' + this.props.entity.id}\n        itemProp=\"mentions\"\n        value=\"mentions\"\n        itemScope\n        itemType={'http://schema.org/' + itemType}\n        typeof={itemType}\n        resource={this.props.entity.id}\n      >\n        {itemType === 'Person' ?\n          [<span\n            style={{display: 'none'}}\n            itemProp=\"givenName\"\n            property=\"givenName\"\n            key=\"givenName\"\n          >{this.props.entity.firstname}</span>,\n          <span\n            style={{display: 'none'}}\n            itemProp=\"familyName\"\n            property=\"familyName\"\n            key=\"familyName\"\n          >{this.props.entity.lastname}</span>]\n          :\n          <span\n            style={{display: 'none'}}\n            property=\"name\"\n            itemProp=\"name\"\n          >{this.props.entity.name}</span>\n        }\n        {<span>{renderContents(this.props.contents)}</span>}\n      </a>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 21,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEntityInline",
    "memberof": "src/contextualizers/glossary/StaticEntityInline.js",
    "longname": "src/contextualizers/glossary/StaticEntityInline.js~StaticEntityInline",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/StaticEntityInline.js",
    "importStyle": "StaticEntityInline",
    "description": "dumb component and placeholder for rendering the structured representation of an entity citation",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 22,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/glossary/StaticEntityInline.js~StaticEntityInline",
    "longname": "src/contextualizers/glossary/StaticEntityInline.js~StaticEntityInline#render",
    "access": null,
    "description": "render",
    "lineNumber": 32,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 23,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/glossary/index.js",
    "memberof": null,
    "longname": "src/contextualizers/glossary/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Glossary contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/glossary\n */\nimport { get as getByPath } from 'object-path';\n\nimport StaticEntityInline from './StaticEntityInline';\nimport StaticEntityBlock from './StaticEntityBlock';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputDocument, inputContextualization, settings) => {\n  const document = Object.assign({}, inputDocument);\n  const contextualization = Object.assign({}, inputContextualization);\n  const sectionId = contextualization.nodePath[0];\n  const path = ['sections', ...contextualization.nodePath.slice()];\n  const node = getByPath(document, path);\n  const entity = document.resources[contextualization.resources[0]];\n  let contents = node.children;\n  if (!contents || (contents[0] && contents[0].text.trim().length === 0)) {\n    contents = document.contextualizers[contextualization.contextualizer].alias\n              || entity.name\n              || entity.firstname + ' ' + entity.lastname;\n    contents = [{\n      node: 'text',\n      text: contents\n    }];\n  }\n  node.props = {\n    contextualization,\n    entity,\n    contents,\n    sectionId\n  };\n  node.special = true;\n  node.tag = StaticEntityInline;\n  return document;\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputDocument, inputContextualization, settings) => {\n  const document = Object.assign({}, inputDocument);\n  const contextualization = Object.assign({}, inputContextualization);\n  const path = ['sections', ...contextualization.nodePath.slice()];\n  const node = getByPath(document, path);\n  const entity = contextualization.resources[0];\n  node.props = {\n    entity,\n    contextualization,\n    settings\n  };\n  node.special = true;\n  node.tag = StaticEntityBlock;\n  return document;\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = contextualizeInlineStatic;\n// export const contextualizeInlineDynamic = (inputDocument, contextualization, settings) => {\n//   return inputDocument;\n// };\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = contextualizeBlockStatic;\n// export const contextualizeBlockDynamic = (inputDocument, contextualization, settings) => {\n//   return inputDocument;\n// };\n"
  },
  {
    "__docId__": 24,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 25,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 27,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/glossary/index.js",
    "longname": "src/contextualizers/glossary/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/glossary/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/imagegallery/StaticImageGallery.js",
    "memberof": null,
    "longname": "src/contextualizers/imagegallery/StaticImageGallery.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {StaticImageFigure} from './../../core/components';\n\nimport renderContents from './../../core/utils/componentsFactory';\n\n/**\n * dumb static-oriented component for displaying an image gallery\n */\nexport default class StaticImageGallery extends React.Component {\n  /**\n   * propTypes\n   * @property {string} schematype - html schema type of the element\n   * @property {array} resources - array of resources used\n   * @property {string} captionContent - what to display as caption\n   * @property {number} figureNumber - in static mode, the number of the figure\n   * @property {string} id - the id to use in order to label the figure\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resources: PropTypes.array,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'ImageGallery',\n    comment: ''\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n            <figure\n              role=\"group\"\n              className=\"peritext-static-image-gallery-container peritext-figure-container\"\n              itemScope\n              itemProp=\"citation\"\n              itemType={'http://schema.org/' + this.props.schematype}\n              typeof={this.props.schematype}\n              resource={this.props.figureNumber ? 'peritext-figure-' + this.props.figureNumber : undefined }\n              id={'peritext-figure-' + this.props.id}\n            >\n              <div className=\"peritext-static-image-gallery-figures-wrapper\">\n                {this.props.resources.map((resource)=>{\n                  return <StaticImageFigure resource={resource} key={resource.id} />;\n                })}\n              </div>\n              <figcaption\n                itemProp=\"description\"\n                property=\"description\">\n                  <span className=\"peritext-figure-marker\">\n                    Figure <span className=\"peritext-figure-number\">{this.props.figureNumber}</span>\n                  </span>\n                  <span> – </span>\n                  <span className=\"peritext-figure-caption-content\">\n                    {renderContents(this.props.captionContent)}\n                  </span>\n              </figcaption>\n            </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 29,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticImageGallery",
    "memberof": "src/contextualizers/imagegallery/StaticImageGallery.js",
    "longname": "src/contextualizers/imagegallery/StaticImageGallery.js~StaticImageGallery",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/StaticImageGallery.js",
    "importStyle": "StaticImageGallery",
    "description": "dumb static-oriented component for displaying an image gallery",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 30,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/imagegallery/StaticImageGallery.js~StaticImageGallery",
    "longname": "src/contextualizers/imagegallery/StaticImageGallery.js~StaticImageGallery#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 31,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/imagegallery/index.js",
    "memberof": null,
    "longname": "src/contextualizers/imagegallery/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Image gallery contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/imagegallery\n */\nimport { get as getByPath } from 'object-path';\n\nimport StaticImageGallery from './StaticImageGallery';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputDocument, inputContextualization, settings) => {\n\n  const document = Object.assign({}, inputDocument);\n  const contextualization = Object.assign({}, inputContextualization);\n  const sectionId = contextualization.nodePath[0];\n  const path = ['sections', ...contextualization.nodePath.slice()];\n  const node = getByPath(document, path);\n  const section = document.sections[sectionId];\n\n  const nodeBlockIndex = path[3];\n  let figureId;\n  let number;\n  const contents = node.children;\n  // if figure is not there yet, add it\n  if (!contextualization.sectionOpCit) {\n    figureId = sectionId + '-' + contextualization.id;\n    contextualization.figureId = figureId;\n    document.figuresCount = document.figuresCount ? document.figuresCount + 1 : 1;\n    contextualization.figureNumber = document.figuresCount;\n    contextualization.figureId = figureId;\n    const figure = {\n      node: 'element',\n      special: true,\n      tag: StaticImageGallery,\n      props: {\n        resources: contextualization.resources.map(key => document.resources[key]),\n        captionContent: [{\n          node: 'text',\n          text: contextualization.title || document.resources[contextualization.resources[0]].title\n        }],\n        figureNumber: contextualization.figureNumber,\n        id: figureId\n      }\n    };\n    number = contextualization.figureNumber;\n    if (settings.figuresPosition === 'inline') {\n      // insert contextualization block (could be refactored as an util)\n      section.contents = [\n        ...section.contents.slice(0, nodeBlockIndex),\n        figure,\n        ...section.contents.slice(nodeBlockIndex)\n      ];\n      const newNodePath = [sectionId, 'contents', nodeBlockIndex + 1];\n      document.contextualizations[contextualization.id].nodePath = newNodePath;\n      // update contextualizations that target subsequent contents blocks\n      Object\n      .keys(document.contextualizations)\n      .map(key => document.contextualizations[key])\n      .filter(cont =>\n        cont.nodePath.slice(0, 2).join() === newNodePath.slice(0, 2).join()\n        && cont.nodePath[2] > nodeBlockIndex\n      )\n      .forEach(cont => {\n        cont.nodePath[2]++;\n      });\n    } else {\n      section.figures = section.figures ? section.figures.concat(figure) : [figure];\n    }\n  } else {\n    figureId = sectionId + '-' + contextualization.precursorId;\n    number = document.contextualizations[contextualization.precursorId].figureNumber;\n  }\n  const displayId = '#peritext-figure-' + figureId;\n  const newContents = [\n    ...contents.slice(),\n    {\n      node: 'text',\n      text: ' ('\n    },\n    {\n      node: 'element',\n      tag: 'a',\n      attr: {\n        href: displayId\n      },\n      children: [\n        {\n          node: 'text',\n          text: 'figure ' + number\n        }\n      ]\n    },\n    {\n      node: 'text',\n      text: ') '\n    }\n  ];\n  node.tag = 'span';\n  node.children = newContents;\n  document.contextualizations[contextualization.id] = contextualization;\n  return document;\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputDocument, inputContextualization, settings) => {\n  const document = Object.assign({}, inputDocument);\n  const contextualization = Object.assign({}, inputContextualization);\n  const sectionId = contextualization.nodePath[0];\n  const path = ['sections', ...contextualization.nodePath.slice()];\n  const node = getByPath(document, path);\n  const section = document.sections[sectionId];\n\n  const nodeBlockIndex = path[3];\n\n  let figureId;\n  document.figuresCount = document.figuresCount ? document.figuresCount + 1 : 1;\n  figureId = sectionId + '-' + contextualization.id;\n  contextualization.figureId = figureId;\n  contextualization.figureNumber = document.figuresCount;\n  const figure = {\n    node: 'element',\n    special: true,\n    tag: StaticImageGallery,\n    props: {\n      resources: contextualization.resources.map(key => document.resources[key]),\n      captionContent: node.children[0].children,\n      figureNumber: contextualization.figureNumber,\n      id: figureId\n    }\n  };\n  if (settings.figuresPosition === 'inline') {\n    section.contents[nodeBlockIndex] = figure;\n  } else {\n    section.figures = section.figures ? section.figures.concat(figure) : [figure];\n  }\n  document.contextualizations[contextualization.id] = contextualization;\n  return document;\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (inputDocument, contextualization, settings) => {\n  return inputDocument;\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (inputDocument, contextualization, settings) => {\n  return inputDocument;\n};\n"
  },
  {
    "__docId__": 32,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 33,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 34,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 35,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/imagegallery/index.js",
    "longname": "src/contextualizers/imagegallery/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/imagegallery/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/index.js",
    "memberof": null,
    "longname": "src/contextualizers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Contextualizers - pure functions that resolve sections against contextualizations+settings objects\n * @module contextualizers\n */\nimport * as citationLib from './citation';\nimport * as timelineLib from './timeline';\nimport * as imagegalleryLib from './imagegallery';\nimport * as webpageLib from './webpage';\nimport * as glossaryLib from './glossary';\nimport * as tableLib from './table';\n\n/**\n * Citation contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const citation = citationLib;\n/**\n * Timeline contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const timeline = timelineLib;\n/**\n * Image gallery contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const imagegallery = imagegalleryLib;\n/**\n * Webpage contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const webpage = webpageLib;\n/**\n * Glossary contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const glossary = glossaryLib;\n/**\n * Table contextualizer that resolve sections data according to contextualization+settings params\n */\nexport const table = tableLib;\n"
  },
  {
    "__docId__": 37,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "citation",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~citation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{citation}",
    "description": "Citation contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 15,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "timeline",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~timeline",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{timeline}",
    "description": "Timeline contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 39,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "imagegallery",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~imagegallery",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{imagegallery}",
    "description": "Image gallery contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 40,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "webpage",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~webpage",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{webpage}",
    "description": "Webpage contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 27,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 41,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "glossary",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~glossary",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{glossary}",
    "description": "Glossary contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 31,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 42,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "table",
    "memberof": "src/contextualizers/index.js",
    "longname": "src/contextualizers/index.js~table",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/index.js",
    "importStyle": "{table}",
    "description": "Table contextualizer that resolve sections data according to contextualization+settings params",
    "lineNumber": 35,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 43,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/table/StaticTable.js",
    "memberof": null,
    "longname": "src/contextualizers/table/StaticTable.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport renderContents from './../../core/utils/componentsFactory';\n\n\n/**\n * dumb static-oriented component for displaying a table\n */\nexport default class StaticTable extends React.Component {\n  /**\n   * propTypes\n   * @property {string} schematype - html schema type of the element\n   * @property {array} resources - array of resources used\n   * @property {string} captionContent - what to display as caption\n   * @property {number} figureNumber - in static mode, the number of the figure\n   * @property {object} data - the resource data to use\n   * @property {string} id - the id to use for identifying the contextualization\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resources: PropTypes.array,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number,\n    data: PropTypes.object,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'Dataset',\n    comment: ''\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const headers = Object.keys(this.props.data.data[0]);\n    const objects = this.props.data.data;\n    return (\n            <figure\n              role=\"group\"\n              className=\"peritext-static-table-container peritext-figure-container\"\n              itemScope\n              itemProp=\"citation\"\n              itemType={'http://schema.org/' + this.props.schematype}\n              typeof={this.props.schematype}\n              resource={this.props.figureNumber ? 'peritext-figure-' + this.props.figureNumber : undefined }\n              id={'peritext-figure-' + this.props.id}\n            >\n              <table className=\"peritext-static-table-table\">\n                <thead>\n                  <tr>\n                    {headers.map((header, index)=>{\n                      return <th key={index}>{header}</th>;\n                    })}\n                  </tr>\n                </thead>\n                <tbody>\n                  {objects.map((object, oIndex)=>{\n                    return (<tr key={oIndex}>\n                      {headers.map((header, hIndex)=>{\n                        return <th key={hIndex}>{object[header]}</th>;\n                      })}\n                    </tr>);\n                  })}\n                </tbody>\n              </table>\n              <figcaption\n                itemProp=\"description\"\n                property=\"description\">\n                  <span className=\"peritext-figure-marker\">\n                    Figure <span className=\"peritext-figure-number\">{this.props.figureNumber}</span>\n                  </span>\n                  <span> – </span>\n                  <span className=\"peritext-figure-caption-content\">\n                    {renderContents(this.props.captionContent)}\n                  </span>\n              </figcaption>\n            </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 44,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTable",
    "memberof": "src/contextualizers/table/StaticTable.js",
    "longname": "src/contextualizers/table/StaticTable.js~StaticTable",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/StaticTable.js",
    "importStyle": "StaticTable",
    "description": "dumb static-oriented component for displaying a table",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 45,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/table/StaticTable.js~StaticTable",
    "longname": "src/contextualizers/table/StaticTable.js~StaticTable#render",
    "access": null,
    "description": "render",
    "lineNumber": 36,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 46,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/table/index.js",
    "memberof": null,
    "longname": "src/contextualizers/table/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Table contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/table\n */\nimport { get as getByPath } from 'object-path';\n\nimport StaticTable from './StaticTable';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputDocument, inputContextualization, settings) => {\n  const document = Object.assign({}, inputDocument);\n  const contextualization = Object.assign({}, inputContextualization);\n  const sectionId = contextualization.nodePath[0];\n  const path = ['sections', ...contextualization.nodePath.slice()];\n  const node = getByPath(document, path);\n  const section = document.sections[sectionId];\n  const data = document.data[contextualization.resources[0]];\n  const nodeBlockIndex = path[3];\n  let figureId;\n  let number;\n  const contents = node.children;\n  // if figure is not there yet, add it\n  if (!contextualization.sectionOpCit) {\n    figureId = sectionId + '-' + contextualization.id;\n    contextualization.figureId = figureId;\n    document.figuresCount = document.figuresCount ? document.figuresCount + 1 : 1;\n    contextualization.figureNumber = document.figuresCount;\n    contextualization.figureId = figureId;\n    const figure = {\n      node: 'element',\n      special: true,\n      tag: StaticTable,\n      props: {\n        resources: contextualization.resources.map(key => document.resources[key]),\n        data,\n        captionContent: [{\n          node: 'text',\n          text: contextualization.title || document.resources[contextualization.resources[0]].title\n        }],\n        figureNumber: contextualization.figureNumber,\n        id: figureId\n      }\n    };\n    number = contextualization.figureNumber;\n    if (settings.figuresPosition === 'inline') {\n      // insert block\n      section.contents = [\n        ...section.contents.slice(0, nodeBlockIndex),\n        figure,\n        ...section.contents.slice(nodeBlockIndex)\n      ];\n      const newNodePath = [sectionId, 'contents', nodeBlockIndex + 1];\n      document.contextualizations[contextualization.id].nodePath = newNodePath;\n      // update contextualizations that target subsequent contents blocks\n      Object\n      .keys(document.contextualizations)\n      .map(key => document.contextualizations[key])\n      .filter(cont =>\n        cont.nodePath.slice(0, 2).join() === newNodePath.slice(0, 2).join()\n        && cont.nodePath[2] > nodeBlockIndex\n      )\n      .forEach(cont => {\n        cont.nodePath[2]++;\n      });\n    } else {\n      section.figures = section.figures ? section.figures.concat(figure) : [figure];\n    }\n  } else {\n    figureId = sectionId + '-' + contextualization.precursorId;\n    number = document.contextualizations[contextualization.precursorId].figureNumber;\n  }\n  const displayId = '#peritext-figure-' + figureId;\n  const newContents = [\n    ...contents.slice(),\n    {\n      node: 'text',\n      text: ' ('\n    },\n    {\n      node: 'element',\n      tag: 'a',\n      attr: {\n        href: displayId\n      },\n      children: [\n        {\n          node: 'text',\n          text: 'figure ' + number\n        }\n      ]\n    },\n    {\n      node: 'text',\n      text: ') '\n    }\n  ];\n  node.tag = 'span';\n  node.children = newContents;\n  document.contextualizations[contextualization.id] = contextualization;\n  return document;\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputDocument, inputContextualization, settings) => {\n  return Object.assign({}, inputDocument);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (inputDocument, inputContextualization, settings) => {\n  return Object.assign({}, inputDocument);\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (inputDocument, inputContextualization, settings) => {\n  return Object.assign({}, inputDocument);\n};\n"
  },
  {
    "__docId__": 47,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 48,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/table/index.js",
    "longname": "src/contextualizers/table/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/table/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/timeline/index.js",
    "memberof": null,
    "longname": "src/contextualizers/timeline/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Timline contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/timeline\n */\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputSection - The representation of the peritext section to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineStatic = (inputDocument, contextualization, settings) => {\n  return Object.assign({}, inputDocument);\n};\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockStatic = (inputDocument, contextualization, settings) => {\n  return Object.assign({}, inputDocument);\n};\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeInlineDynamic = (inputDocument, contextualization, settings) => {\n  return Object.assign({}, inputDocument);\n};\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\nexport const contextualizeBlockDynamic = (inputDocument, contextualization, settings) => {\n  return Object.assign({}, inputDocument);\n};\n"
  },
  {
    "__docId__": 52,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputSection",
        "description": "The representation of the peritext section to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/timeline/index.js",
    "longname": "src/contextualizers/timeline/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/timeline/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/webpage/StaticWebsitePoster.js",
    "memberof": null,
    "longname": "src/contextualizers/webpage/StaticWebsitePoster.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {StaticImageFigure, StructuredHyperLink} from './../../core/components';\n\nimport renderContents from './../../core/utils/componentsFactory';\n\n/**\n * dumb static-oriented component for displaying a webpage poster image\n */\nexport default class StructuredWebsitePoster extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} schematype html schema type of the element\n   * @property {object} resource the resource to be parsed\n   * @property {array} captionContent what to display as caption\n   * @property {number} figureNumber in static mode, the number of the figure\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resource: PropTypes.object.isRequired,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'website',\n    captionContent: ''\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const invisibleStyle = {\n      display: 'none'\n    };\n    const contents = [\n      {\n        node: 'text',\n        text: this.props.resource.url\n      }\n    ];\n    return (\n            <figure\n              role=\"group\"\n              className=\"peritext-static-website-poster-container peritext-figure-container\"\n              itemScope\n              itemProp=\"citation\"\n              itemType={'http://schema.org/' + this.props.schematype}\n              typeof={this.props.schematype}\n              resource={'#' + this.props.resource.id}\n              id={'peritext-figure-' + this.props.id}\n            >\n              <span\n                itemProp=\"name\"\n                property=\"name\"\n                style={invisibleStyle}\n              >\n                {this.props.resource.title}\n              </span>\n              <StaticImageFigure {...this.props} />\n              <figcaption\n                itemProp=\"description\"\n                property=\"description\"\n              >\n                Figure {this.props.figureNumber} – {renderContents(this.props.captionContent)} – <StructuredHyperLink contents={contents} resource={this.props.resource}/>\n              </figcaption>\n            </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 57,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredWebsitePoster",
    "memberof": "src/contextualizers/webpage/StaticWebsitePoster.js",
    "longname": "src/contextualizers/webpage/StaticWebsitePoster.js~StructuredWebsitePoster",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/StaticWebsitePoster.js",
    "importStyle": "StructuredWebsitePoster",
    "description": "dumb static-oriented component for displaying a webpage poster image",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 58,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/contextualizers/webpage/StaticWebsitePoster.js~StructuredWebsitePoster",
    "longname": "src/contextualizers/webpage/StaticWebsitePoster.js~StructuredWebsitePoster#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 59,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/contextualizers/webpage/index.js",
    "memberof": null,
    "longname": "src/contextualizers/webpage/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Webpage contextualizer that resolve sections data according to contextualization+settings params\n * @module contextualizers/webpage\n */\n\n import { get as getByPath } from 'object-path';\n\n import {StructuredHyperLink} from './../../core/components';\n import StaticWebsitePoster from './StaticWebsitePoster.js';\n\n/**\n * Handle an inline contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\n export const contextualizeInlineStatic = (inputDocument, inputContextualization, settings) => {\n   const document = Object.assign({}, inputDocument);\n   const contextualization = Object.assign({}, inputContextualization);\n   const sectionId = contextualization.nodePath[0];\n   const path = ['sections', ...contextualization.nodePath.slice()];\n   const node = getByPath(document, path);\n   const section = document.sections[sectionId];\n\n   const link = {\n     node: 'element',\n     tag: StructuredHyperLink,\n     special: true,\n     props: {\n       resource: document.resources[contextualization.resources[0]],\n       contents: [{\n         node: 'text',\n         text: document.resources[contextualization.resources[0]].url\n       }]\n     }\n   };\n   const noteNumber = section.notes.length + 1;\n   const noteId = sectionId + '-' + noteNumber;\n   section.notes.push({\n     noteNumber,\n     children: [link],\n     id: noteId\n   });\n   node.children = [\n     ...node.children,\n     {\n       element: 'node',\n       tag: 'note',\n       target: noteId\n     }\n   ];\n\n   return document;\n };\n\n/**\n * Handle a block contextualization for static outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\n export const contextualizeBlockStatic = (inputDocument, inputContextualization, settings) => {\n   const document = Object.assign({}, inputDocument);\n   const contextualization = Object.assign({}, inputContextualization);\n   const sectionId = contextualization.nodePath[0];\n   const path = ['sections', ...contextualization.nodePath.slice()];\n   const node = getByPath(document, path);\n   const section = document.sections[sectionId];\n   let figureId;\n   figureId = sectionId + '-' + contextualization.id;\n   document.figuresCount = document.figuresCount ? document.figuresCount + 1 : 1;\n   contextualization.figureId = figureId;\n   contextualization.figureNumber = document.figuresCount;\n   const captionContent = node.children && node.children[0] && node.children[0].children || undefined;\n   const figure = {\n     node: 'element',\n     special: true,\n     tag: StaticWebsitePoster,\n     props: {\n       imageKey: 'posterurl',\n       resource: document.resources[contextualization.resources[0]],\n       captionContent,\n       figureNumber: contextualization.figureNumber,\n       id: figureId\n     }\n   };\n\n   if (settings.figuresPosition === 'inline') {\n     const nodeBlockIndex = path[3];\n     section.contents[nodeBlockIndex] = figure;\n   } else {\n     section.figures = section.figures ? section.figures.concat(figure) : [figure];\n   }\n   document.contextualizations[contextualization.id] = contextualization;\n   return document;\n };\n\n/**\n * Handle an inline contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext document in which the contextualization was made\n */\n export const contextualizeInlineDynamic = (inputDocument, contextualization, settings) => {\n   return inputDocument;\n };\n\n/**\n * Handle a block contextualization for dynamic outputs\n * @param {Object} inputDocument - The representation of the peritext document to update\n * @param {Object} inputContextualization - The representation of the contextualization to resolve\n * @param {Object} settings - the specific rendering settings to use for resolving the contextualization\n * @return {Object} newDocument - the updated representation of the peritext section in which the contextualization was made\n */\n export const contextualizeBlockDynamic = (inputDocument, contextualization, settings) => {\n   return inputDocument;\n };\n"
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineStatic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeInlineStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeInlineStatic}",
    "description": "Handle an inline contextualization for static outputs",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockStatic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeBlockStatic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeBlockStatic}",
    "description": "Handle a block contextualization for static outputs",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeInlineDynamic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeInlineDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeInlineDynamic}",
    "description": "Handle an inline contextualization for dynamic outputs",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext document in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizeBlockDynamic",
    "memberof": "src/contextualizers/webpage/index.js",
    "longname": "src/contextualizers/webpage/index.js~contextualizeBlockDynamic",
    "access": null,
    "export": true,
    "importPath": "peritext/src/contextualizers/webpage/index.js",
    "importStyle": "{contextualizeBlockDynamic}",
    "description": "Handle a block contextualization for dynamic outputs",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputDocument",
        "description": "The representation of the peritext document to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "inputContextualization",
        "description": "The representation of the contextualization to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use for resolving the contextualization"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated representation of the peritext section in which the contextualization was made"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticBackCover.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticBackCover.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\nimport {\n  StructuredPerson\n} from '../index';\n\n/**\n * dumb component for back cover page of a static publication of document\n */\nexport default class StaticBackCover extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} metadata - a section metadata to parse in order to fill cover template\n   */\n  static propTypes = {\n    metadata: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <section\n        id=\"peritext-static-back-cover\"\n        className=\"peritext-static-back-cover-container\"\n      >\n        <h2>{(this.props.metadata.general.title && this.props.metadata.general.title.value)}</h2>\n        <h3 className=\"peritext-static-authors\">\n          {(this.props.metadata.general.author.value).map((person) =>{\n            return <StructuredPerson key={person.id} resource={person}/>;\n          })}\n        </h3>\n        <p>\n          {(this.props.metadata.general.abstract && this.props.metadata.general.abstract.value)}\n        </p>\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 65,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticBackCover",
    "memberof": "src/core/components/StaticComponents/StaticBackCover.js",
    "longname": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticBackCover.js",
    "importStyle": "StaticBackCover",
    "description": "dumb component for back cover page of a static publication of document",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 66,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover",
    "longname": "src/core/components/StaticComponents/StaticBackCover.js~StaticBackCover#render",
    "access": null,
    "description": "render",
    "lineNumber": 27,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 67,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticDocument.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticDocument.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport { intlShape } from 'react-intl';\nimport {bibToSchema} from '../../utils/microDataUtils';\nimport {\n  StaticBackCover,\n  StaticEndNotes,\n  StaticEndFigures,\n  StaticFrontCover,\n  StaticForewords,\n  StaticGlossary,\n  StaticReferencesList,\n  StaticSection,\n  StaticTableOfContents,\n  StaticTableOfFigures,\n  StructuredMetadataPlaceholder\n} from '../index';\n\n\n/**\n * dumb component for rendering the structured representation of a static document\n */\nclass StaticDocument extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} document - the reference to the whole document\n   * @property {array} sections - the list of rendering sections to include - warning -> can include cover, table of contents, ... sections\n   * @property {Object} settings - the rendering settings to use\n   */\n  static propTypes = {\n    document: PropTypes.object,\n    sections: PropTypes.array,\n    settings: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const bibType = bibToSchema(this.props.document.metadata.general.bibType.value);\n    const id = this.props.document.metadata.general.id.value;\n    return (\n        <section\n          itemScope\n          itemType={'http://schema.org/' + bibType}\n          typeof={bibType}\n          vocab=\"http://schema.org/\"\n          resource={'#' + id}\n        >\n          {<StructuredMetadataPlaceholder section={this.props.document} />}\n\n          {this.props.sections.map((section, index)=> {\n            switch (section.type) {\n\n            case 'table-of-contents':\n              return (section.contents.length) ? <StaticTableOfContents id={section.id} key={index} contents={section.contents} /> : '';\n\n            case 'table-of-figures':\n              return (section.contents.length) ? <StaticTableOfFigures id={section.id} key={index} contents={section.contents} /> : '';\n\n            case 'front-cover':\n              return <StaticFrontCover key={index} metadata={section.metadata} />;\n\n            case 'back-cover':\n              return <StaticBackCover key={index} metadata={section.metadata} />;\n\n            case 'endnotes':\n              return (section.contents.length) ? <StaticEndNotes id={section.id} key={index} notes={section.contents} classSuffix=\"document-end\" /> : '';\n\n            case 'endfigures':\n              return (section.contents.length) ? <StaticEndFigures id={section.id} key={index} contents={section.contents} classSuffix=\"document-end\" /> : '';\n\n            case 'references':\n              return (section.contents.length) ? <StaticReferencesList id={section.id} key={index} references={section.contents} settings={this.props.settings} /> : '';\n\n            case 'glossary':\n              return (section.contents.length) ? <StaticGlossary id={section.id} key={index} elements={section.contents} /> : '';\n\n            case 'contents':\n              return <StaticSection key={index} section={section} settings={this.props.settings} />;\n\n            case 'forewords':\n              return <StaticForewords key={index} section={section} settings={this.props.settings} />;\n\n            default:\n              break;\n            }\n          })}\n        </section>\n    );\n  }\n}\n\nStaticDocument.contextTypes = { intl: intlShape };\nexport default StaticDocument;\n"
  },
  {
    "__docId__": 68,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticDocument",
    "memberof": "src/core/components/StaticComponents/StaticDocument.js",
    "longname": "src/core/components/StaticComponents/StaticDocument.js~StaticDocument",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticDocument.js",
    "importStyle": "StaticDocument",
    "description": "dumb component for rendering the structured representation of a static document",
    "lineNumber": 22,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 69,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticDocument.js~StaticDocument",
    "longname": "src/core/components/StaticComponents/StaticDocument.js~StaticDocument#render",
    "access": null,
    "description": "render",
    "lineNumber": 43,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 70,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticEndFigures.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport { intlShape, defineMessages } from 'react-intl';\n\nimport renderContents from '../../utils/componentsFactory';\n\nconst translate = defineMessages({\n  endfigures: {\n    id: 'end_figures',\n    description: 'Title of the end figures',\n    defaultMessage: 'Figures',\n  }\n});\n\n/**\n * dumb component for rendering the structured representation of a static section\n */\nclass StaticEndFigures extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    classSuffix: PropTypes.string,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        className={'peritext-static-end-figures-container peritext-static-end-figures-' + this.props.classSuffix + '-container'}\n        id={this.props.id}\n      >\n        {this.props.contents.length > 0 ? <h4 className=\"peritext-static-end-figures-title\">\n         { formatMessage(translate.endfigures, {}) }\n        </h4> : ''}\n\n        <div className=\"peritext-static-end-figures-figures-container\">\n          {renderContents(this.props.contents)}\n        </div>\n      </section>\n    );\n  }\n}\n\nStaticEndFigures.contextTypes = { intl: intlShape };\n\nexport default StaticEndFigures;\n"
  },
  {
    "__docId__": 71,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticEndFigures.js",
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndFigures.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEndFigures",
    "memberof": "src/core/components/StaticComponents/StaticEndFigures.js",
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js~StaticEndFigures",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndFigures.js",
    "importStyle": "StaticEndFigures",
    "description": "dumb component for rendering the structured representation of a static section",
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 73,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticEndFigures.js~StaticEndFigures",
    "longname": "src/core/components/StaticComponents/StaticEndFigures.js~StaticEndFigures#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 74,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticEndNotes.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {StaticNoteContent} from '../index';\nimport { intlShape, defineMessages } from 'react-intl';\n\n\nconst translate = defineMessages({\n  endnotes: {\n    id: 'end_notes',\n    description: 'Title of the endnotes',\n    defaultMessage: 'Notes',\n  }\n});\n\n/**\n * dumb component for rendering the structured representation of a static section\n */\nclass StaticEndNotes extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    notes: PropTypes.array,\n    classSuffix: PropTypes.string,\n    id: PropTypes.id\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        className={'peritext-static-end-notes-container peritext-static-end-notes-' + this.props.classSuffix + '-container'}\n        id={this.props.id}\n      >\n        {this.props.notes.length > 0 ? <h4 className=\"peritext-static-end-notes-title\">\n         { formatMessage(translate.endnotes, {}) }\n        </h4> : ''}\n\n        <div className=\"peritext-static-end-notes-notes-container\">\n          {this.props.notes.map((note, noteIndex)=> {\n            return <StaticNoteContent key={noteIndex} note={note} />;\n          })}\n        </div>\n      </section>\n    );\n  }\n}\n\nStaticEndNotes.contextTypes = { intl: intlShape };\n\nexport default StaticEndNotes;\n"
  },
  {
    "__docId__": 75,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticEndNotes.js",
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndNotes.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticEndNotes",
    "memberof": "src/core/components/StaticComponents/StaticEndNotes.js",
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js~StaticEndNotes",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticEndNotes.js",
    "importStyle": "StaticEndNotes",
    "description": "dumb component for rendering the structured representation of a static section",
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 77,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticEndNotes.js~StaticEndNotes",
    "longname": "src/core/components/StaticComponents/StaticEndNotes.js~StaticEndNotes#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 78,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticFootnote.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticFootnote.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport renderContents from '../../utils/componentsFactory';\n\n/**\n * dumb component for containing either a static or dynamic note, acting whether as a pointer or as a container\n */\nexport default class StaticFootnote extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} note - the note object to use in order to render the footnote\n   */\n  static propTypes = {\n    note: PropTypes.object,\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <sup\n        className=\"peritext-static-note-content-container\"\n        name={'peritext-static-note-content-' + this.props.note.id }\n        id={'peritext-static-note-content-' + this.props.note.id}\n      >\n        {renderContents(this.props.note.children)}\n      </sup>);\n  }\n}\n"
  },
  {
    "__docId__": 79,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticFootnote",
    "memberof": "src/core/components/StaticComponents/StaticFootnote.js",
    "longname": "src/core/components/StaticComponents/StaticFootnote.js~StaticFootnote",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticFootnote.js",
    "importStyle": "StaticFootnote",
    "description": "dumb component for containing either a static or dynamic note, acting whether as a pointer or as a container",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 80,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticFootnote.js~StaticFootnote",
    "longname": "src/core/components/StaticComponents/StaticFootnote.js~StaticFootnote#render",
    "access": null,
    "description": "render",
    "lineNumber": 24,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 81,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticForewords.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticForewords.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\nimport {bibToSchema} from '../../utils/microDataUtils';\n\nimport {\n  StructuredMetadataPlaceholder,\n  StaticEndNotes,\n  StaticEndFigures\n} from '../index';\n\nimport renderContents from '../../utils/componentsFactory';\n\n/**\n * dumb component for rendering the structured representation of a static section\n */\nexport default class StaticForewords extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} section - the section to render\n   * @property {Object} settings - the settings to use for section rendering\n   */\n  static propTypes = {\n    section: PropTypes.object,\n    settings: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const bibType = bibToSchema(this.props.section.metadata.general.bibType.value);\n    const id = this.props.section.metadata.general.id.value;\n    return (\n      <section\n        className={'peritext-static-section-container peritext-static-forewords-container'}\n        id={id}\n        itemScope\n        itemType={'http://schema.org/' + bibType}\n        typeof={bibType}\n        resource={'#' + id}\n        itemProp=\"hasPart\"\n        property=\"hasPart\"\n      >\n        <StructuredMetadataPlaceholder section={this.props.section} />\n        {renderContents(this.props.section.contents)}\n        {this.props.settings.figuresPosition === 'section-end' && this.props.section.figures ?\n          <StaticEndFigures\n            contents={this.props.section.figures}\n            classSuffix=\"section-end\"\n          /> : ''}\n        {this.props.settings.notesPosition === 'section-end' && this.props.section.notes.length ?\n          <StaticEndNotes\n            classSuffix=\"section-end\"\n            notes={this.props.section.notes}\n          /> : ''}\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 82,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticForewords",
    "memberof": "src/core/components/StaticComponents/StaticForewords.js",
    "longname": "src/core/components/StaticComponents/StaticForewords.js~StaticForewords",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticForewords.js",
    "importStyle": "StaticForewords",
    "description": "dumb component for rendering the structured representation of a static section",
    "lineNumber": 16,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 83,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticForewords.js~StaticForewords",
    "longname": "src/core/components/StaticComponents/StaticForewords.js~StaticForewords#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 84,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticFrontCover.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticFrontCover.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport StructuredPerson from '../StructuredDataComponents/StructuredPerson';\n\n/**\n * dumb component for cover page of a static publication of document\n */\nexport default class StaticFrontCover extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} metadata a section metadata to parse in order to fill cover template\n   */\n  static propTypes = {\n    metadata: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const bibType = this.props.metadata.general.bibType.value;\n    if (bibType !== 'phdthesis') {\n      return (\n        <section\n        id=\"peritext-static-front-cover\"\n        className=\"peritext-static-front-cover-container\"\n        >\n          <h1>{this.props.metadata.general.title && this.props.metadata.general.title.value}</h1>\n          <h2 className=\"peritext-static-authors\">\n            {this.props.metadata.general.author.value.map((person) =>{\n              return <StructuredPerson key={person.id} resource={person}/>;\n            })}\n          </h2>\n        </section>\n        );\n    }\n    return (\n      <section\n        id=\"peritext-static-front-cover\"\n        className=\"peritext-static-front-cover-container\"\n      >\n        <div\n          style={{backgroundImage: 'url(' + (this.props.metadata.general.coverimage && this.props.metadata.general.coverimage.value) + ')'}}\n          id=\"peritext-static-front-cover-image-container\"\n        ></div>\n        <div\n          className=\"peritext-static-front-cover-texts-container\"\n        >\n          <section className=\"peritext-static-front-cover-part-top-left\">\n            <h3 className=\"peritext-static-front-cover-dissertationinstitution\">\n              Thèse / {(this.props.metadata.general.dissertationinstitution && this.props.metadata.general.dissertationinstitution.value)}\n            </h3>\n            <p>\n              Pour obtenir le grade de DOCTEUR\n            </p>\n            <h4 className=\"peritext-static-front-cover-dissertationcomment\">\n              {(this.props.metadata.general.dissertationcomment && this.props.metadata.general.dissertationcomment.value)}\n            </h4>\n\n            <p className=\"peritext-static-front-cover-dissertationdoctoralschool\">\n              École doctorale {(this.props.metadata.general.dissertationdoctoralschool && this.props.metadata.general.dissertationdoctoralschool.value)}\n            </p>\n\n            <p className=\"peritext-static-front-cover-dissertationdiscipline\">\n              Mention : <span>{(this.props.metadata.general.dissertationdiscipline && this.props.metadata.general.dissertationdiscipline.value)}</span>\n            </p>\n          </section>\n\n          <section className=\"peritext-static-front-cover-part-top-right\">\n            <p>\n              présentée par\n            </p>\n            <h1 className=\"peritext-static-authors\">\n              {this.props.metadata.general.author.value.map((person) =>{\n                return <StructuredPerson key={person.id} resource={person}/>;\n              })}\n            </h1>\n            <p className=\"peritext-static-front-cover-dissertationlab\">\n              {(this.props.metadata.general.dissertationlab && this.props.metadata.general.dissertationlab.value)}\n            </p>\n          </section>\n\n          <section className=\"peritext-static-front-cover-part-bottom-left\">\n            <h1>\n              {(this.props.metadata.general.title && this.props.metadata.general.title.value)}\n            </h1>\n          </section>\n\n          <section className=\"peritext-static-front-cover-part-bottom-right\">\n            <p className=\"peritext-static-front-cover-date\">\n              Thèse soutenue le {(this.props.metadata.general.date && this.props.metadata.general.date.value)}\n            </p>\n            <p>\n              devant le jury composé de :\n            </p>\n            {\n              (this.props.metadata.general.dissertationjury.value).map((person) =>{\n                return (\n                    <p key={person.id} className=\"peritext-static-front-cover-jury-member\">\n                      <StructuredPerson resource={person} pattern=\"${firstName} ${lastName:capitals} ${information} / ${role}\"/>\n                    </p>\n                  );\n              })\n            }\n          </section>\n        </div>\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 85,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticFrontCover",
    "memberof": "src/core/components/StaticComponents/StaticFrontCover.js",
    "longname": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticFrontCover.js",
    "importStyle": "StaticFrontCover",
    "description": "dumb component for cover page of a static publication of document",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 86,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover",
    "longname": "src/core/components/StaticComponents/StaticFrontCover.js~StaticFrontCover#render",
    "access": null,
    "description": "render",
    "lineNumber": 24,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 87,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticGlossary.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticGlossary.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport { intlShape, defineMessages } from 'react-intl';\nimport StaticEntityBlock from '../../../contextualizers/glossary/StaticEntityBlock';\n\nconst translate = defineMessages({\n  glossary: {\n    id: 'glossary',\n    description: 'Title of glossary section',\n    defaultMessage: 'Glossary',\n  }\n});\n\n/**\n * dumb component for rendering a static table of contents\n */\nclass StaticGlossary extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    elements: PropTypes.array,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    elements: []\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        id={this.props.id}\n        className=\"peritext-static-glossary-container\"\n      >\n        <h2>{ formatMessage(translate.glossary, {}) }</h2>\n        <section\n          className=\"peritext-static-glossary-elements-container\"\n        >\n          {\n            this.props.elements.map((entity, index) => (\n              <StaticEntityBlock key={index} entity={entity} />\n            ))\n          }\n        </section>\n      </section>\n    );\n  }\n}\nStaticGlossary.contextTypes = { intl: intlShape };\n\nexport default StaticGlossary;\n"
  },
  {
    "__docId__": 88,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticGlossary.js",
    "longname": "src/core/components/StaticComponents/StaticGlossary.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticGlossary.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticGlossary",
    "memberof": "src/core/components/StaticComponents/StaticGlossary.js",
    "longname": "src/core/components/StaticComponents/StaticGlossary.js~StaticGlossary",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticGlossary.js",
    "importStyle": "StaticGlossary",
    "description": "dumb component for rendering a static table of contents",
    "lineNumber": 16,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 90,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticGlossary.js~StaticGlossary",
    "longname": "src/core/components/StaticComponents/StaticGlossary.js~StaticGlossary#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 91,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticImageFigure.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticImageFigure.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\n/**\n * dumb component for displaying a simple structured image figure\n */\nexport default class StaticImageFigure extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} schematype - html schema type of the element\n   * @property {object} resource - the resource to be parsed\n   * @property {string} imageKey - the resource prop to use for finding the image url\n   * @property {string} captionContent - what to display as caption\n   * @property {number} figureNumber - in static mode, the number of the figure\n   */\n  static propTypes = {\n    schematype: PropTypes.string,\n    resource: PropTypes.object,\n    imageKey: PropTypes.string,\n    captionContent: PropTypes.array,\n    figureNumber: PropTypes.number\n  };\n\n  static defaultProps = {\n    schematype: 'ImageObject',\n    captionContent: [],\n    imageKey: 'imageurl'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n              <figure\n                className=\"peritext-static-image-figure-container\"\n                itemProp=\"image\"\n                value=\"image\"\n                itemScope\n                itemType=\"http://schema.org/ImageObject\"\n                typeof=\"ImageObject\"\n              >\n                <a\n                  href={this.props.resource[this.props.imageKey]}\n                  itemProp=\"url\"\n                  property=\"url\"\n                  value={this.props.resource[this.props.imageKey]}\n                >\n                </a>\n                <img\n                  itemProp=\"contentUrl\"\n                  value=\"contentUrl\"\n                  src={this.props.resource[this.props.imageKey]}\n                  alt={this.props.resource.title}\n                />\n              </figure>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 92,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticImageFigure",
    "memberof": "src/core/components/StaticComponents/StaticImageFigure.js",
    "longname": "src/core/components/StaticComponents/StaticImageFigure.js~StaticImageFigure",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticImageFigure.js",
    "importStyle": "StaticImageFigure",
    "description": "dumb component for displaying a simple structured image figure",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 93,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticImageFigure.js~StaticImageFigure",
    "longname": "src/core/components/StaticComponents/StaticImageFigure.js~StaticImageFigure#render",
    "access": null,
    "description": "render",
    "lineNumber": 34,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 94,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticNoteContent.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticNoteContent.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\nimport renderContents from '../../utils/componentsFactory';\n\n\n/**\n * dumb component for rendering the structured representation of a static note\n */\nexport default class StaticNote extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} note - the note object to use in order to render the note content\n   */\n  static propTypes = {\n    note: PropTypes.object,\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        style={{display: 'block'}}\n        className=\"peritext-static-note-content-container\"\n        name={'peritext-static-note-content-' + this.props.note.id}\n        id={'peritext-static-note-content-' + this.props.note.id}\n      >\n        <a\n          href={'#peritext-static-note-pointer-' + this.props.note.id}\n          className=\"peritext-static-note-content-number\"\n        >\n          {this.props.note.noteNumber}\n        </a>\n        {renderContents(this.props.note.children)}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 95,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticNote",
    "memberof": "src/core/components/StaticComponents/StaticNoteContent.js",
    "longname": "src/core/components/StaticComponents/StaticNoteContent.js~StaticNote",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticNoteContent.js",
    "importStyle": "StaticNote",
    "description": "dumb component for rendering the structured representation of a static note",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 96,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticNoteContent.js~StaticNote",
    "longname": "src/core/components/StaticComponents/StaticNoteContent.js~StaticNote#render",
    "access": null,
    "description": "render",
    "lineNumber": 26,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 97,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticNotePointer.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticNotePointer.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\n/**\n * dumb component for rendering the structured representation of a static note pointer\n */\nexport default class StaticNotePointer extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} note - the note object to use in order to render the note pointer\n   */\n  static propTypes = {\n    note: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <sup\n        className=\"peritext-static-note-pointer-container\"\n        name={'peritext-static-note-pointer-' + this.props.note.id}\n        id={'peritext-static-note-pointer-' + this.props.note.id}\n      >\n        <a\n          href={'#peritext-static-note-content-' + this.props.note.id}\n          className=\"peritext-static-note-pointer-number\"\n        >\n          {this.props.note.noteNumber}\n        </a>\n      </sup>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 98,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticNotePointer",
    "memberof": "src/core/components/StaticComponents/StaticNotePointer.js",
    "longname": "src/core/components/StaticComponents/StaticNotePointer.js~StaticNotePointer",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticNotePointer.js",
    "importStyle": "StaticNotePointer",
    "description": "dumb component for rendering the structured representation of a static note pointer",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 99,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticNotePointer.js~StaticNotePointer",
    "longname": "src/core/components/StaticComponents/StaticNotePointer.js~StaticNotePointer#render",
    "access": null,
    "description": "render",
    "lineNumber": 23,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 100,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticReferencesList.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport { intlShape, defineMessages } from 'react-intl';\n\n// let styles = {};\n\nconst translate = defineMessages({\n  referencestitle: {\n    id: 'references_title',\n    description: 'Title of references/bibliography section',\n    defaultMessage: 'References'\n  }\n});\n\n/**\n * dumb component for rendering a static table of figures\n */\nclass StaticReferencesList extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    references: PropTypes.array,\n    settings: PropTypes.object,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    references: []\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const citationRenderer = require('./../../../referencers/' + this.props.settings.citationStyle + '.js');\n    const BlockCitation = citationRenderer.BlockCitation;\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        className=\"peritext-static-references-list-container\"\n        id={this.props.id}\n      >\n        <h2>{ formatMessage(translate.referencestitle, {}) }</h2>\n        <section className=\"peritext-static-references-list-items-container\">\n          {this.props.references.map((reference)=> {\n            return <BlockCitation key={reference.id} resource={reference} contextualization={{}} />;\n          })}\n        </section>\n      </section>\n    );\n  }\n}\n\nStaticReferencesList.contextTypes = { intl: intlShape };\n\nexport default StaticReferencesList;\n"
  },
  {
    "__docId__": 101,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticReferencesList.js",
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticReferencesList.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticReferencesList",
    "memberof": "src/core/components/StaticComponents/StaticReferencesList.js",
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js~StaticReferencesList",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticReferencesList.js",
    "importStyle": "StaticReferencesList",
    "description": "dumb component for rendering a static table of figures",
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 103,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticReferencesList.js~StaticReferencesList",
    "longname": "src/core/components/StaticComponents/StaticReferencesList.js~StaticReferencesList#render",
    "access": null,
    "description": "render",
    "lineNumber": 37,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 104,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticSection.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticSection.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\nimport {bibToSchema} from '../../utils/microDataUtils';\n\nimport {\n  StructuredMetadataPlaceholder,\n  StaticEndNotes,\n  StaticEndFigures\n} from './../index';\n\nimport renderContents from './../../utils/componentsFactory';\n\n/**\n * dumb component for rendering the structured representation of a static section\n */\nexport default class StaticSection extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} section - the section to render\n   * @property {Object} settings - the settings to use for section rendering\n   */\n  static propTypes = {\n    section: PropTypes.object,\n    settings: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const bibType = bibToSchema(this.props.section.metadata.general.bibType.value);\n    const id = this.props.section.metadata.general.id.value;\n    const title = this.props.section.metadata.general.title.value;\n    const generalityLevel = this.props.section.metadata.general.generalityLevel.value;\n    return (\n      <section\n        className={'peritext-static-section-container peritext-static-section-level-' + generalityLevel}\n        id={id}\n        itemScope\n        itemType={'http://schema.org/' + bibType}\n        typeof={bibType}\n        resource={'#' + id}\n        itemProp=\"hasPart\"\n        property=\"hasPart\"\n        title={title}\n      >\n        <StructuredMetadataPlaceholder section={this.props.section} />\n        {renderContents(this.props.section.contents)}\n        {this.props.settings.figuresPosition === 'section-end' && this.props.section.figures ?\n          <StaticEndFigures\n            contents={this.props.section.figures}\n            classSuffix=\"section-end\"\n          /> : ''}\n        {this.props.settings.notesPosition === 'section-end' && this.props.section.notes.length ?\n          <StaticEndNotes\n            classSuffix=\"section-end\"\n            notes={this.props.section.notes}\n          /> : ''}\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 105,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticSection",
    "memberof": "src/core/components/StaticComponents/StaticSection.js",
    "longname": "src/core/components/StaticComponents/StaticSection.js~StaticSection",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticSection.js",
    "importStyle": "StaticSection",
    "description": "dumb component for rendering the structured representation of a static section",
    "lineNumber": 16,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 106,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticSection.js~StaticSection",
    "longname": "src/core/components/StaticComponents/StaticSection.js~StaticSection#render",
    "access": null,
    "description": "render",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 107,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport { intlShape, defineMessages } from 'react-intl';\n\nconst translate = defineMessages({\n  tableofcontents: {\n    id: 'table_of_contents',\n    description: 'Table of contents title',\n    defaultMessage: 'Table of contents',\n  }\n});\n\n/**\n * dumb component for rendering a static table of contents\n */\nclass StaticTableOfContents extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    level: PropTypes.number,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    title: 'Table of contents',\n    level: 1\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        id={this.props.id}\n        className=\"peritext-static-table-of-contents-container\"\n      >\n        <h2>{ formatMessage(translate.tableofcontents, {}) }</h2>\n        <section className=\"peritext-static-table-of-contents-elements-container\">\n          {this.props.contents.map((element) =>{\n            return <StaticTableOfContentsElement id={element.id} key={element.id} title={element.title} level={element.level} levelDisplacement={this.props.level}/>;\n          })}\n        </section>\n      </section>\n    );\n  }\n}\n\nStaticTableOfContents.contextTypes = { intl: intlShape };\n\nexport default StaticTableOfContents;\n\nclass StaticTableOfContentsElement extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    title: PropTypes.string,\n    level: PropTypes.number,\n    id: PropTypes.string,\n    paddingDisplacement: PropTypes.number,\n    levelDisplacement: PropTypes.number\n  };\n\n  static defaultProps = {\n    level: 0,\n    paddingDisplacement: 0.5,\n    levelDisplacement: 0\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <section\n        className=\"peritext-static-table-of-contents-element-container\"\n        style={{paddingLeft: (this.props.level - this.props.levelDisplacement - 1) * this.props.paddingDisplacement + 'cm'}}\n      >\n        <a\n          href={'#' + this.props.id}\n        >\n          {this.props.title}\n        </a>\n      </section>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfContents.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTableOfContentsElement",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContentsElement",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfContents.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 110,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContentsElement",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContentsElement#render",
    "access": null,
    "description": "render",
    "lineNumber": 81,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 111,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTableOfContents",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfContents.js",
    "importStyle": "StaticTableOfContents",
    "description": "dumb component for rendering a static table of contents",
    "lineNumber": 15,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 112,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContents",
    "longname": "src/core/components/StaticComponents/StaticTableOfContents.js~StaticTableOfContents#render",
    "access": null,
    "description": "render",
    "lineNumber": 36,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 113,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "memberof": null,
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport { intlShape, defineMessages } from 'react-intl';\n\nconst translate = defineMessages({\n  tableoffigures: {\n    id: 'table_of_figures',\n    description: 'Table of figures title',\n    defaultMessage: 'Table of figures',\n  },\n  figurename: {\n    id: 'figure',\n    description: 'Name of a figure',\n    defaultMessage: 'Figure',\n  }\n});\n\n\n/**\n * dumb component for rendering a static table of figures\n */\nclass StaticTableOfFigures extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    id: PropTypes.string\n  };\n\n  static defaultProps = {\n    contents: []\n  };\n\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const { formatMessage } = this.context.intl;\n    return (\n      <section\n        id={this.props.id}\n        className=\"peritext-static-table-of-figures-container\"\n      >\n        <h2>{ formatMessage(translate.tableoffigures, {}) }</h2>\n        <section className=\"peritext-static-table-of-figures-elements-container\">\n          {this.props.contents.map((element, index) =>{\n            return (<section\n                      className=\"peritext-static-table-of-figures-element\"\n                      key={element.id + index}>\n                      <a\n                        href={'#' + element.id}\n                      >\n                        { formatMessage(translate.figurename, {}) } {element.number}\n                      </a>\n                    </section>);\n          })}\n        </section>\n      </section>\n    );\n  }\n}\n\nStaticTableOfFigures.contextTypes = { intl: intlShape };\n\nexport default StaticTableOfFigures;\n"
  },
  {
    "__docId__": 114,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfFigures.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StaticTableOfFigures",
    "memberof": "src/core/components/StaticComponents/StaticTableOfFigures.js",
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js~StaticTableOfFigures",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StaticComponents/StaticTableOfFigures.js",
    "importStyle": "StaticTableOfFigures",
    "description": "dumb component for rendering a static table of figures",
    "lineNumber": 21,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 116,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StaticComponents/StaticTableOfFigures.js~StaticTableOfFigures",
    "longname": "src/core/components/StaticComponents/StaticTableOfFigures.js~StaticTableOfFigures#render",
    "access": null,
    "description": "render",
    "lineNumber": 40,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 117,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {generateOpenUrl} from '../../utils/microDataUtils';\n\n// let styles = {};\n\n/**\n * dumb component for rendering the structured representation of a cited element in the format of openUrl/Context Object in Span\n */\nexport default class StructuredCOinS extends React.Component {\n\n  /**\n   * propTypes\n   */\n  static propTypes = {\n    resource: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const openUrl = generateOpenUrl(this.props.resource);\n    return (\n      <span className=\"peritext-structured-context-object-in-span-container Z3988\" title={openUrl}></span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 118,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredCOinS",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredCOinS.js~StructuredCOinS",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredCOinS.js",
    "importStyle": "StructuredCOinS",
    "description": "dumb component for rendering the structured representation of a cited element in the format of openUrl/Context Object in Span",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 119,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCOinS.js~StructuredCOinS",
    "longname": "src/core/components/StructuredDataComponents/StructuredCOinS.js~StructuredCOinS#render",
    "access": null,
    "description": "render",
    "lineNumber": 25,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 120,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredCite.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredCite.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\n/**\n * dumb component for rendering the structured representation of a cite element\n */\nexport default class StructuredCite extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} value - the value of the cite item\n   * @property {string} property - the schema property to apply\n   */\n  static propTypes = {\n    value: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    property: 'name'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <cite\n        className=\"peritext-structred-cite-container\"\n        property={this.props.property}\n        itemProp={this.props.property}\n      >\n        {this.props.value}\n      </cite>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 121,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredCite",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCite.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredCite.js~StructuredCite",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredCite.js",
    "importStyle": "StructuredCite",
    "description": "dumb component for rendering the structured representation of a cite element",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 122,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredCite.js~StructuredCite",
    "longname": "src/core/components/StructuredDataComponents/StructuredCite.js~StructuredCite#render",
    "access": null,
    "description": "render",
    "lineNumber": 26,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 123,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredDate.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\n/**\n * dumb component for rendering the structured representation of a date\n */\nexport default class StructuredDate extends React.Component {\n\n  /**\n   * propTypes\n   * @property {number|string} value - the value of the date, as an absolute date number or as a string statement\n   * @property {string} property - the schema property to use for microformatting the element\n   * @property {string} modificator - the modificator statement to use for formatting the date\n   */\n  static propTypes = {\n    value: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string\n    ]),\n    property: PropTypes.string,\n    modificator: PropTypes.string\n  };\n\n  static defaultProps = {\n    property: 'datePublished'\n  };\n\n  /**\n   * Resolves date value against modificator statement\n   * @param {string|number} value - value of the date\n   * @param {string} modificator - modificator to be applied\n   * @return {Object} newVal - the modified value of the date\n  */\n  setFinalValue(value, modificator) {\n    if (typeof value === 'string' && modificator === 'year') {\n      const match = value.match(/([\\d]{2,4})/);\n      if (match) {\n        return match[1];\n      }\n    }\n    return value;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const finalValue = this.setFinalValue(this.props.value, this.props.modificator);\n    return (\n      <time\n        className=\"peritext-structured-date-container\"\n        property={this.props.property}\n        itemProp={this.props.property}\n        dateTime={finalValue}\n      >\n        {finalValue}\n      </time>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 124,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredDate",
    "memberof": "src/core/components/StructuredDataComponents/StructuredDate.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredDate.js",
    "importStyle": "StructuredDate",
    "description": "dumb component for rendering the structured representation of a date",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 125,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setFinalValue",
    "memberof": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate",
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate#setFinalValue",
    "access": null,
    "description": "Resolves date value against modificator statement",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value of the date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "modificator",
        "description": "modificator to be applied"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newVal - the modified value of the date"
    },
    "generator": false
  },
  {
    "__docId__": 126,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate",
    "longname": "src/core/components/StructuredDataComponents/StructuredDate.js~StructuredDate#render",
    "access": null,
    "description": "render",
    "lineNumber": 47,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 127,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\nimport renderContents from '../../utils/componentsFactory';\n\n/**\n * dumb component for displaying a structured simple hyperlink <a>\n */\nexport default class StructuredHyperLink extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string} schematype html schema type of the element\n   * @property {array} contents the text to display inside the hyperlink\n   * @property {object} resource the resource to be parsed\n   * @property {object} property the microformat property of the hyperlink\n   */\n  static propTypes = {\n    contents: PropTypes.array,\n    schematype: PropTypes.string,\n    resource: PropTypes.object,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    schematype: 'website',\n    property: 'citation'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const invisibleStyle = {\n      display: 'none'\n    };\n    return (\n            <a className=\"peritext-structured-hyperlink-container\"\n                itemScope\n                itemProp={this.props.property}\n                itemType={'http://schema.org/' + this.props.schematype}\n                typeof={this.props.schematype}\n                resource={'#' + this.props.resource.id}\n                href={this.props.resource.url}\n            >\n              <span\n                itemProp=\"name\"\n                property=\"name\"\n                value={this.props.resource.title}\n                style={invisibleStyle}\n              >\n                {this.props.resource.title}\n              </span>\n              <span\n                itemrop=\"name\"\n                property=\"name\"\n                value={this.props.resource.url}\n                style={invisibleStyle}\n              >\n                {this.props.resource.url}\n              </span>\n              <span>\n                {renderContents(this.props.contents)}\n              </span>\n            </a>\n          );\n  }\n}\n"
  },
  {
    "__docId__": 128,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredHyperLink",
    "memberof": "src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredHyperLink.js~StructuredHyperLink",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredHyperLink.js",
    "importStyle": "StructuredHyperLink",
    "description": "dumb component for displaying a structured simple hyperlink <a>",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 129,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredHyperLink.js~StructuredHyperLink",
    "longname": "src/core/components/StructuredDataComponents/StructuredHyperLink.js~StructuredHyperLink#render",
    "access": null,
    "description": "render",
    "lineNumber": 33,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 130,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport {\n  StructuredDate,\n  StructuredSpan,\n  StructuredPerson\n} from '../index';\n\n/**\n * dumb component for rendering the structured representation of a section\n */\nexport default class StructuredMetadataPlaceholder extends React.Component {\n\n  /**\n   * propTypes\n   * @property {Object} section - section to represent with metadata\n   */\n  static propTypes = {\n    section: PropTypes.object\n  };\n\n  static defaultProps = {\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    const metadata = Object.keys(this.props.section.metadata).reduce((metas, domainKey) => {\n      return metas.concat(\n        Object.keys(this.props.section.metadata[domainKey]).map(propKey => {\n          return {\n            key: propKey,\n            domain: domainKey,\n            value: this.props.section.metadata[domainKey][propKey].value\n          };\n        }\n      ));\n    }, []);\n    return (\n      <div\n        className=\"peritext-structured-metadata-placeholder-container\"\n        style={{visibility: 'hidden'}}\n      >\n        {metadata.filter((prop) =>{\n          return prop.domain === 'general';\n        }).map((meta) =>{\n          switch (meta.key) {\n          case 'title':\n            return <StructuredSpan key={meta.key} property=\"name\" value={meta.value} />;\n          case 'date':\n            return <StructuredDate key={meta.key} property=\"datePublished\" value={meta.value} />;\n          case 'author':\n            return (\n              <span key={meta.key}>\n                {\n                  meta.value.map((author)=> {\n                    return <StructuredPerson resource={author} key={author.id} />;\n                  })\n                }\n              </span>\n            );\n          // TODO : continue along with other metadata-to-schema conversions\n          default:\n            return '';\n          }\n        })}\n      </div>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 131,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredMetadataPlaceholder",
    "memberof": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js~StructuredMetadataPlaceholder",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js",
    "importStyle": "StructuredMetadataPlaceholder",
    "description": "dumb component for rendering the structured representation of a section",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 132,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js~StructuredMetadataPlaceholder",
    "longname": "src/core/components/StructuredDataComponents/StructuredMetadataPlaceholder.js~StructuredMetadataPlaceholder#render",
    "access": null,
    "description": "render",
    "lineNumber": 28,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 133,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport reactStringReplace from 'react-string-replace';\nimport {\n  StructuredDate\n} from '../index';\n\n\n/**\n * dumb component for rendering the structured representation of parent journal information\n */\nexport default class StructuredParentJournal extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource parsed for structuring data\n   * @property {string} pattern - the pattern to apply for formatting thresource\n   * @property {string} property - the microformat property to apply to the structured element\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    pattern: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    pattern: '${journal}, ${date}, ${volume}(${issue}). ISSN : ${issn}',\n    property: 'isPartOf'\n  };\n\n  /**\n   * updateHtml : transform pattern+resource props into a react element\n   * @param {object} resource - the resource to render\n   * @param {string} pattern - the pattern to use for rendering the resource\n   * @return {ReactElement} markup\n   */\n  updateHtml(resource, pattern) {\n    let replacedText;\n    replacedText = reactStringReplace(pattern, /(\\${journal})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-journal\">{resource.journal}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${date})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-date\">{resource.date || resource.year}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${volume})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-volume\">{resource.volume}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${issue})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-issue\">{resource.issue}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${issn})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-parent-journal-issn\">{resource.issn}</span>\n    ));\n    return replacedText;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        className=\"peritext-structured-parent-journal-container\"\n        itemProp={this.props.property}\n        property={this.props.property}\n        itemScope\n        itemType=\"http://schema.org/Periodical\"\n        typeof=\"Periodical\"\n        resource={this.props.resource.issn + this.props.resource.journal}\n      >\n        <span style={{display: 'none'}} itemProp=\"name\" property=\"name\">{this.props.resource.journal}</span>\n        <span\n          itemProp=\"hasPart\"\n          property=\"hasPart\"\n          itemScope\n          itemType=\"http://schema.org/PublicationVolume\"\n          typeof=\"PublicationVolume\"\n          resource={this.props.resource.issn + this.props.resource.journal + '-volume' + this.props.resource.volume}\n          style={{display: 'none'}}\n        >\n          <span itemProp=\"volumeNumber\" property=\"volumeNumber\">{this.props.resource.volume}</span>\n          <span\n            itemProp=\"hasPart\"\n            property=\"hasPart\"\n            itemScope\n            itemType=\"http://schema.org/PublicationIssue\"\n            typeof=\"PublicationIssue\"\n            resource={this.props.resource.issn + this.props.resource.journal + '-volume' + this.props.resource.volume + '-issue' + this.props.resource.issue}\n          >\n            <span itemProp=\"issueNumber\" property=\"issueNumber\">{this.props.resource.issue}</span>\n            <StructuredDate value={this.props.resource.date || this.props.resource.year}/>\n          </span>\n        </span>\n        <span\n          itemProp=\"issn\"\n          style={{display: 'none'}}\n          property=\"issn\">\n            {this.props.resource.issn}\n        </span>\n\n        {this.updateHtml(this.props.resource, this.props.pattern)}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 134,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredParentJournal",
    "memberof": "src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredParentJournal.js",
    "importStyle": "StructuredParentJournal",
    "description": "dumb component for rendering the structured representation of parent journal information",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 135,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "updateHtml",
    "memberof": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal",
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal#updateHtml",
    "access": null,
    "description": "updateHtml : transform pattern+resource props into a react element",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "the resource to render"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to use for rendering the resource"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 136,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal",
    "longname": "src/core/components/StructuredDataComponents/StructuredParentJournal.js~StructuredParentJournal#render",
    "access": null,
    "description": "render",
    "lineNumber": 64,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 137,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredPerson.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport reactStringReplace from 'react-string-replace';\n\n/**\n * dumb component for rendering the structured representation of a person\n */\nexport default class StructuredPerson extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} resource - the person object which may contain the following props : \"lastName\", \"firstName\", \"role\", and \"information\"\n   * @property {string} pattern - the pattern to apply for formatting the person name to html, eg : \" ${lastName:capitals}, ${firstName:initials}\"\n   * @property {string} property - the microformat property to apply to the structured element\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    pattern: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    pattern: '${firstName} ${lastName}',\n    property: 'author'\n  };\n\n  /**\n   * transformValues modifies firstName and lastName according to pattern indications\n   * @param {Object} author - the person representation to transform\n   * @param {string} pattern - the pattern to use for transforming person representation\n   * @return {Object} newAuthor - new author object\n   */\n  transformValues(author, pattern) {\n    const vals = Object.assign({}, author);\n    // catch format transformers\n    const transformFirstNameMatch = pattern.match(/(\\${firstName(:[^}]*)?})/);\n    const transformLastNameMatch = pattern.match(/(\\${lastName(:[^}]*)?})/);\n    // if transformers - transform\n    if (transformFirstNameMatch) {\n      if (transformFirstNameMatch[2] === ':initials') {\n        // processing composed names (e.g. Gian-Marco Patalucci)\n        let initials = vals.firstName.split('-').map((term)=>{\n          if (term.length > 0) {\n            return term.toUpperCase().substr(0, 1) + '.';\n          }\n          return term;\n        }).join('-');\n        // processing multiple names (e.g. Donald Ronald Romuald Ronaldo Reagan)\n        initials = vals.firstName.split(' ').map((term)=>{\n          if (term.length > 0) {\n            return term.toUpperCase().substr(0, 1) + '.';\n          }\n          return term;\n        }).join(' ');\n        vals.firstName = initials;\n      }\n    }\n    if (transformLastNameMatch) {\n      if (transformLastNameMatch[2] === ':capitals') {\n        vals.lastName = vals.lastName.toUpperCase();\n      }\n    }\n    return vals;\n  }\n\n  /**\n   * updateHtml : transform pattern+person props into a react element\n   * @return {ReactElement} markup\n   */\n  updateHtml() {\n    const vals = this.transformValues(this.props.resource, this.props.pattern);\n\n    const firstNameExp = this.props.pattern.match(/(\\${firstName(:[^}]*)?})/);\n    const lastNameExp = this.props.pattern.match(/(\\${lastName(:[^}]*)?})/);\n    let replacedText = this.props.pattern;\n    if (firstNameExp) {\n      replacedText = reactStringReplace(replacedText, new RegExp('(\\\\' + firstNameExp[0] + ')', 'g'), (match, index)=> (\n        <span key={match + index} className=\"peritext-structured-person-firstname\" itemProp=\"givenName\" property=\"givenName\" >{vals.firstName}</span>\n      ));\n    }\n\n    if (lastNameExp) {\n      replacedText = reactStringReplace(replacedText, new RegExp('(\\\\' + lastNameExp[0] + ')', 'g'), (match, index)=> (\n        <span key={match + index} className=\"peritext-structured-person-lastname\" itemProp=\"familyName\" property=\"familyName\" >{vals.lastName}</span>\n      ));\n    }\n\n    replacedText = reactStringReplace(replacedText, /(\\${role})/g, (match, index)=> (\n      <span key={match + index} className=\"peritext-structured-person-role\" >{vals.role}</span>\n    ));\n\n    if (vals.information) {\n      replacedText = reactStringReplace(replacedText, /(\\${information})/g, (match, index)=> (\n        <span key={match + index} className=\"peritext-structured-person-information\" >{vals.information}</span>\n      ));\n    }\n\n    return replacedText;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        className=\"peritext-structured-person-container\"\n        itemProp={this.props.property}\n        itemScope\n        itemType=\"http://schema.org/Person\"\n        property={this.props.property}\n        typeof=\"Person\"\n        resource={this.props.resource.id}\n      >\n        {this.updateHtml()}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 138,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredPerson",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredPerson.js",
    "importStyle": "StructuredPerson",
    "description": "dumb component for rendering the structured representation of a person",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 139,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "transformValues",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson#transformValues",
    "access": null,
    "description": "transformValues modifies firstName and lastName according to pattern indications",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "author",
        "description": "the person representation to transform"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to use for transforming person representation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newAuthor - new author object"
    },
    "generator": false
  },
  {
    "__docId__": 140,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "updateHtml",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson#updateHtml",
    "access": null,
    "description": "updateHtml : transform pattern+person props into a react element",
    "lineNumber": 69,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 141,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson",
    "longname": "src/core/components/StructuredDataComponents/StructuredPerson.js~StructuredPerson#render",
    "access": null,
    "description": "render",
    "lineNumber": 104,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 142,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\nimport reactStringReplace from 'react-string-replace';\n\n/**\n * dumb component for rendering the structured representation of publisher information\n */\nexport default class StructuredPublisher extends React.Component {\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource parsed for structuring data\n   * @property {string} pattern - the pattern to apply for formatting thresource\n   * @property {string} property - the microformat property to apply to the structured element\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    pattern: PropTypes.string,\n    property: PropTypes.string\n  };\n\n  static defaultProps = {\n    pattern: '${publisher} : ${address}',\n    property: 'publisher'\n  };\n\n  /**\n   * updateHtml : transform pattern+resource props into a react element\n   * @param {object} resource - the resource to represent\n   * @param {string} pattern - the pattern to represent the resource with\n   * @return {ReactElement} markup\n   */\n  updateHtml(resource, pattern) {\n\n    let replacedText = reactStringReplace(pattern, /(\\${publisher})/g, (match, index)=> (\n      <span key={match + index} itemProp=\"name\" property=\"name\" className=\"peritext-structured-publisher-publisher\">{resource.publisher}</span>\n    ));\n\n    replacedText = reactStringReplace(replacedText, /(\\${address})/g, (match, index)=> (\n      <span key={match + index} itemProp=\"address\" value=\"address\" className=\"peritext-structured-publisher-address\">{resource.address}</span>\n    ));\n\n    return replacedText;\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        className=\"peritext-structured-publisher-container\"\n        itemProp={this.props.property}\n        property={this.props.property}\n        itemScope\n        itemType=\"http://schema.org/Organization\"\n        typeof=\"Organization\"\n        resource={this.props.resource.publisher}\n      >\n        {this.updateHtml(this.props.resource, this.props.pattern)}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 143,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredPublisher",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredPublisher.js",
    "importStyle": "StructuredPublisher",
    "description": "dumb component for rendering the structured representation of publisher information",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 144,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "updateHtml",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher",
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher#updateHtml",
    "access": null,
    "description": "updateHtml : transform pattern+resource props into a react element",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "the resource to represent"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to represent the resource with"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 145,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher",
    "longname": "src/core/components/StructuredDataComponents/StructuredPublisher.js~StructuredPublisher#render",
    "access": null,
    "description": "render",
    "lineNumber": 49,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 146,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/StructuredDataComponents/StructuredSpan.js",
    "memberof": null,
    "longname": "src/core/components/StructuredDataComponents/StructuredSpan.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import React, {PropTypes} from 'react';\n\n/**\n * dumb generic component for rendering the structured representation of a property\n */\nexport default class StructuredSpan extends React.Component {\n\n  /**\n   * propTypes\n   * @property {string|number} value - the value to put in the span\n   * @property {string} property - the schema property to microformat the span with\n   * @property {string} htmlClass - the class to apply to the span element\n   */\n  static propTypes = {\n    value: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.number\n    ]),\n    property: PropTypes.string,\n    htmlClass: PropTypes.string\n  };\n\n  static defaultProps = {\n    property: 'name'\n  };\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <span\n        property={this.props.property}\n        itemProp={this.props.property}\n        className={this.props.htmlClass}\n      >\n        {this.props.value}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 147,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "StructuredSpan",
    "memberof": "src/core/components/StructuredDataComponents/StructuredSpan.js",
    "longname": "src/core/components/StructuredDataComponents/StructuredSpan.js~StructuredSpan",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/components/StructuredDataComponents/StructuredSpan.js",
    "importStyle": "StructuredSpan",
    "description": "dumb generic component for rendering the structured representation of a property",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 148,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/components/StructuredDataComponents/StructuredSpan.js~StructuredSpan",
    "longname": "src/core/components/StructuredDataComponents/StructuredSpan.js~StructuredSpan#render",
    "access": null,
    "description": "render",
    "lineNumber": 31,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 149,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/components/index.js",
    "memberof": null,
    "longname": "src/core/components/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Components - generic components to be used in several places of the lib\n * @module components\n */\n\nexport { default as StaticBackCover } from './StaticComponents/StaticBackCover.js';\nexport { default as StaticDocument } from './StaticComponents/StaticDocument.js';\nexport { default as StaticEndNotes } from './StaticComponents/StaticEndNotes.js';\nexport { default as StaticEndFigures } from './StaticComponents/StaticEndFigures.js';\nexport { default as StaticFootnote } from './StaticComponents/StaticFootnote.js';\nexport { default as StaticForewords } from './StaticComponents/StaticForewords.js';\nexport { default as StaticFrontCover } from './StaticComponents/StaticFrontCover.js';\nexport { default as StaticGlossary } from './StaticComponents/StaticGlossary.js';\nexport { default as StaticImageFigure } from './StaticComponents/StaticImageFigure.js';\nexport { default as StaticNoteContent } from './StaticComponents/StaticNoteContent.js';\nexport { default as StaticNotePointer } from './StaticComponents/StaticNotePointer.js';\nexport { default as StaticReferencesList } from './StaticComponents/StaticReferencesList.js';\nexport { default as StaticSection } from './StaticComponents/StaticSection.js';\nexport { default as StaticTableOfContents } from './StaticComponents/StaticTableOfContents.js';\nexport { default as StaticTableOfFigures } from './StaticComponents/StaticTableOfFigures.js';\n\nexport { default as StructuredCite } from './StructuredDataComponents/StructuredCite.js';\nexport { default as StructuredCOinS } from './StructuredDataComponents/StructuredCOinS.js';\nexport { default as StructuredDate } from './StructuredDataComponents/StructuredDate.js';\nexport { default as StructuredHyperLink } from './StructuredDataComponents/StructuredHyperLink.js';\nexport { default as StructuredMetadataPlaceholder } from './StructuredDataComponents/StructuredMetadataPlaceholder.js';\nexport { default as StructuredParentJournal } from './StructuredDataComponents/StructuredParentJournal.js';\nexport { default as StructuredPerson } from './StructuredDataComponents/StructuredPerson.js';\nexport { default as StructuredPublisher } from './StructuredDataComponents/StructuredPublisher.js';\nexport { default as StructuredSpan } from './StructuredDataComponents/StructuredSpan.js';\n"
  },
  {
    "__docId__": 150,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/controllers/annotationsController.js",
    "memberof": null,
    "longname": "src/core/controllers/annotationsController.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Annotations controller - a set of pure functions for interacting with an annotations source (through a connector)\n * @module controllers/annotationsController\n * @todo everything\n */\n"
  },
  {
    "__docId__": 151,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/controllers/assetsController.js",
    "memberof": null,
    "longname": "src/core/controllers/assetsController.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Assets controller - a set of pure functions for interacting with an assets source (through a connector)\n * @module controllers/assetsController\n */\n\nlet connector;\nlet connectorName;\nlet tempConnectorName;\n\n/**\n* Updates the active connector module according to connection params\n* @param {Object} params - connection params\n*/\nconst updateConnector = (params)=> {\n  tempConnectorName = params.connector;\n  if (tempConnectorName !== connectorName) {\n    connectorName = tempConnectorName;\n    connector = require('./../../connectors/' + params.connector);\n  }\n};\n\n/**\n * Provides the URI of a specific assets file from connector\n * @param {array|string} path - the path of the assets file to look for\n * @param {Object} params - connection params\n * @return {function(connectorError: error, uri: string)} callback - possible errors and the uri\n*/\nexport const getAssetUri = (path, params, callback)=> {\n  updateConnector(params);\n  connector.getAssetUri({path, params}, callback);\n};\n\n/**\n* Returns an appropriate connector function for directly reading a file from assets source\n* @param {Object} params - connection params\n* @return {function(err: error, res: Object)} readFunction - the connector function for directly reading a file contents from assets source\n*/\nexport const getReader = (params) =>{\n  updateConnector(params);\n  return connector.readFromPath;\n};\n"
  },
  {
    "__docId__": 152,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateConnector",
    "memberof": "src/core/controllers/assetsController.js",
    "longname": "src/core/controllers/assetsController.js~updateConnector",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/controllers/assetsController.js",
    "importStyle": null,
    "description": "Updates the active connector module according to connection params",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getAssetUri",
    "memberof": "src/core/controllers/assetsController.js",
    "longname": "src/core/controllers/assetsController.js~getAssetUri",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/assetsController.js",
    "importStyle": "{getAssetUri}",
    "description": "Provides the URI of a specific assets file from connector",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "the path of the assets file to look for"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(connectorError: error, uri: string)"
      ],
      "spread": false,
      "description": "callback - possible errors and the uri"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getReader",
    "memberof": "src/core/controllers/assetsController.js",
    "longname": "src/core/controllers/assetsController.js~getReader",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/assetsController.js",
    "importStyle": "{getReader}",
    "description": "Returns an appropriate connector function for directly reading a file from assets source",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(err: error, res: Object)"
      ],
      "spread": false,
      "description": "readFunction - the connector function for directly reading a file contents from assets source"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/controllers/contentsController.js",
    "memberof": null,
    "longname": "src/core/controllers/contentsController.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Contents controller - a set of pure functions for parsing and serializing fsTree representations to peritextSections representations\n * @module controllers/contentsController\n */\n\nimport {\n  waterfall,\n  mapSeries,\n  ensureAsync\n} from 'async';\nimport {\n  parseDocument,\n  serializeDocument\n} from '../converters/documentConverter';\nimport { diff } from 'deep-diff';\nimport * as filesystem from '../../connectors/filesystem';\nlet connector;\nlet connectorName;\nlet tempConnectorName;\n\n/**\n* Updates the active connector module according to connection params\n* @param {Object} params - connection params\n*/\nconst updateConnector = (params) => {\n  tempConnectorName = params.connector;\n  if (tempConnectorName !== connectorName) {\n    connectorName = tempConnectorName;\n    if ( connectorName === 'filesystem' ) {\n      connector = filesystem;\n    }\n    // this method is better but does not work when integrating the lib with webpack-based app (to investigate)\n    // connector = require('./../../../connectors/' + params.connector);\n  }\n};\n\n/**\n* Resolves a difference object through Create/Update/Delete operations\n* @param {Object} difference - the difference object specifying type of difference and details\n* @param {Object} params - connection params\n* @param {Object} connect - connector module\n* @param {function(connectorError: error, connectorResult)} callback - provided by connector\n*/\nconst applyDifference = (difference, params, connect, callback) => {\n  let item;\n  switch (difference.kind) {\n  // new element\n  case 'N':\n    item = difference.rhs;\n    return connect.createFromPath({\n      path: item.path,\n      params,\n      type: item.type,\n      overwrite: true,\n      stringContents: (item.stringContents || '')\n    }, callback);\n  // delete element\n  case 'D':\n    return connect.deleteFromPath({\n      path: difference.lhs.path,\n      params\n    }, callback);\n  // edit element\n  case 'E':\n    if (difference.path.pop() === 'path') {\n      return callback();\n    }\n    console.log('unhandled edit difference ', difference);\n    break;\n  // change in array\n  case 'A':\n    switch (difference.item.kind) {\n    case 'N':\n      item = difference.item.rhs;\n      return waterfall([\n        (containerCb) => {\n          connect.createFromPath({\n            path: item.path,\n            params,\n            type: item.type,\n            overwrite: true,\n            stringContents: (item.stringContents || '')\n          }, containerCb);\n        },\n        (childrenCb)=> {\n          if (item.children) {\n            return mapSeries(item.children, ensureAsync((child, childCb)=>{\n              return connect.createFromPath({\n                path: child.path,\n                params,\n                type: child.type,\n                overwrite: true,\n                stringContents: (child.stringContents || '')\n              }, childCb);\n            }), childrenCb);\n          }\n          // default callback\n          return childrenCb(null);\n        }\n      ], callback);\n\n    case 'D':\n      item = difference.item.lhs;\n      return connect.deleteFromPath({\n        path: item.path,\n        params\n      }, callback);\n\n    case 'E':\n      item = difference.item.rhs;\n      return waterfall([\n        // create root\n        (cb)=> {\n          connect.updateFromPath({\n            path: item.path,\n            params,\n            stringContents: (item.stringContents || '')\n          }, cb);\n        },\n        // update children\n        (cb)=> {\n          if (item.children) {\n            mapSeries(item.children, ensureAsync((child, cb2)=> {\n              connect.updateFromPath({path: child.path, params, stringContents: (child.stringContents || '')}, cb2);\n            }), cb);\n          } else cb();\n        }\n      ], callback);\n\n    default:\n      console.log('unhandled difference ', difference);\n      break;\n    }\n    break;\n  default:\n    console.log('unhandled difference ', difference);\n    break;\n  }\n  callback();\n};\n\n/**\n  * @param {Object} params - connection params\n  * @param {Object} models - peritext models to use\n  * @param {Object} parametesr - language templates parameters - with which expressions are templates or includes wrapped ?\n  * @param {function(parsingErrors: error, results:Object)} callback - block errors and a result object containing section and an array of warnings+parsing errors\n  */\nexport const updateFromSource = (params, models, parameters, callback) => {\n  updateConnector(params);\n  waterfall([\n    (cb)=> {\n      connector.readFromPath({\n        params, path: [],\n        depth: true,\n        parseFiles: true\n      }, (err, results)=> {\n        cb(err, results);\n      });\n    },\n    (tree, cb)=> {\n      parseDocument({tree, models, parameters}, cb);\n    }\n  ],\n  (err, results)=> {\n    callback(err, results);\n  });\n};\n\n/**\n* Serializes the representation of a series of peritext sections to an fsTree representation by \"diffing\" new fsTree with previous fsTree\n* then makes a diff list with deep-diff\n* then monitor source tree updating (with C.U.D. operations) accordingly\n* @param {Object} params - connection params\n* @param {array} document - the peritext document to serialize\n* @param {Object} models - peritext models to use\n* @param {Object} oldFsTree - the previous fsTree representation to compare with the new\n* @param {function(serializingErrors: error, sections:array)} callback - errors and input sections\n*/\nexport const updateToSource = (params, document, models, oldFsTree, callback) => {\n  updateConnector(params);\n  const newFsTree = serializeDocument({\n    document,\n    models,\n    basePath: params.basePath\n  });\n  const differences = diff(oldFsTree, newFsTree);\n  mapSeries(differences, ensureAsync((difference, cb)=> {\n    applyDifference(difference, params, connector, cb);\n  }), (errors)=> {\n    callback(errors, newFsTree);\n  });\n};\n"
  },
  {
    "__docId__": 156,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateConnector",
    "memberof": "src/core/controllers/contentsController.js",
    "longname": "src/core/controllers/contentsController.js~updateConnector",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/controllers/contentsController.js",
    "importStyle": null,
    "description": "Updates the active connector module according to connection params",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "applyDifference",
    "memberof": "src/core/controllers/contentsController.js",
    "longname": "src/core/controllers/contentsController.js~applyDifference",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/controllers/contentsController.js",
    "importStyle": null,
    "description": "Resolves a difference object through Create/Update/Delete operations",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "difference",
        "description": "the difference object specifying type of difference and details"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "connect",
        "description": "connector module"
      },
      {
        "nullable": null,
        "types": [
          "function(connectorError: error, connectorResult)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "provided by connector"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateFromSource",
    "memberof": "src/core/controllers/contentsController.js",
    "longname": "src/core/controllers/contentsController.js~updateFromSource",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/contentsController.js",
    "importStyle": "{updateFromSource}",
    "description": "",
    "lineNumber": 148,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "peritext models to use"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parametesr",
        "description": "language templates parameters - with which expressions are templates or includes wrapped ?"
      },
      {
        "nullable": null,
        "types": [
          "function(parsingErrors: error, results:Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "block errors and a result object containing section and an array of warnings+parsing errors"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "updateToSource",
    "memberof": "src/core/controllers/contentsController.js",
    "longname": "src/core/controllers/contentsController.js~updateToSource",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/controllers/contentsController.js",
    "importStyle": "{updateToSource}",
    "description": "Serializes the representation of a series of peritext sections to an fsTree representation by \"diffing\" new fsTree with previous fsTree\nthen makes a diff list with deep-diff\nthen monitor source tree updating (with C.U.D. operations) accordingly",
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "connection params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the peritext document to serialize"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "peritext models to use"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "oldFsTree",
        "description": "the previous fsTree representation to compare with the new"
      },
      {
        "nullable": null,
        "types": [
          "function(serializingErrors: error, sections:array)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "errors and input sections"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/bibTexConverter.js",
    "memberof": null,
    "longname": "src/core/converters/bibTexConverter.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module parses and serializes bibTex objects\n * @module converters/bibTexConverter\n */\n\n/**\n * homemade bibTeX syntax parser (performance could be improved I guess)\n * it needs a second pass to parse {} in values and analyze them against a model - that should be done elsewhere, as this converter just deals with syntax-to-object conversion\n */\nclass bibTexParser {\n  /**\n   * constructor\n   */\n  constructor() {\n    this.STATES = ['bibType', 'id', 'properties'];\n    this.testing = false;\n  }\n\n  /**\n   * Adds a key+value prop to the resource's javascript representation object\n   * @param {object} obj - the resource representation\n   * @param {string} key - the key to populate\n   * @param {string} value - the value to set\n   * @return {object} newObj - the updated resource representation\n   */\n  addValue(obj, key, value) {\n    if (obj[key]) {\n\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      }else obj[key] = [obj[key], value];\n\n    }else obj[key] = value;\n\n    return obj;\n  }\n\n  /**\n   * Consumes a string (stored in this.consumable) representation of a bibTeX expression\n   * @return {boolean} exit - a simple exit trigger (but internal props will have been mutated)\n   */\n  consume() {\n    const matchBibType = /^@([^{]+)/;\n    const matchId = /^{([^,]+),/;\n    const wrappers = [\n      ['{', '}'],\n      ['\"', '\"']\n    ];\n\n    if (this.testing) {\n      console.log('current state: ', this.currentState);\n    }\n\n    let match;\n    if (this.currentState === 'bibType') {\n      match = matchBibType.exec(this.consumable);\n      if (match) {\n        this.currentObject.bibType = match[1];\n        this.consumable = this.consumable.substr(match[1].length + 1);\n        this.currentState = this.STATES[1];\n        return true;\n      }\n      this.error = {\n        type: 'error',\n        preciseType: 'bibParsingError',\n        message: 'could not find bibType',\n        initialString: this.initialStr\n      };\n      return true;\n\n    } else if (this.currentState === 'id') {\n      match = matchId.exec(this.consumable);\n      if (match) {\n        this.currentObject.id = match[1];\n        this.consumable = this.consumable.substr(match[1].length + 2);\n        this.currentState = this.STATES[2];\n        return true;\n      }\n      this.error = {\n        type: 'error',\n        preciseType: 'bibParsingError',\n        message: 'could not find citekey',\n        initialString: this.initialStr\n      };\n      return true;\n\n    /*\n     * ``key = value`` structure\n     * value is always wrapped inside character couples that vary depending on bibtex implementation (\" { ')\n     * possibility of nested wrapping (eg {Name {{S}urname}})\n     */\n    }else if (this.currentState === 'properties') {\n      const wrapped = [wrappers[0]];\n      let index = 0;\n      let mode = 'key';\n      let temp = '';\n      let tempKey = '';\n      let trespassing;\n      let character;\n      let entering;\n\n      if (this.testing) {\n        console.log('initial parser mode: ', mode, ' || stored wrapped pairs : ', wrapped);\n      }\n\n      while (wrapped.length > 0) {\n\n        trespassing = index > this.consumable.length - 1;\n        character = this.consumable.charAt(index);\n        if (this.testing) {\n          console.log('===\\nNEW PARSING STATE \\n===');\n          console.log('actual char', character);\n          console.log('actual mode: ', mode);\n          console.log('actual wrapped pairs: ', wrapped);\n        }\n\n        if (trespassing) {\n          this.error = {\n            type: 'error',\n            preciseType: 'bibParsingError',\n            message: 'finished to parse bibtex string without finding closing character ' + wrapped[wrapped.length - 1][1],\n            initialString: this.initialStr\n          };\n          if (this.testing)console.log('trespassing');\n          return true;\n        // end of wrapped expression - if matches with last recorded wrapper's closing character\n        } else if (character === wrapped[wrapped.length - 1][1]) {\n          wrapped.pop();\n          if (wrapped.length > 1) {\n            temp += character;\n          }\n          index = 1;\n          if (this.testing)console.log('poped a wrapping level');\n        // end of key specification, record tempkey and wait to have found value\n        } else if (mode === 'key' && character === '=') {\n          tempKey = temp.trim();\n          if (this.testing)console.log('encountered a = in key mode, storing key ', tempKey);\n          temp = '';\n          mode = 'value';\n          index = 1;\n        // end of value specification - add value and reboot temp\n        }else if (mode === 'value' && wrapped.length < 2 && character === ',') {\n          if (this.testing)console.log('end of line, storing prop');\n          this.addValue(this.currentObject, tempKey, temp.trim());\n          temp = '';\n          mode = 'key';\n          index = 1;\n        // in the middle of some key or value = continue\n        } else if (mode === 'value') {\n          entering = false;\n          // catch wrapper char\n          wrappers.some((wrapper) => {\n            if (this.consumable.charAt(index) === wrapper[0]) {\n              entering = true;\n              return wrapped.push(wrapper);\n            }\n          });\n          if (!(entering && wrapped.length <= 2)) {\n            temp += character;\n          }\n          if (this.testing)console.log('continuing in value ', temp);\n          index = 1;\n        // default, by security\n        } else {\n          if (this.testing)console.log('default exit doing nothing');\n          // if(this.testing)console.log('current string: ', this. consumable.substr(index));\n          temp += character;\n          index = 1;\n        }\n        this.consumable = this.consumable.substr(index);\n        if (this.testing)console.log(this.currentObject);\n\n      }\n      this.addValue(this.currentObject, tempKey.trim(), temp.trim());\n\n      // add if not empty\n      if (Object.keys(this.currentObject).length) {\n        this.results.push(Object.assign({}, this.currentObject));\n      }\n      this.currentObject = {};\n      this.consumable = this.consumable.substr(index).trim();\n      this.currentState = this.STATES[0];\n      return true;\n    }\n  }\n\n\n  /**\n   * Parses a bibTeX string and callbacks a javascript objet\n   * @param {string} str - the string to parse\n   * @param {function(error:error, results:Object)} callback\n   */\n  parse(str, callback) {\n    this.currentObject = {};\n    this.currentState = this.STATES[0];\n    this.results = [];\n    this.consumable = str.trim();\n    this.initialStr = str.trim();\n    this.error = null;\n    while (this.error === null && this.consumable.trim().length > 0) {\n      this.consume();\n    }\n    return callback(this.error, this.results);\n  }\n\n}\n\nconst parser = new bibTexParser();\n\n\n/**\n * Parses a bibTeX string and returns an object\n * @param {string} str - the bibTeX string to parse\n * @return {function(error: error, result: Object)} callback - error and the resulting object\n */\nexport const parseBibTexStr = (str, callback) => {\n  if (typeof str === 'string') {\n    return parser.parse(str, callback);\n  }\n  return callback(new Error('must input a string'), undefined);\n};\n\nconst validateBibObject = function(bibObject) {\n  if (bibObject.id === undefined) {\n    return {\n      type: 'error',\n      preciseType: 'bibObjectValidationError',\n      message: 'bibObject must have a id property',\n      bibObject: bibObject\n    };\n  } else if (bibObject.bibType === undefined) {\n    return {\n      type: 'error',\n      preciseType: 'bibObjectValidationError',\n      message: 'bibObject must have a bibType property',\n      bibObject: bibObject\n    };\n  }\n\n  for (const key in bibObject) {\n    if (typeof bibObject[key] === 'object' && !Array.isArray(bibObject[key])) {\n      return {\n        type: 'error',\n        preciseType: 'bibObjectValidationError',\n        message: 'bibObject cannot contain nested objects',\n        bibObject: bibObject\n      };\n    }\n  }\n\n  return true;\n};\n\n/**\n * Serializes a javascript object representing a resource or a contextualizer, to a bibTeX-formatted string\n * @param {object} bibObject - the resource/contextualizer representation\n * @return {string} bibStr - the bibTeX mention as a string\n */\nexport const serializeBibTexObject = (bibObject) => {\n  const validated = validateBibObject(bibObject);\n  if (validated.type === 'error') {\n    return validated;\n  }\n  let str = '';\n  let val;\n  for (const key in bibObject) {\n    if (bibObject[key]) {\n      val = bibObject[key];\n      if (Array.isArray(val)) {\n        val.forEach((value)=>{\n          str += '\\t' + key + ' = {' + value + '},\\n';\n        });\n        //  val = val.join(',');\n      }else if (key !== 'id' && key !== 'bibType') {\n        str += '\\t' + key + ' = {' + val + '},\\n';\n      }\n    }\n  }\n  // removing the last coma\n  if (str.length > 1) {\n    str = str.substr(0, str.length - 2);\n  }\n  return `@${bibObject.bibType}{${bibObject.id},\n    ${str}\n}`;\n};\n\n/**\nAccepted inputs for authors and persons (to add in doc/spec):\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\nMaskin, Eric S.\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\nMaskin, Eric S.\n{Martin}, Julia; Coleman\n{Jakubowicz}, Andrew\n{Charalambos}, D. Aliprantis and Kim C. {Border}\n*/\n\n/**\n * Parses a list of authors as they are formatted in bbiTeX statements\n * @param {string} str - the bibTeX string to parse\n * @return {array} authors - the javascript representation of authors as an array\n */\nexport const parseBibAuthors = (str) => {\n  const authors = str.split(/;|and|et/);\n  const additionalInfo = /\\(([^)]*)?\\)?\\(?([^)]*)?\\)?/;\n  let match;\n  return authors.filter((inputStr) =>{\n    return inputStr.trim().length > 0;\n  }).map((inputAuthorStr) =>{\n    let workingStr = inputAuthorStr;\n    let authorStr = '';\n    let firstName;\n    let lastName;\n    let role = 'author';\n    let information;\n    match = inputAuthorStr.match(additionalInfo);\n    if (match) {\n      workingStr = workingStr.replace(match[0], '');\n      if (match[1]) {\n        role = match[1].trim();\n      }\n      if (match[2]) {\n        information = match[2];\n        information = information.trim();\n      }\n    }\n    const lastNameMatch = workingStr.match(/{([^}]*)}/);\n    if (lastNameMatch) {\n      lastName = lastNameMatch[1].trim();\n      authorStr = [workingStr.substr(0, lastNameMatch.index), workingStr.substr(lastNameMatch.index + lastNameMatch[0].length)].join('');\n      firstName = authorStr.replace(',', '').trim();\n    } else {\n      let vals = workingStr.split(',');\n      if (vals.length > 1) {\n        firstName = vals[1].trim();\n        lastName = vals[0].trim();\n      } else if (workingStr.trim().indexOf(' ') > -1) {\n        vals = workingStr.trim().split(' ');\n        firstName = vals.shift().trim();\n        lastName = vals.join(' ').trim();\n      } else {\n        lastName = workingStr.trim();\n        firstName = '';\n      }\n    }\n    const id = (role + '-' + firstName + lastName).toLowerCase().replace(' ', '-');\n    return {firstName, lastName, role, information, id};\n  });\n};\n\n/**\n * Parses a bibTeX-like contextualization statement given as string and returns an object\n * @param {string} inputStr - the bibTeX string to parse\n * @return {Object} contextualization - the contextualization object\n */\nexport const parseBibContextualization = (inputStr) => {\n  const bracketsRE = /([^=^,]+)=(?:{)([^}]*)(?:}),?/g;\n  const quoteRE = /([^=^,]+)=\"([^\"]*)\",?/g;\n  const paramsObject = {};\n\n\n  const str = inputStr.substr(1, inputStr.length - 2).replace(/&quot;/g, '\"');\n  let match;\n  let key;\n  let expression;\n  let subObject;\n  let newObj;\n\n  while ((match = bracketsRE.exec(str)) !== null) {\n    key = match[1].trim();\n    expression = match[2].trim().split(',');\n    // simple\n    if (expression.length === 1) {\n      paramsObject[key] = expression[0];\n    // nested\n    } else {\n      subObject = {};\n\n      let isArray;\n\n      expression = expression.map((exp) =>{\n        const split = exp.split('=');\n        if (split.length === 2) {\n          isArray = false;\n          return {\n            key: split[0],\n            value: split[1]\n          };\n        }\n        isArray = true;\n        return exp;\n      });\n\n      if (!isArray) {\n        subObject = expression.reduce((obj, exp)=>{\n          obj[exp.key] = exp.value;\n          return obj;\n        }, subObject);\n      }\n\n      newObj = Object.assign({}, subObject);\n\n      if (paramsObject[key] === undefined) {\n        paramsObject[key] = newObj;\n      } else if (Array.isArray(paramsObject[key])) {\n        paramsObject[key].push(newObj);\n      } else paramsObject[key] = [paramsObject[key], newObj];\n    }\n\n  }\n\n  while ((match = quoteRE.exec(str)) !== null) {\n    key = match[1].trim();\n    expression = match[2].trim();\n    paramsObject[key] = expression;\n  }\n\n  return paramsObject;\n};\n\n\nconst resolveNested = (subVal) => {\n  if (typeof subVal !== 'string') {\n    return subVal;\n  }\n  let expression = subVal.split(',');\n  let subObject;\n  let newObj;\n  // simple\n  if (expression.length === 1) {\n    return subVal;\n  // nested\n  }\n  subObject = {};\n  let isArray;\n  expression = expression.map((exp) =>{\n    const split = exp.split('=');\n    if (split.length === 2) {\n      isArray = false;\n      return {\n        key: split[0],\n        value: split[1]\n      };\n    }\n    isArray = true;\n    return exp;\n  });\n\n  if (!isArray) {\n    subObject = expression.reduce((obj, exp)=>{\n      obj[exp.key] = exp.value;\n      return obj;\n    }, subObject);\n  }\n\n  newObj = Object.assign({}, subObject);\n  return newObj;\n};\n\n/**\n * Parses bibTeX nested values inside a bibObject\n * @param {Object} bibObject - the object to parse\n * @return {Object} newObject - the resulting updated object\n */\nexport const parseBibNestedValues = (bibObject) => {\n  const newObject = Object.assign({}, bibObject);\n  let subVal;\n  for (const index in newObject) {\n    if (newObject[index]) {\n      subVal = newObject[index];\n      if (Array.isArray(subVal)) {\n        newObject[index] = bibObject[index].map(resolveNested);\n      }else {\n        newObject[index] = resolveNested(newObject[index]);\n      }\n    }\n  }\n  return newObject;\n};\n"
  },
  {
    "__docId__": 161,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "bibTexParser",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": null,
    "description": "homemade bibTeX syntax parser (performance could be improved I guess)\nit needs a second pass to parse {} in values and analyze them against a model - that should be done elsewhere, as this converter just deals with syntax-to-object conversion",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 162,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#constructor",
    "access": null,
    "description": "constructor",
    "lineNumber": 14,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 163,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "STATES",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#STATES",
    "access": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "testing",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#testing",
    "access": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "addValue",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#addValue",
    "access": null,
    "description": "Adds a key+value prop to the resource's javascript representation object",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the resource representation"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the key to populate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "newObj - the updated resource representation"
    },
    "generator": false
  },
  {
    "__docId__": 166,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "consume",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#consume",
    "access": null,
    "description": "Consumes a string (stored in this.consumable) representation of a bibTeX expression",
    "lineNumber": 42,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "exit - a simple exit trigger (but internal props will have been mutated)"
    },
    "generator": false
  },
  {
    "__docId__": 167,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentObject",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#currentObject",
    "access": null,
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 181,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "parse",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#parse",
    "access": null,
    "description": "Parses a bibTeX string and callbacks a javascript objet",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the string to parse"
      },
      {
        "nullable": null,
        "types": [
          "function(error:error, results:Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 179,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentObject",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#currentObject",
    "access": null,
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "currentState",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#currentState",
    "access": null,
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "results",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#results",
    "access": null,
    "description": null,
    "lineNumber": 196,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "consumable",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#consumable",
    "access": null,
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "initialStr",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#initialStr",
    "access": null,
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "error",
    "memberof": "src/core/converters/bibTexConverter.js~bibTexParser",
    "longname": "src/core/converters/bibTexConverter.js~bibTexParser#error",
    "access": null,
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parser",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~parser",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "type": {
      "types": [
        "bibTexParser"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibTexStr",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~parseBibTexStr",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": "{parseBibTexStr}",
    "description": "Parses a bibTeX string and returns an object",
    "lineNumber": 216,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the bibTeX string to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(error: error, result: Object)"
      ],
      "spread": false,
      "description": "callback - error and the resulting object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "validateBibObject",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~validateBibObject",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 223,
    "undocument": true,
    "params": [
      {
        "name": "bibObject",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 188,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializeBibTexObject",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~serializeBibTexObject",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": "{serializeBibTexObject}",
    "description": "Serializes a javascript object representing a resource or a contextualizer, to a bibTeX-formatted string",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "bibObject",
        "description": "the resource/contextualizer representation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "bibStr - the bibTeX mention as a string"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibAuthors",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~parseBibAuthors",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": "{parseBibAuthors}",
    "description": "Parses a list of authors as they are formatted in bbiTeX statements",
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the bibTeX string to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "authors - the javascript representation of authors as an array"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibContextualization",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~parseBibContextualization",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": "{parseBibContextualization}",
    "description": "Parses a bibTeX-like contextualization statement given as string and returns an object",
    "lineNumber": 364,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputStr",
        "description": "the bibTeX string to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "contextualization - the contextualization object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveNested",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~resolveNested",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 430,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseBibNestedValues",
    "memberof": "src/core/converters/bibTexConverter.js",
    "longname": "src/core/converters/bibTexConverter.js~parseBibNestedValues",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/bibTexConverter.js",
    "importStyle": "{parseBibNestedValues}",
    "description": "Parses bibTeX nested values inside a bibObject",
    "lineNumber": 473,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bibObject",
        "description": "the object to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newObject - the resulting updated object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/documentConverter/cleanNaiveTree.js",
    "memberof": null,
    "longname": "src/core/converters/documentConverter/cleanNaiveTree.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module cleans resources and metadata from a naive (resource concatenated) tree\n * @module converter/documentConverter/cleanNaiveTree\n */\nimport slug from 'slug';\n\n/**\n * Resolves resource and metadata statements from a naive representation of a section\n * @param {Object} params - the cleaning params\n * @param {array} params.errors - the inherited parsing errors to pass along to the next step\n * @param {Object} params.validTree - the tree to clean\n * @param {Object} models - the models to parse the resources with\n * @return {errors: array, validTree: Object} - the possible error, a list of parsing minor errors, and the resulting tree\n */\nexport const cleanNaiveTree = ({errors = [], validTree}, models) =>{\n  const contextualizers = [];\n  const naiveTree = Object.assign({}, validTree);\n  let metadata;\n  const hasResources = naiveTree && naiveTree.resources;\n  // has it a resource file\n  if (hasResources) {\n    naiveTree.resources = naiveTree.resources.filter(function(res) {\n      // catch metadata\n      let validated;\n      // extract contextualizer descriptions\n      if (res.bibType === 'contextualizer') {\n        contextualizers.push(res);\n        return false;\n      }\n      for (const type in models.sectionTypeModels.acceptedTypes) {\n        if (res.bibType === 'peritext' + type) {\n          metadata = res;\n          return false;\n        }\n      }\n\n      if (!validated) {\n        // verify that the resource type are known\n        for (const otherType in models.resourceModels.individual) {\n          if (res.bibType === otherType) {\n            return true;\n          }\n        }\n      }\n      // if not validated, record error and don't take resource\n      if (!validated) {\n        errors.push({\n          type: 'error',\n          preciseType: 'invalidResource',\n          resourceId: res.id,\n          message: 'could not find resource type ' + res.bibType + ' for Resource ID ' + res.id\n        });\n        return false;\n      }\n      return true;\n    });\n  } else naiveTree.resources = [];\n  // populate automatic metadata\n  if (metadata === undefined && naiveTree.name.charAt(0) !== '_') {\n    errors.push({\n      type: 'warning',\n      preciseType: 'metadataNotFound',\n      message: 'no metadata specified for the folder ' + naiveTree.name + ' so it was not taken into account'\n    });\n    // bootstrap a minimal metadata\n    metadata = {\n      bibType: 'peritextinherits',\n      id: slug(naiveTree.name.toLowerCase()),\n      title: naiveTree.name\n    };\n  }\n  // parse children if present\n  if (naiveTree.children && naiveTree.name.charAt(0) !== '_') {\n    naiveTree.children = naiveTree.children.map(child => {\n      return cleanNaiveTree({validTree: child}, models);\n    }).filter((result)=>{\n      return result.validTree !== undefined;\n    })\n    .map((result) =>{\n      return result.validTree;\n    });\n  }\n  const newErrors = (errors.length > 0) ? errors.reverse() : null;\n  return {\n    errors: newErrors,\n    validTree: Object.assign({}, naiveTree, {metadata}, {contextualizers})\n  };\n};\n"
  },
  {
    "__docId__": 194,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "cleanNaiveTree",
    "memberof": "src/core/converters/documentConverter/cleanNaiveTree.js",
    "longname": "src/core/converters/documentConverter/cleanNaiveTree.js~cleanNaiveTree",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/documentConverter/cleanNaiveTree.js",
    "importStyle": "{cleanNaiveTree}",
    "description": "Resolves resource and metadata statements from a naive representation of a section",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the cleaning params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.errors",
        "description": "the inherited parsing errors to pass along to the next step"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.validTree",
        "description": "the tree to clean"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to parse the resources with"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "errors: array, validTree: Object"
      ],
      "spread": false,
      "description": "the possible error, a list of parsing minor errors, and the resulting tree"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/documentConverter/concatTree.js",
    "memberof": null,
    "longname": "src/core/converters/documentConverter/concatTree.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module concatenates fsTree contents according to include statements and resolves cases in which several markdown files are in the same directory\n * @module converter/documentConverter/concatTree\n */\nimport {parseMarkdown as extractIncludes} from './../../converters/markdownIncludesParser';\nimport {map as asyncMap, waterfall} from 'async';\n\nlet resolveFileIncludes;\n\n// Extracts md includes and inline resources descriptions from a file object\nconst populateElementWithIncludes = (child, params, callback) =>{\n  extractIncludes(child.stringContents,\n    {\n      includeWrappingChars: params.templateWrappingCharacters,\n      resWrappingChars: params.inlineResourceDescriptionWrappingCharacters\n    }, function(err, {extracted, cleanStr}) {\n      if (!err) {\n        child.extracted = extracted;\n        child.stringContents = cleanStr;\n      }\n      callback(err, child);\n    });\n};\n\n\n// Produces a nested structure of the included files in a given file\nconst include = (ex, file, mdFilesWithIncludes) =>{\n  let fileIndex;\n  const fileToInclude = mdFilesWithIncludes\n      .find((otherFile, index)=>{\n        if (otherFile.name === ex.statement) {\n          fileIndex = index;\n          return true;\n        }\n      });\n  if (fileToInclude !== undefined) {\n    const fileHasIncludes = fileToInclude\n                              .extracted\n                                .filter((rawExtracted)=>{\n                                  return rawExtracted.type === 'includeStatement';\n                                }).length > 0;\n    if (fileHasIncludes) {\n      resolveFileIncludes(fileToInclude, mdFilesWithIncludes);\n    }\n    file.includes.push(fileToInclude);\n    mdFilesWithIncludes.splice(fileIndex, 1);\n  }\n};\n\n// Monitors the nested including structure population process of a file\nconst doResolveFilesWithIncludes = (file, mdFilesWithIncludes) =>{\n  file.includes = [];\n  file.includeStatements = [];\n  for (let index = file.extracted.length - 1; index >= 0; index--) {\n    const ex = file.extracted[index];\n    if (ex.type === 'includeStatement') {\n      include(ex, file, mdFilesWithIncludes);\n      file.extracted.splice(index, 1);\n      file.includeStatements.push(ex);\n    }\n  }\n};\n\nresolveFileIncludes = doResolveFilesWithIncludes;\n\n// Turns non nested file object into include-based nested file objects\nconst nestIncludes = ({resourcesStr, mdFilesWithIncludes, params}, cb) =>{\n\n  mdFilesWithIncludes.forEach((mdfile) =>{\n    resolveFileIncludes(mdfile, mdFilesWithIncludes);\n  });\n  cb(null, {resourcesStr, mdFilesWithIncludes});\n};\n\n\n// Consumes the nested property 'include' by populating its string contents with includes contents,\n// resolved recursively\nconst buildFinalMdContent = (file) =>{\n  let content = file.stringContents;\n  const hasIncludes = file.includes && file.includes.length && file.includes.length > 0;\n  if (hasIncludes) {\n    file.includeStatements\n      .filter((ex)=>{\n        return ex.type === 'includeStatement';\n      })\n      .forEach((ex)=>{\n        const targetIncluded = file.includes.find((file2)=>{\n          return file2.name === ex.statement;\n        });\n        const contentToInclude = buildFinalMdContent(targetIncluded);\n        content = [content.substr(0, ex.index), contentToInclude, content.substr(ex.index)].join('');\n      });\n  }\n\n  return content;\n};\n\n// Turns an array of nested file objects into one single string\nconst resolveNestedIncludes = ({resourcesStr, mdFilesWithIncludes, params}, cb) =>{\n  const contentStr = mdFilesWithIncludes\n                      .reduce((str, file) => {\n                        return str + buildFinalMdContent(file);\n                      }, '');\n  cb(null, {contentStr, resourcesStr, params});\n};\n\nconst concatCustomizers = (newTree) =>{\n  return newTree.children\n      .filter(child => {\n        return child.type === 'directory' && child.name.charAt(0) === '_';\n      })\n      .map(child => {\n        const contents = {};\n        child.children.forEach((subChild) =>{\n          contents[subChild.name] = subChild.stringContents;\n        });\n        return {\n          type: child.name.substr(1),\n          contents\n        };\n      });\n};\n\n/**\n * Turns a fsTree into a dumTree, that is to say a tree which presents .bib resources and .md files contents concatenated by folder (according to inner 'include' statements and then automatically)\n * @param {Object} tree - the fsTree to concatenate\n * @param {Object} params - the language-related parameters\n * @return {errors: Array, dumbTree: Object}  - error and the concatenated tree\n */\nexport const concatTree = (tree, params) =>{\n  const newTree = Object.assign({}, tree);\n  // concat .bib res files\n  const resources = newTree.children\n                    .filter(child => {\n                      return child.type === 'file' && child.extname === '.bib';\n                    })\n                    .reduce((str, child) => {\n                      if (child.stringContents !== undefined) {\n                        return str + '\\n' + child.stringContents;\n                      }\n                      return str;\n                    }, '');\n\n  const mdContents = newTree.children\n                    .filter(child => {\n                      return child.type === 'file' && child.extname === '.md';\n                    });\n  const childrenDirs = newTree.children\n                    .filter(child => {\n                      return child.type === 'directory' && child.name.charAt(0) !== '_';\n                    });\n  const childrenCustomizers = concatCustomizers(newTree);\n  waterfall([\n    // extract md files elements includes statements\n    (cb) =>{\n      asyncMap(mdContents, (child, cback) =>{\n        populateElementWithIncludes(child, params, cback);\n      }, (err, mdFilesWithIncludes) =>{\n        // concat extracted bibtex resources\n        const resourcesStr = mdFilesWithIncludes\n                      .reduce((str, mdFile) => {\n                        let newStr = str;\n                        mdFile.extracted\n                          .filter((ex)=>{\n                            return ex.type === 'resourceStatement';\n                          }).forEach((ex)=>{\n                            newStr += ex.statement;\n                          });\n                        return newStr;\n                      }, resources);\n        cb(null, {resourcesStr, mdFilesWithIncludes, params});\n      });\n    },\n    nestIncludes,\n    resolveNestedIncludes\n  ], (err, {resourcesStr, contentStr}) =>{\n    newTree.resourcesStr = resourcesStr;\n    newTree.contentStr = contentStr;\n    if (childrenCustomizers.length > 0) {\n      newTree.customizers = childrenCustomizers;\n    }\n    // recursively repeat dat stuff with children dirs\n    newTree.children = childrenDirs.map(dir => {\n      return concatTree(dir, params).dumbTree;\n    });\n  });\n  return {dumbTree: newTree, errors: []};\n};\n"
  },
  {
    "__docId__": 196,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "populateElementWithIncludes",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~populateElementWithIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "include",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~include",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doResolveFilesWithIncludes",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~doResolveFilesWithIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nestIncludes",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~nestIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "buildFinalMdContent",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~buildFinalMdContent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveNestedIncludes",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~resolveNestedIncludes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "concatCustomizers",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~concatCustomizers",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "concatTree",
    "memberof": "src/core/converters/documentConverter/concatTree.js",
    "longname": "src/core/converters/documentConverter/concatTree.js~concatTree",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/documentConverter/concatTree.js",
    "importStyle": "{concatTree}",
    "description": "Turns a fsTree into a dumTree, that is to say a tree which presents .bib resources and .md files contents concatenated by folder (according to inner 'include' statements and then automatically)",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tree",
        "description": "the fsTree to concatenate"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the language-related parameters"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "errors: Array, dumbTree: Object"
      ],
      "spread": false,
      "description": "error and the concatenated tree"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/documentConverter/index.js",
    "memberof": null,
    "longname": "src/core/converters/documentConverter/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module converts an fsTree flatfile abstraction to a peritext document representation\n * And it converts aperitext document representation to an fsTree flatfile abstraction\n * @module converters/documentConverter\n */\n\nimport {concatTree} from './concatTree';\nimport {parseTreeResources} from './parseTreeResources';\nimport {organizeTree} from './organizeTree';\nimport {propagateData} from './propagateData';\nimport {cleanNaiveTree} from './cleanNaiveTree';\nimport {getResourceModel, serializePropAgainstType} from './../../utils/modelUtils';\nimport {resolveSectionAgainstModels} from './../../resolvers/resolveSectionAgainstModels';\nimport {resolveResourcesAgainstModels} from './../../resolvers/resolveResourcesAgainstModels';\nimport {resolveBindings} from './../../resolvers/resolveContextualizations';\nimport {markdownToJsAbstraction} from '../markdownConverter';\nimport {serializeBibTexObject, parseBibNestedValues} from '../bibTexConverter';\n\nconst sectionListToFsTree = (inputSectionList, basePath) =>{\n  const sectionList = inputSectionList.map((section)=>{\n    const folderTitle = section.id;\n    const relPath = (section.root) ? '' : folderTitle;\n    const children = [\n      {\n        type: 'file',\n        extname: '.md',\n        name: 'contents.md',\n        path: relPath + '/contents.md',\n        'stringContents': section.markdownContent\n      },\n      {\n        type: 'file',\n        extname: '.bib',\n        name: 'resources.bib',\n        path: relPath + '/resources.bib',\n        'stringContents': section.bibResources\n      }\n      // todo: customizers\n    ];\n    const folder = {\n      type: 'directory',\n      name: section.id,\n      extname: '',\n      path: relPath + '/',\n      root: section.root,\n      children\n    };\n    return folder;\n  });\n\n  const root = sectionList.find((section)=>{\n    return section.root;\n  });\n  const children = sectionList.filter((section)=>{\n    return !section.root;\n  });\n  delete root.root;\n  root.children = root.children.concat(children);\n  root.name = basePath.split('/').pop();\n  return root;\n};\n\nconst serializeMetadata = (metadata, models) => {\n  const obj = {};\n  Object.keys(metadata).forEach(domain => {\n    Object.keys(metadata[domain]).forEach(gKey => {\n      const prop = metadata[domain][gKey];\n      if (gKey === 'bibType' || !prop.inheritedVerticallyFrom && !prop.inheritedHorizontallyFrom) {\n        // format prop name like twitter_title\n        const key = domain === 'general' ? gKey : domain + '_' + gKey;\n        const model = models.metadataModels[domain][gKey];\n        if (model) {\n          obj[key] = serializePropAgainstType(prop.value, model.valueType, model);\n        } else obj[key] = prop.value;\n      }\n    });\n  });\n  obj.bibType = 'peritext' + obj.bibType;\n  return serializeBibTexObject(obj);\n};\n\nconst concatSection = (section, models) =>{\n  const metadataStr = serializeMetadata(section.metadata, models);\n  return {\n    markdownContent: section.markdownContents,\n    bibResources: metadataStr,\n    customizers: section.customizers,\n    id: section.metadata.general.id.value\n  };\n};\n\n// from documentSectionsList to fsTree\n/**\n * Converts a sections' list to a fsTree representation of the resulting sourcedata\n * @param {Object} param - serializing params\n * @param {array} param.sectionList - the list of sections to serialize\n * @param {Object} param.models - the models to use for serializing\n * @param {string} param.basePath - the path to use as basis for determining serializing output paths\n * @return {Object} - returns the filesystem representation of the data\n */\nexport const serializeDocument = ({document, models, basePath}, callback) =>{\n  const sections = Object.keys(document.sections).map(key => document.sections[key]);\n  // collect resources and prepare for serialization\n  const resources = Object.keys(document.resources)\n    .map(key => document.resources[key])\n    .filter((resource)=>{\n      return !resource.inheritedVerticallyFrom;\n    })\n    .map((resource) =>{\n      const modelList = getResourceModel(resource.bibType, models.resourceModels);\n      if (modelList) {\n        let model;\n        return Object.keys(resource).reduce((obj, key) =>{\n          if (resource[key] !== undefined) {\n            model = modelList.properties.find((thatModel)=>{\n              return thatModel.key === key;\n            });\n            if (model) {\n              obj[key] = serializePropAgainstType(resource[key], model.valueType, model);\n            } else obj[key] = resource[key];\n          }\n\n          return obj;\n        }, {});\n      }\n      return resource;\n    });\n  // collect contextualizers and prepare for serialization\n  const contextualizers = Object.keys(document.contextualizers)\n    .map(key => document.contextualizers[key])\n    .filter((contextualizer)=>{\n      return contextualizer && !contextualizer.describedInline;\n    }).map((contextualizer)=>{\n      const modelList = getResourceModel(contextualizer.type, models.contextualizerModels);\n      if (modelList) {\n        let model;\n        const cont = Object.keys(contextualizer).reduce((obj, key) =>{\n          if (contextualizer[key] !== undefined) {\n            model = modelList.properties.find((thatModel)=>{\n              return thatModel.key === key;\n            });\n\n            if (model) {\n              obj[key] = serializePropAgainstType(contextualizer[key], model.valueType, model);\n            } else obj[key] = contextualizer[key];\n          }\n          return obj;\n        }, {});\n        cont.bibType = 'contextualizer';\n        return cont;\n      }\n      contextualizer.bibType = 'contextualizer';\n      return contextualizer;\n    });\n  // merge resources and contextualizers in a collection of entities to be rendered as bibTeX\n  const bibResources = resources.concat(contextualizers).map(serializeBibTexObject);\n  // const globalMetadata = serializeMetadata(document.metadata, models);\n  const fsSections = sections.map(section => {\n    return concatSection(section, models);\n  });\n  // adding resources and contextualizers to first section / root\n  fsSections[0].bibResources += bibResources.join('\\n\\n');\n  fsSections[0].root = true;\n  return sectionListToFsTree(fsSections, basePath);\n};\n\n// from fsTree (returned by any connector) to a documentSectionsList usable in app\n/**\n * Parses an fsTree representation and renders a list of sections to be used with peritext exporters or as is\n * @param {Object} params - parsing params\n * @param {Object} params.tree - the input fsTree representation\n * @param {Object} params.parameters - language-related parameters\n * @param {Object} params.parent - a possible existing parent section - to use for inheritance phases - suitable for partial document parsing/re-rendering use cases (like with an editor app)\n * @param {Object} params.models - models to use for parsing the data\n * @param {function(error:error, results: Object)} callback - RCC representation of the contents and parsing errors list for UI\n */\nexport const parseDocument = ({tree, parameters, parent, models}, callback)=> {\n  // concat markdown, resources, styles, templates, components, and resolve includes, producing a clean 'dumb tree'\n  const {dumbTree, errors: dumbTreeErrors} = concatTree(tree, parameters);\n  // parse bibtext to produce resources and metadata props, producing a 'naive tree' of sections\n  const {naiveTree, errors: naiveTreeErrors} = parseTreeResources(dumbTree);\n  // validate and resolve metadata against their models for all sections\n  const {validTree, errors: validTreeErrors} = cleanNaiveTree({validTree: naiveTree}, models);\n  // bootstrap errors list\n  let errors = dumbTreeErrors.concat(naiveTreeErrors).concat(validTreeErrors);\n  // format objects, normalize metadata, and resolve organization statements\n  const {document: organizedDocument, errors: documentErrors} = organizeTree({errors, validTree});\n  // propagate resources, metadata and customizers vertically (from parents to children sections), metadata lateraly (from metadata models propagation data)\n  const {document: richDocument, errors: richErrors} = propagateData({errors: documentErrors, document: organizedDocument, models, parent});\n  // resolve data against their models\n  const {newResources, newErrors: resErrors} = resolveResourcesAgainstModels(richDocument.resources, models);\n  richDocument.resources = newResources;\n  errors = errors.concat(richErrors).concat(resErrors);\n  // resolve sections against models\n  for (const id in richDocument.sections) {\n    if (richDocument.sections[id]) {\n      const section = richDocument.sections[id];\n      const { newErrors: sectionErrors, newSection } = resolveSectionAgainstModels(section, models);\n      errors = errors.concat(sectionErrors);\n      delete newSection.resources;\n      richDocument.sections[id] = newSection;\n    }\n  }\n  // resolve contextualizers nested values\n  for (const id in richDocument.contextualizers) {\n    if (richDocument.contextualizers[id]) {\n      richDocument.contextualizers[id] = parseBibNestedValues(richDocument.contextualizers[id]);\n    }\n  }\n  // parse markdown contents and organize them as blocks lists, and parse+resolve contextualization objects\n  richDocument.contextualizations = {};\n  for (const id in richDocument.sections) {\n    if (richDocument.sections[id]) {\n      const {\n        errors: sectionErrors,\n        section,\n        contextualizations,\n        contextualizers\n      } = markdownToJsAbstraction(richDocument.sections[id], parameters);\n      errors = errors.concat(sectionErrors);\n      richDocument.sections[id] = section;\n      richDocument.contextualizers = Object.assign(richDocument.contextualizers, contextualizers);\n      richDocument.contextualizations = Object.assign(richDocument.contextualizations, contextualizations);\n    }\n  }\n  // resolve contextualizers statements against their models\n  const {\n    errors: globalErrors,\n    document: newDocument\n  } = resolveBindings({document: richDocument, models});\n  const document = newDocument;\n  errors = errors.concat(globalErrors).filter(error => error !== null);\n  // update summary and document metadata with root\n  document.metadata = Object.assign({}, document.sections[document.summary[0]].metadata);\n  document.customizers = document.sections[document.summary[0]].customizers;\n  document.forewords = document.sections[document.summary[0]];\n  document.summary = document.summary.slice(1);\n  callback(null, {\n    errors,\n    document\n  });\n};\n"
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "sectionListToFsTree",
    "memberof": "src/core/converters/documentConverter/index.js",
    "longname": "src/core/converters/documentConverter/index.js~sectionListToFsTree",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializeMetadata",
    "memberof": "src/core/converters/documentConverter/index.js",
    "longname": "src/core/converters/documentConverter/index.js~serializeMetadata",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "concatSection",
    "memberof": "src/core/converters/documentConverter/index.js",
    "longname": "src/core/converters/documentConverter/index.js~concatSection",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializeDocument",
    "memberof": "src/core/converters/documentConverter/index.js",
    "longname": "src/core/converters/documentConverter/index.js~serializeDocument",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/documentConverter/index.js",
    "importStyle": "{serializeDocument}",
    "description": "Converts a sections' list to a fsTree representation of the resulting sourcedata",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "param",
        "description": "serializing params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "param.sectionList",
        "description": "the list of sections to serialize"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "param.models",
        "description": "the models to use for serializing"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "param.basePath",
        "description": "the path to use as basis for determining serializing output paths"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "returns the filesystem representation of the data"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseDocument",
    "memberof": "src/core/converters/documentConverter/index.js",
    "longname": "src/core/converters/documentConverter/index.js~parseDocument",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/documentConverter/index.js",
    "importStyle": "{parseDocument}",
    "description": "Parses an fsTree representation and renders a list of sections to be used with peritext exporters or as is",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "parsing params"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.tree",
        "description": "the input fsTree representation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.parameters",
        "description": "language-related parameters"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.parent",
        "description": "a possible existing parent section - to use for inheritance phases - suitable for partial document parsing/re-rendering use cases (like with an editor app)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.models",
        "description": "models to use for parsing the data"
      },
      {
        "nullable": null,
        "types": [
          "function(error:error, results: Object)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "RCC representation of the contents and parsing errors list for UI"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/documentConverter/organizeTree.js",
    "memberof": null,
    "longname": "src/core/converters/documentConverter/organizeTree.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module organizes relations between sections (order, inheritance, generality level)\n * @module converter/documentConverter/organizeTree\n */\n\nconst formatMetadata = (metadataObj) =>{\n  const output = {};\n  let value;\n  let keydetail;\n  let domain;\n  for (let key in metadataObj) {\n    if (metadataObj[key] !== undefined) {\n      value = metadataObj[key];\n      keydetail = key.split('_');\n      domain = (keydetail.length > 1) ? keydetail.shift() : 'general';\n      key = keydetail.join('_');\n      if (output[domain] === undefined) {\n        output[domain] = {};\n      }\n      output[domain][key] = {\n        value\n      };\n    }\n  }\n  return output;\n};\n\nconst flattenSections = (tree) =>{\n  if (tree.children) {\n    const newChildren = tree.children.map(child=>{\n      return Object.assign({}, child, {parent: tree.metadata.id});\n    });\n    const newTree = Object.assign({}, tree);\n    return [\n      newTree,\n      ...newChildren\n    ];\n  }\n  return tree;\n};\n\n\nconst formatSection = (section) =>{\n  const metadata = formatMetadata(section.metadata);\n  let keyedCustomizers;\n  if (section.customizers) {\n    keyedCustomizers = {};\n    section.customizers.forEach((customizer) => {\n      keyedCustomizers[customizer.type] = customizer.contents;\n    });\n  }\n  return {\n    metadata,\n    contents: section.contentStr,\n    resources: section.resources,\n    parent: section.parent,\n    customizers: keyedCustomizers,\n    contextualizers: section.contextualizers\n  };\n};\n\nconst formatSections = (sections) =>{\n  const formattedSections = sections.map(section => {\n    return formatSection(section);\n  });\n  return formattedSections;\n};\n\nconst moveInArray = (inputArray, oldIndex, newIndex)=> {\n  const array = [...inputArray];\n  if (newIndex >= array.length) {\n    let toFill = newIndex - array.length;\n    while ((toFill--) + 1) {\n      array.push(undefined);\n    }\n  }\n  array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);\n  return array;\n};\n\nconst makeRelations = (inputSections) =>{\n  // find parents and predecessors\n  let sections = inputSections.map((inputSection) =>{\n    const section = Object.assign({}, inputSection);\n    // todo : clean the two ways of defining parents (at object root or in metadata)\n    if (section.parent && section.metadata.general.parent === undefined) {\n      section.metadata.general.parent = {value: section.parent};\n    }\n    delete section.parent;\n    if (section.after && section.metadata.general.after === undefined) {\n      section.metadata.general.after = {value: section.after};\n    }\n    delete section.after;\n    return section;\n  });\n  // order sections\n  // move the \"no-after\" sections to the begining of array\n  const hasAfter = sections.filter(section => section.metadata.general.after);\n  const hasNoAfter = sections.filter(section => section.metadata.general.after === undefined);\n  sections = [...hasNoAfter, ...hasAfter];\n  // resolve after statements\n  for (let index = sections.length - 1; index >= 0; index--) {\n    const section = sections[index];\n    // console.log('parsing ', section.metadata.general.id.value, index);\n    if (section.metadata.general.after && section.metadata.general.parent) {\n      let indexAfter;\n      sections.some((section2, thatIndex) =>{\n        const id = section2.metadata.general.id.value;\n        if (section.metadata.general.after.value === id) {\n          indexAfter = thatIndex;\n          return true;\n        }\n      });\n      if (indexAfter !== undefined && index !== indexAfter + 1) {\n        // console.log('put ', section.metadata.general.id.value, index, ' after ', section.metadata.general.after.value, indexAfter);\n        sections = moveInArray(sections, index, indexAfter + 1);\n      } else if (indexAfter === undefined) {\n        console.error(section.metadata.general.id.value,\n          ' is supposed to be after ',\n          section.metadata.general.after.value,\n          ' but this section does not exist');\n      }\n    }\n  }\n  const summary = sections.map(section => section.metadata.general.id.value);\n  const orderedSections = sections.map((section, index) => {\n    if (index > 0 ) {\n      section.metadata.general.after = {\n        value: sections[index - 1].metadata.general.id.value\n      };\n    } else {\n      delete section.metadata.general.after;\n    }\n    return section;\n  });\n  const outputSections = orderedSections.reduce((output, section) => {\n    return Object.assign(output, {[section.metadata.general.id.value]: section});\n  }, {});\n  return {outputSections, summary};\n};\n\n/**\n * Organizes relations between sections\n * @param {Object} params - the organization params\n * @param {array} params.errors - the inherited parsing errors to pass along to next step\n * @param {Object} params.validTree - the tree to process\n * @return {error: error, results: {errors: array, sections: array} - an updated list of parsing errors and updated sections\n */\nexport const organizeTree = ({errors = [], validTree}) => {\n  const flatSections = flattenSections(validTree);\n  const formattedSections = formatSections(flatSections);\n  const {outputSections: sections, summary} = makeRelations(formattedSections);\n  return {\n    document: {\n      sections,\n      summary\n    },\n    errors\n  };\n};\n"
  },
  {
    "__docId__": 211,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "formatMetadata",
    "memberof": "src/core/converters/documentConverter/organizeTree.js",
    "longname": "src/core/converters/documentConverter/organizeTree.js~formatMetadata",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/organizeTree.js",
    "importStyle": null,
    "description": "This module organizes relations between sections (order, inheritance, generality level)",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@module",
        "tagValue": "converter/documentConverter/organizeTree"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "flattenSections",
    "memberof": "src/core/converters/documentConverter/organizeTree.js",
    "longname": "src/core/converters/documentConverter/organizeTree.js~flattenSections",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "formatSection",
    "memberof": "src/core/converters/documentConverter/organizeTree.js",
    "longname": "src/core/converters/documentConverter/organizeTree.js~formatSection",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "formatSections",
    "memberof": "src/core/converters/documentConverter/organizeTree.js",
    "longname": "src/core/converters/documentConverter/organizeTree.js~formatSections",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "moveInArray",
    "memberof": "src/core/converters/documentConverter/organizeTree.js",
    "longname": "src/core/converters/documentConverter/organizeTree.js~moveInArray",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "makeRelations",
    "memberof": "src/core/converters/documentConverter/organizeTree.js",
    "longname": "src/core/converters/documentConverter/organizeTree.js~makeRelations",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/organizeTree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "organizeTree",
    "memberof": "src/core/converters/documentConverter/organizeTree.js",
    "longname": "src/core/converters/documentConverter/organizeTree.js~organizeTree",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/documentConverter/organizeTree.js",
    "importStyle": "{organizeTree}",
    "description": "Organizes relations between sections",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the organization params"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.errors",
        "description": "the inherited parsing errors to pass along to next step"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.validTree",
        "description": "the tree to process"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "error: error, results: {errors: array, sections: array"
      ],
      "spread": false,
      "description": "an updated list of parsing errors and updated sections"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/documentConverter/parseTreeResources.js",
    "memberof": null,
    "longname": "src/core/converters/documentConverter/parseTreeResources.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module parses resources expressions in .bib files representations\n * @module converter/documentConverter/parseTreeResources\n */\nimport {parseBibTexStr} from '../bibTexConverter';\n\n/**\n * Converts dumbTree resources representations (as string) to js objects - recursively do the same for tree's children\n * @param {Object} dumbTree - a semi-parsed representation inbetween an fsTree and a more structured representation\n * @return {errors: Array, naiveTree: Object}  - the output representation\n */\nexport const parseTreeResources = (dumbTree) => {\n  const naiveTree = Object.assign({}, dumbTree);\n  const errors = [];\n  if (naiveTree.resourcesStr) {\n    parseBibTexStr(naiveTree.resourcesStr, function(err, resources) {\n      naiveTree.resources = resources;\n    });\n  }\n  if (naiveTree.children) {\n    naiveTree.children = naiveTree.children.map(child => {\n      return parseTreeResources(child).naiveTree;\n    });\n  }\n  return {\n    naiveTree,\n    errors\n  };\n};\n"
  },
  {
    "__docId__": 219,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseTreeResources",
    "memberof": "src/core/converters/documentConverter/parseTreeResources.js",
    "longname": "src/core/converters/documentConverter/parseTreeResources.js~parseTreeResources",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/documentConverter/parseTreeResources.js",
    "importStyle": "{parseTreeResources}",
    "description": "Converts dumbTree resources representations (as string) to js objects - recursively do the same for tree's children",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "dumbTree",
        "description": "a semi-parsed representation inbetween an fsTree and a more structured representation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "errors: Array, naiveTree: Object"
      ],
      "spread": false,
      "description": "the output representation"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/documentConverter/propagateData.js",
    "memberof": null,
    "longname": "src/core/converters/documentConverter/propagateData.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module handles metadata propagation within and between sections\n * @module converter/documentConverter/propagateData\n */\nimport {metaStringToCouple} from './../../utils/sectionUtils';\n\nconst inheritMetadataFromParent = (section, sectionTypeModels, sections, parentMetadata) => {\n  if (parentMetadata === undefined) {\n    return section;\n  }\n  // set final bibType\n  if (section.metadata.general.bibType.value === 'section') {\n    const parentBibType = parentMetadata.general.bibType.value;\n    const parentModel = sectionTypeModels.acceptedTypes[parentBibType];\n    if (parentModel) {\n      section.metadata.general.bibType = {\n        value: parentModel.childrenType,\n        inheritedVerticallyFrom: parentMetadata.general.id.value\n      };\n    }\n  }\n  // set hierarchical level (parent + 1 or parent + own level)\n  const parentLevel = parentMetadata.general.generalityLevel;\n  const ownLevel = section.metadata.general.generalityLevel;\n  if (parentLevel && ownLevel) {\n    section.metadata.general.generalityLevel.value = +parentLevel.value + ownLevel.value;\n  } else if (parentLevel) {\n    section.metadata.general.generalityLevel = {value: +parentLevel.value + 1};\n  } else {\n    section.metadata.general.generalityLevel = {value: parentLevel.value};\n  }\n  // inherit the rest\n  for (const domain in parentMetadata) {\n    if (parentMetadata[domain]) {\n      for (const key in parentMetadata[domain]) {\n        if (parentMetadata[domain][key]) {\n          // inherit if property does not exist in child\n          if (section.metadata[domain] === undefined || section.metadata[domain][key] === undefined) {\n            if (section.metadata[domain] === undefined) {\n              section.metadata[domain] = {};\n            }\n            section.metadata[domain][key] = {\n              value: parentMetadata[domain][key].value,\n              inheritedVerticallyFrom: parentMetadata.general.id.value\n            };\n          }\n        }\n      }\n    }\n  }\n  // mark metadata as done\n  section.metadataInherited = true;\n  return section;\n};\n\n\nconst doInheritMetadataFromParent = (inputSection, sectionTypeModels, sections) => {\n  let section = Object.assign({}, inputSection);\n  let parent = section.metadata.general.parent;\n  if (parent && !section.metadataInherited) {\n    section.metadataInherited = true;\n    parent = sections[parent.value];\n    // first, make your parent inherit from its parent\n    if (!parent.metadataInherited) {\n      parent = doInheritMetadataFromParent(parent, sectionTypeModels, sections);\n    }\n    // then inherit yourself from your parent\n    section = inheritMetadataFromParent(section, sectionTypeModels, sections, parent.metadata);\n  }\n  section.metadataInherited = true;\n  return section;\n};\n\n\nconst inheritCustomizersFromParent = (section, sections, parentCustomizers, parentKey) => {\n  if (parentCustomizers === undefined) {\n    return section;\n  }else if (section.customizers === undefined) {\n    section.customizers = Object.assign({}, parentCustomizers);\n  }else {\n    for (const index in section.customizers) {\n      if (parentCustomizers[index] !== undefined) {\n        // if customizer is a string (e.g. : css data) append child data after parent data\n        if (typeof section.customizers[index] === 'string') {\n          section.customizers[index] = parentCustomizers[index] + '\\n\\n\\n' + section.customizers[index];\n        }else {\n          for (const jindex in parentCustomizers[index]) {\n            // add customizer from parent (e.g. : template) if not defined in child\n            if (section.customizers[index][jindex] === undefined) {\n              section.customizers[index][jindex] = parentCustomizers[index][jindex];\n            }\n          }\n        }\n      }\n    }\n  }\n  return section;\n};\n\nconst doInheritCustomizersFromParent = (inputSection, sections) => {\n  let section = Object.assign({}, inputSection);\n  let parent = section.metadata.general.parent;\n  if (parent && !section.customizersInherited) {\n    parent = sections[parent.value];\n    // first, make your parent inherit from its parent\n    if (!parent.customizersInherited) {\n      parent = doInheritCustomizersFromParent(parent, sections);\n    }\n    // then inherit yourself from your parent\n    section = inheritCustomizersFromParent(section, sections, parent.customizers, parent.metadata.general.id.value);\n  }\n  section.customizersInherited = true;\n  return section;\n};\n\nconst populateLaterally = (section, models) => {\n  // const toInclude = [];\n  for (const domain in section.metadata) {\n    if (section.metadata[domain]) {\n      for (const key in section.metadata[domain]) {\n        if (section.metadata[domain][key]) {\n          const model = models[domain][key];\n          if (model) {\n            const spreaded = model.propagatesTo.map(metaStringToCouple);\n            spreaded.forEach(sp => {\n              if (section.metadata[sp.domain] === undefined) {\n                section.metadata[sp.domain] = {};\n              }\n              if (section.metadata[sp.domain][sp.key] === undefined) {\n                section.metadata[sp.domain][sp.key] = {\n                  value: section.metadata[domain][key].value,\n                  inheritedHorizontallyFrom: {domain, key}\n                };\n              }\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return section;\n};\n\n/**\n * Populate the metadatas of a list of sections, by applying propagation from parents or inbetween metadata values (e.g. : from twitter domain to open graph domain)\n * @param {Object} params - the params of propagation\n * @param {array} params.errors - the list of errors possibly inherited from previous steps\n * @param {Object} params.document - the document in its current shape (sections litteral object + sumamry)\n * @param {Object} params.models - the models to parse the sections with\n * @param {Object} params.parent - if specified, sections that don't have a parent will all be considered as children of this one (but it won't be parsed itself)\n * @return {errors: array, document: Object} - the new transformation errors and updated document representation\n */\nexport const propagateData = ({\n  errors,\n  document: inputDocument,\n  models\n}) => {\n\n  const document = Object.assign({}, inputDocument);\n  document.resources = {};\n  document.contextualizers = {};\n\n  for (const key in document.sections) {\n    if (document.sections[key]) {\n      const section = document.sections[key];\n      // catch root and desactivate inheritance for this one\n      if (section.metadata.general.parent === undefined) {\n        section.metadata.general.generalityLevel = {value: 1};\n        section.resourcesInherited = true;\n        section.metadataInherited = true;\n        section.customizersInherited = true;\n        section.contextualizersInherited = true;\n      }\n      // clean bibType\n      let newBibType = section.metadata.general.bibType.value;\n      newBibType = newBibType ? newBibType.split('peritext') : [];\n      newBibType = newBibType.length > 1 ? newBibType[1] : newBibType[0];\n      section.metadata.general.bibType.value = newBibType;\n      // add resources to general resources list\n      section.resources.forEach(resource => {\n        if (document.resources[resource.id]) {\n          errors.push({\n            type: 'error',\n            preciseType: 'redundantResource',\n            resourceId: resource.id,\n            message: 'Resource ' + resource.bibType + ' is described more than once'\n          });\n        }\n        document.resources[resource.id] = resource;\n      });\n      // add contextualizers to general resources list\n      section.contextualizers.forEach(contextualizer => {\n        if (document.contextualizers[contextualizer.id]) {\n          errors.push({\n            type: 'error',\n            preciseType: 'redundantContextualizer',\n            resourceId: contextualizer.id,\n            message: 'Contextualizer ' + contextualizer.bibType + ' is described more than once'\n          });\n        }\n        document.contextualizers[contextualizer.id] = contextualizer;\n      });\n      delete section.contextualizers;\n    }\n  }\n  // vertical inheritance process\n  // -> fill with parent metadata, append parent customizers\n  for (const keyVert in document.sections) {\n    if (document.sections[keyVert]) {\n      document.sections[keyVert] = doInheritMetadataFromParent(document.sections[keyVert], models.sectionTypeModels, document.sections);\n      document.sections[keyVert] = doInheritCustomizersFromParent(document.sections[keyVert], document.sections);\n    }\n  }\n  // lateral inheritance process\n  // e.g. twitter ==> dublincore\n  for (const keyLat in document.sections) {\n    if (document.sections[keyLat]) {\n      document.sections[keyLat] = populateLaterally(document.sections[keyLat], models.metadataModels);\n    }\n  }\n\n  // cleaning control properties\n  for (const keyClean in document.sections) {\n    if (document.sections[keyClean]) {\n      const section = document.sections[keyClean];\n      delete section.metadataInherited;\n      delete section.customizersInherited;\n    }\n  }\n  return {errors, document};\n};\n"
  },
  {
    "__docId__": 221,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "inheritMetadataFromParent",
    "memberof": "src/core/converters/documentConverter/propagateData.js",
    "longname": "src/core/converters/documentConverter/propagateData.js~inheritMetadataFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doInheritMetadataFromParent",
    "memberof": "src/core/converters/documentConverter/propagateData.js",
    "longname": "src/core/converters/documentConverter/propagateData.js~doInheritMetadataFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "inheritCustomizersFromParent",
    "memberof": "src/core/converters/documentConverter/propagateData.js",
    "longname": "src/core/converters/documentConverter/propagateData.js~inheritCustomizersFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "doInheritCustomizersFromParent",
    "memberof": "src/core/converters/documentConverter/propagateData.js",
    "longname": "src/core/converters/documentConverter/propagateData.js~doInheritCustomizersFromParent",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "populateLaterally",
    "memberof": "src/core/converters/documentConverter/propagateData.js",
    "longname": "src/core/converters/documentConverter/propagateData.js~populateLaterally",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/documentConverter/propagateData.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "propagateData",
    "memberof": "src/core/converters/documentConverter/propagateData.js",
    "longname": "src/core/converters/documentConverter/propagateData.js~propagateData",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/documentConverter/propagateData.js",
    "importStyle": "{propagateData}",
    "description": "Populate the metadatas of a list of sections, by applying propagation from parents or inbetween metadata values (e.g. : from twitter domain to open graph domain)",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the params of propagation"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.errors",
        "description": "the list of errors possibly inherited from previous steps"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.document",
        "description": "the document in its current shape (sections litteral object + sumamry)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.models",
        "description": "the models to parse the sections with"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.parent",
        "description": "if specified, sections that don't have a parent will all be considered as children of this one (but it won't be parsed itself)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "errors: array, document: Object"
      ],
      "spread": false,
      "description": "the new transformation errors and updated document representation"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/markdownConverter.js",
    "memberof": null,
    "longname": "src/core/converters/markdownConverter.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module resolves markdown contents + peritext-specific assertions (notes, contextualizations, contextualizers)\n * It returns a representation of a section's content as an object containing arrays of: DOM children as js representation, notes, contextualizations, contextualizers\n * @module converters/markdownConverter\n */\nimport marked from 'marked';\nimport {v4} from 'uuid';\nimport {html2json} from 'html2json';\nimport {XmlEntities} from 'html-entities';\nconst entities = new XmlEntities();\nimport {parseBibContextualization} from './bibTexConverter';\n\n// basic marked parser settings\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: true,\n  smartLists: true,\n  smartypants: false\n});\n\nconst eatParamsObject = (str)=> {\n  let index = 0;\n  let wrappingLevel = 0;\n  let paramsObject = '';\n  let inObject = false;\n  let ch;\n  while (index < str.length) {\n    ch = str.charAt(index);\n    if (ch === '{') {\n      wrappingLevel++;\n    }else if (ch === '}') {\n      wrappingLevel--;\n    }\n\n    if (!inObject && wrappingLevel > 0) {\n      inObject = true;\n      paramsObject += ch;\n    } else if (inObject && wrappingLevel === 0) {\n      paramsObject += ch;\n      return paramsObject;\n    } else if (inObject) {\n      paramsObject += ch;\n      // not in object, character is neither a wrapper nor a whitespace, leave\n    } else if (!inObject && ch.match(/([\\s])/) === null) {\n      return undefined;\n    }\n    index++;\n  }\n  return undefined;\n};\n\nconst parseParamsObject = (paramsObject)=> {\n  /*\n   * analyse contextualizer statement\n  */\n  let overloading;\n  let contextualizerKey;\n  // case : explicit call to a contextualizer ==> explicit contextualizer overload case\n  if (paramsObject && paramsObject.indexOf('@') === 1) {\n    contextualizerKey = paramsObject.match(/^\\{(@[^,}]+)/)[1];\n    overloading = contextualizerKey;\n  }\n  // else case : no explicit call to a contextualizer ==> inline implicit contextualization, determine id automatically\n  contextualizerKey = 'contextualization-' + v4();\n\n  let formattedParams;\n  if (paramsObject !== undefined) {\n    formattedParams = parseBibContextualization(paramsObject);\n    const emptyParams = JSON.stringify(formattedParams).length <= 2;\n    // not empty = params present, so inline (implicit new contextualizer, or contextualizer overloading)\n    if (!emptyParams) {\n      formattedParams.describedInline = true;\n    // case : no additionnal params ==> no parameters\n    } else {\n      formattedParams = {};\n    }\n  // case : no mention of a contextualizer fully implicit contextualizer (no contextualizer specified)\n  } else {\n    formattedParams = {};\n    formattedParams.describedInline = true;\n    formattedParams.fullyImplicit = true;\n  }\n  // case : a contextualizer has been mentionned, with additionnal contextualization params --> contextualizer overloading\n  if (overloading) {\n    formattedParams.overloading = overloading;\n  }\n  formattedParams.id = contextualizerKey;\n  return formattedParams;\n};\n\nconst parseContextualizations = (section)=> {\n  let replaced = section.contents;\n  const contextualizations = {};\n  const newContextualizers = {};\n  const orderedContextualizations = [];\n  const statementsRE = /(\\!)?\\[([^\\]]*)\\]\\(([^\\)]+)\\)/g;\n  let match;\n  let type;\n  let resources;\n  let paramsObject;\n\n  while ((match = statementsRE.exec(replaced)) !== null) {\n    /*\n     * retrieve data from markdown expressions\n     */\n    // hyperlink markdown syntax stands for inline contextualization\n    // image markdown syntax stands for block contextualization\n    // ()[] => inline, !()[] => block\n    type = match[1] ? 'block' : 'inline';\n    // contents\n    // quoted resources\n    resources = match[3].split(',').map(resKey => resKey.substr(1));\n    const contextualizationId = 'contextualization-' + v4();\n    // following parameters\n    paramsObject = eatParamsObject(replaced.substr(match.index + match[0].length));\n    // UPDATE TEXT\n    // delete paramsObject from text\n    if (paramsObject) {\n      replaced = replaced.replace(replaced.substring(match.index + match[0].length, match.index + match[0].length + paramsObject.length), '');\n    }\n    // update reference in <a> link or <image>\n    replaced = replaced.replace(replaced.substring(match.index + match[0].indexOf(match[3]), match.index + match[0].indexOf(match[3]) + match[3].length), contextualizationId);\n    // UPDATE DATA\n    const contextualizer = parseParamsObject(paramsObject);\n    if (contextualizer) {\n      newContextualizers[contextualizer.id] = contextualizer;\n    }\n    contextualizations[contextualizationId] = {\n      'id': contextualizationId,\n      contextualizer: contextualizer.id,\n      resources,\n      type\n    };\n    orderedContextualizations.push(contextualizationId);\n  }\n  return {md: replaced, orderedContextualizations, contextualizations, contextualizers: newContextualizers};\n};\n\n\n// this module does not use a regex-based method\n// because it must catch possible nested content-related \"{\" brackets symbols\n// e.g. : this is an {example inside brackets}\nconst parseNotes = (md, sectionId)=> {\n  const notes = [];\n  let noteNumber = 1;\n  let index = 0;\n  let displace = 0;\n  let beginIndex;\n  let nestingLevel = 0;\n  let ch;\n  let newMd = md;\n  let noteContent;\n  while (newMd.substr(displace).indexOf('[^]{') > -1) {\n    index = displace + newMd.substring(displace).indexOf('[^]{') + 4;\n    beginIndex = index;\n    nestingLevel = 1;\n\n    while (index < newMd.length && nestingLevel > 0) {\n      ch = newMd.charAt(index);\n      if (ch === '{') {\n        nestingLevel++;\n      } else if (ch === '}') {\n        nestingLevel--;\n      }\n      index++;\n    }\n\n    noteContent = newMd.substring(beginIndex, index - 1);\n    const id = 'note-' + sectionId + '-' + v4();// noteNumber;\n    const placeholder = `[footnote](note_${id})`;\n    const initialLength = index - beginIndex + 4;\n    const lengthDif = initialLength - placeholder.length;\n    newMd = newMd.replace(newMd.substring(beginIndex - 4, index), placeholder);\n    notes.push({\n      noteNumber,\n      markdownContents: noteContent,\n      id\n    });\n    noteNumber++;\n    displace = index - lengthDif;\n  }\n  return {\n    notes,\n    newMd\n  };\n};\n// for recursivity matter\nlet mapMdJsonToPJson = ()=>{return undefined;};\nlet representContents = ()=>{return undefined;};\n\nmapMdJsonToPJson = (inputElement, contextualizations, elementPath) =>{\n  const element = Object.assign({}, inputElement);\n  if (element.text) {\n    element.text = entities.decode(element.text);\n  }\n  if (element.tag === 'a') {\n    if (element.attr.href.indexOf('note_') === 0) {\n      element.tag = 'note';\n      element.target = element.attr.href.substr(5);\n    // case of an inline contextualization\n    } else {\n      element.tag = 'inlineC';\n      const contextualizationId = element.attr.href;\n      const contextualization = contextualizations[contextualizationId];\n      contextualization.nodePath = elementPath;\n    }\n  // case of a block contextualization\n  } else if (element.tag === 'img') {\n    element.tag = 'blockC';\n    const contextualizationId = element.attr.src;\n    const contextualization = contextualizations[contextualizationId];\n    contextualization.nodePath = elementPath;\n    let contents = (element.attr && element.attr.alt) ? element.attr.alt : '';\n    contents = contents.join !== undefined ? contents.join(' ') : contents;\n    element.children = [representContents(contents, contextualizations, elementPath)[0]];\n    delete element.attr;\n  }\n  if (element.child) {\n    element.children = element.child.map((child, elementIndex)=>{\n      return mapMdJsonToPJson(child, contextualizations, elementPath.concat(['children', elementIndex]));\n    });\n    delete element.child;\n  }\n  return element;\n};\n\nrepresentContents = (mdContent, contextualizations, elementPath) =>{\n  return html2json(marked(mdContent)).child.map((child, blockIndex)=> {\n    return mapMdJsonToPJson(child, contextualizations, elementPath.concat(blockIndex));\n  });\n};\n\n/**\n * Parses markdown contents in order to update section data with new contents (as a pseudo-DOM nested javascript object representation), notes, contextualizers and contextualizations\n * @param {Object} section - the section to parse\n * @param {Object} parameters - deprecated - rendering parameters (not used at this step)\n * @return {errors: array, section: Object} - the resulting conversion errors and updated section\n */\nexport const markdownToJsAbstraction = (section, parameters)=> {\n  const errors = [];\n\n  const sectionId = section.metadata.general.id.value;\n  // save original markdown expression of contents (for further possible serializing)\n  section.markdownContents = section.contents;\n  // first extract contextualizations statements\n  const {\n    md,\n    contextualizers,\n    orderedContextualizations,\n    contextualizations\n  } = parseContextualizations(section);\n  // then extract notes statements\n  const {\n    notes,\n    newMd\n  } = parseNotes(md, sectionId);\n  section.contextualizations = orderedContextualizations;\n  // convert cleaned markdown contents to js representation\n  section.contents = representContents(newMd, contextualizations, [sectionId, 'contents']);\n  section.notes = notes.map((note, noteIndex) =>{\n    const contents = html2json(marked(note.markdownContents)).child.map((child, blockIndex)=> {\n      return mapMdJsonToPJson(child, contextualizations, [sectionId, 'notes', noteIndex]);\n    });\n    return Object.assign(note, {\n      children: [\n        // this is dirty, done for matching contextualization nodePath which is displaced otherwise\n        // other dirty solution : handle that in mapMdJsonToPJson with a path check\n        // (if in notes prop => decrement contextualization target)\n        { node: 'text',\n          text: ''\n        },\n        ...contents[0].children\n      ]\n    });\n  });\n  return {errors, section, contextualizers, contextualizations};\n};\n"
  },
  {
    "__docId__": 228,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "entities",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~entities",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "html-entities~XmlEntities"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "eatParamsObject",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~eatParamsObject",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseParamsObject",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~parseParamsObject",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseContextualizations",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~parseContextualizations",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseNotes",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~parseNotes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mapMdJsonToPJson",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~mapMdJsonToPJson",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 192,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "representContents",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~representContents",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "markdownToJsAbstraction",
    "memberof": "src/core/converters/markdownConverter.js",
    "longname": "src/core/converters/markdownConverter.js~markdownToJsAbstraction",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/markdownConverter.js",
    "importStyle": "{markdownToJsAbstraction}",
    "description": "Parses markdown contents in order to update section data with new contents (as a pseudo-DOM nested javascript object representation), notes, contextualizers and contextualizations",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to parse"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parameters",
        "description": "deprecated - rendering parameters (not used at this step)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "errors: array, section: Object"
      ],
      "spread": false,
      "description": "the resulting conversion errors and updated section"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/converters/markdownIncludesParser.js",
    "memberof": null,
    "longname": "src/core/converters/markdownIncludesParser.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * This module analyses special markdown insertions (includes and resources)\n * Takes a peritext-markdown string + syntax params as input\n * Parses inline resources expressions\n * Parses ``include`` statements\n * Returns cleaned string, plus a list of include statements and resources to parse\n * @module converters/markdownIncludesParser\n */\n\nconst regexEscape = function(str) {\n  return str.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\n/**\n * Parses markdown string for markdown files includes statements and inline resources descriptions\n * @param {string} str - the string to parse\n * @param {Object} expressions - the wrapping expressions to use in order to parse includes and inline resources\n * @param {function(error: error, results: {extracted: array, cleanStr: string})} - callback - returns error, results as an array of extracted statements and clean string (without statements)\n */\nexport const parseMarkdown = (str, {includeWrappingChars, resWrappingChars}, callback) => {\n  const includesRegexp = new RegExp(regexEscape(includeWrappingChars[0]) + 'include:([^\\\\\\}]+)' + regexEscape(includeWrappingChars[1]), 'g');\n  const resourcesRegexp = new RegExp(regexEscape(resWrappingChars[0]) + '\\\\\\n([\\\\\\w\\\\\\W]+)\\\\\\n' + regexEscape(resWrappingChars[1]), 'g');\n  let extracted = [];\n  let cleanStr = str;\n  let match;\n  let extr;\n\n  // recursively check for one of the two substitution expressions\n  while (((match = resourcesRegexp.exec(cleanStr)) !== null) || ((match = includesRegexp.exec(cleanStr)) !== null)) {\n    // if match, swipe out original statement\n    cleanStr = [cleanStr.substr(0, match.index - 1), cleanStr.substr(match.index + match[0].length)].join('');\n    // save statement position and type\n    extr = {\n      index: match.index,\n      statement: match[1]\n    };\n    if (match[0].match(resourcesRegexp)) {\n      extr.type = 'resourceStatement';\n    }else if (match[0].match(includesRegexp)) {\n      extr.type = 'includeStatement';\n    }\n    // update other statements' position that would be further in string\n    extracted = extracted.map((ex) => {\n      if (ex.index > extr.index) {\n        ex.index -= match[0].length + 1;\n      }\n      return ex;\n    });\n    extracted.push(extr);\n  }\n\n  // reverse sort (for further string substitution operations)\n  extracted = extracted.sort((one, two) =>{\n    if (one.index > two.index) {\n      return -1;\n    }\n    return 1;\n  });\n  return callback(null, {extracted, cleanStr});\n};\n"
  },
  {
    "__docId__": 237,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "regexEscape",
    "memberof": "src/core/converters/markdownIncludesParser.js",
    "longname": "src/core/converters/markdownIncludesParser.js~regexEscape",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/converters/markdownIncludesParser.js",
    "importStyle": null,
    "description": "This module analyses special markdown insertions (includes and resources)\nTakes a peritext-markdown string + syntax params as input\nParses inline resources expressions\nParses ``include`` statements\nReturns cleaned string, plus a list of include statements and resources to parse",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@module",
        "tagValue": "converters/markdownIncludesParser"
      }
    ],
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 238,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseMarkdown",
    "memberof": "src/core/converters/markdownIncludesParser.js",
    "longname": "src/core/converters/markdownIncludesParser.js~parseMarkdown",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/converters/markdownIncludesParser.js",
    "importStyle": "{parseMarkdown}",
    "description": "Parses markdown string for markdown files includes statements and inline resources descriptions",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the string to parse"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "expressions",
        "description": "the wrapping expressions to use in order to parse includes and inline resources"
      },
      {
        "nullable": null,
        "types": [
          "function(error: error, results: {extracted: array, cleanStr: string})"
        ],
        "spread": false,
        "optional": false,
        "name": "-",
        "description": "callback - returns error, results as an array of extracted statements and clean string (without statements)"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/getters.js",
    "memberof": null,
    "longname": "src/core/getters.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\nexport const getDocument = (document) => Object.assign({}, document);\n\nexport const getDocumentMetadata = (document) => Object.assign({}, document.metadata);\n\nconst packSection = (document, section) => {\n  const mappedContextualizations = section.contextualizations.map(key =>\n    document.contextualizations[key]\n  );\n\n  const contextualizations = mappedContextualizations.reduce((total, item) =>\n    Object.assign(total, {[item.id]: item}), {});\n\n  const contextualizers = mappedContextualizations.map(cont =>\n    document.contextualizers[cont.contextualizer]\n  ).reduce((total, item) =>\n    Object.assign(total, {[item.id]: item}), {});\n  const resources = mappedContextualizations.reduce((res, contextualization) => {\n    return res.concat(contextualization.resources.map((resKey)=>{\n      return document.resources[resKey];\n    }));\n  }, []).reduce((total, item) =>\n      Object.assign(total, {[item.id]: item}), {});\n\n  return Object.assign({},\n    section,\n    {contextualizations},\n    {contextualizers},\n    {resources}\n  );\n};\n\nexport const getSection = (document, id) => {\n  const section = document.sections[id];\n  return packSection(document, section);\n};\n\nexport const getForewords = (document) => {\n  const section = document.forewords;\n  return packSection(document, section);\n};\n\nexport const getTableOfSections = (document) =>\n  document.summary.map(sectionKey =>{\n    const metadata = document.sections[sectionKey].metadata;\n    return {\n      id: metadata.general.id.value,\n      generalityLevel: metadata.general.generalityLevel.value,\n      title: metadata.general.title.value,\n      parent: metadata.general.parent ? metadata.general.parent.value : undefined\n    };\n  });\n\nexport const getTableOfFigures = (document) =>\n  Object.keys(document.contextualizations)\n  .map(key => document.contextualizations[key])\n  .filter(contextualization => contextualization.figureId)\n  .map(contextualization => ({\n    figureId: contextualization.figureId,\n    figureNumber: contextualization.figureNumber,\n    contextualization\n  }));\n\nexport const getResourceContextualizations = (document, resourceId) =>\n  Object.keys(document.contextualizations)\n    .map(key => document.contextualizations[key])\n    .filter(contextualization =>\n      contextualization.resources.indexOf(resourceId) > -1\n    );\n\nexport const getContextualizerContextualizations = (document, contextualizerId) =>\n  Object.keys(document.contextualizations)\n    .map(key => document.contextualizations[key])\n    .filter(contextualization =>\n      contextualization.contextualizer === contextualizerId\n    );\n\nexport const getGlossary = (document) => {\n  const entitiesTypes = ['person', 'place', 'subject', 'concept', 'organization', 'technology', 'artefact'];\n  const sections = Object.keys(document.sections).map(key => document.sections[key]);\n  // get all glossary contextualizations\n  const glossaryPointers = sections.reduce((results, thatSection)=>{\n    const sectionCitekey = thatSection.metadata.general.id.value;\n    return results.concat(\n      thatSection.contextualizations\n      .filter((thatContextualization)=> {\n        return document.contextualizations[thatContextualization].contextualizerType === 'glossary';\n      })\n      .reduce((localResults, contextualizationKey)=> {\n        const contextualization = document.contextualizations[contextualizationKey];\n        const targetBlockPath = contextualization.nodePath.slice(0, 3);\n        return localResults.concat({\n          mentionId: '#peritext-content-entity-inline-' + sectionCitekey + '-' + contextualization.id,\n          entity: document.resources[contextualization.resources[0]].id,\n          alias: document.contextualizers[contextualization.contextualizer].alias,\n          targetBlockPath\n        });\n      }, []));\n  }, []);\n  // regroup related resources\n  const glossaryResources = [];\n  Object.keys(document.resources)\n  .map(refKey => {\n    const thatResource = document.resources[refKey];\n    if (thatResource.inheritedVerticallyFrom === undefined\n        && entitiesTypes.indexOf(thatResource.bibType) > -1\n        ) {\n      glossaryResources.push(thatResource);\n    }\n  });\n  // reduce to have a one-entry-per-entity glossary\n  const glossaryData = glossaryResources.map((inputGlossaryEntry)=> {\n    const glossaryEntry = Object.assign({}, inputGlossaryEntry);\n    // retroup resources\n    glossaryEntry.aliases = glossaryPointers.filter((pointer)=> {\n      return pointer.entity === glossaryEntry.id;\n    }).reduce((aliases, entry)=> {\n      const alias = entry.alias || 'no-alias';\n      aliases[alias] = aliases[alias] ? aliases[alias].concat(entry) : [entry];\n      return aliases;\n    }, {});\n    return glossaryEntry;\n  }).sort((entry1, entry2)=> {\n    return (entry1.name || entry1.lastname) > (entry2.name || entry2.lastname) ? 1 : -1;\n  });\n  return glossaryData;\n};\n"
  },
  {
    "__docId__": 240,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getDocument",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getDocument",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getDocument}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getDocumentMetadata",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getDocumentMetadata",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getDocumentMetadata}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "packSection",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~packSection",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getSection",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getSection",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getSection}",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getForewords",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getForewords",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getForewords}",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getTableOfSections",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getTableOfSections",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getTableOfSections}",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getTableOfFigures",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getTableOfFigures",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getTableOfFigures}",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getResourceContextualizations",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getResourceContextualizations",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getResourceContextualizations}",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getContextualizerContextualizations",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getContextualizerContextualizations",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getContextualizerContextualizations}",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getGlossary",
    "memberof": "src/core/getters.js",
    "longname": "src/core/getters.js~getGlossary",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/getters.js",
    "importStyle": "{getGlossary}",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/models/index.js",
    "memberof": null,
    "longname": "src/core/models/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Models - default models used along the library\n * @module models\n */\n\n/**\n * models of peritext sections metadata\n */\nexport const metadataModels = require('./metadataModels.json');\n/**\n * models of peritext resources\n */\nexport const resourceModels = require('./resourceModels.json');\n/**\n * models of possible peritext sections bibType and their inheritance rules\n */\nexport const sectionTypeModels = require('./sectionTypeModels.json');\n/**\n * models of peritext contextualizers\n */\nexport const contextualizerModels = require('./contextualizerModels.json');\n/**\n * models of peritext (possible, and default) rendering settings\n */\nexport const settingsModels = require('./settingsModels.json');\n"
  },
  {
    "__docId__": 251,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "metadataModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~metadataModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{metadataModels}",
    "description": "models of peritext sections metadata",
    "lineNumber": 9,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 252,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resourceModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~resourceModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{resourceModels}",
    "description": "models of peritext resources",
    "lineNumber": 13,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 253,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "sectionTypeModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~sectionTypeModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{sectionTypeModels}",
    "description": "models of possible peritext sections bibType and their inheritance rules",
    "lineNumber": 17,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 254,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contextualizerModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~contextualizerModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{contextualizerModels}",
    "description": "models of peritext contextualizers",
    "lineNumber": 21,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "settingsModels",
    "memberof": "src/core/models/index.js",
    "longname": "src/core/models/index.js~settingsModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/models/index.js",
    "importStyle": "{settingsModels}",
    "description": "models of peritext (possible, and default) rendering settings",
    "lineNumber": 25,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/htmlMetaTemplateSerializer.js",
    "memberof": null,
    "longname": "src/core/resolvers/htmlMetaTemplateSerializer.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve metadata templates against their data\n * @module resolvers/htmlMetaTemplateSerializer\n */\n\n// templates have two variables : ${key} and ${value}\n// if value is an array\n// modificators are specifed after commas\n// modificators : join(), personsToString\n\n/**\n * Consumes a metadata object against an html metadata node template\n * @param {Object} metadata - the metadata object\n * @param {string} template - the template to consumes\n * @return {string} htmlMeta - the representation of the html metadata as string\n */\nexport const serializeHtmlMeta = (metadata, key, template) => {\n  let transformationAction = template.match(/\\${value:([^}]*)/);\n  let transformationArgument;\n  let value;\n  if (transformationAction) {\n    transformationAction = transformationAction[1];\n    if (transformationAction.indexOf('join(') === 0) {\n      try {\n        transformationArgument = transformationAction.match(/join\\(([^\\)]*)\\)/)[1];\n      }catch (exception) {\n        transformationArgument = ', ';\n      }\n    }\n  }\n\n  if (transformationAction === 'join' && Array.isArray(metadata.value)) {\n    value = metadata.value.join(transformationArgument);\n  }else if (transformationAction === 'personsToString' && Array.isArray(metadata.value)) {\n    const persons = metadata.value.map((person)=>{\n      return (person.firstName) ? person.firstName + ' ' + person.lastName : person.lastName;\n    });\n    value = persons.join(', ');\n  }else value = metadata.value;\n  let output = template;\n  while (output.indexOf('${value') > -1) {\n    output = output.replace('${key}', key).replace(/\\${value:?([^}]*)?}/, value);\n  }\n  return output;\n};\n"
  },
  {
    "__docId__": 257,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializeHtmlMeta",
    "memberof": "src/core/resolvers/htmlMetaTemplateSerializer.js",
    "longname": "src/core/resolvers/htmlMetaTemplateSerializer.js~serializeHtmlMeta",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/htmlMetaTemplateSerializer.js",
    "importStyle": "{serializeHtmlMeta}",
    "description": "Consumes a metadata object against an html metadata node template",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "metadata",
        "description": "the metadata object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "template",
        "description": "the template to consumes"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "htmlMeta - the representation of the html metadata as string"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/resolveContextualizations.js",
    "memberof": null,
    "longname": "src/core/resolvers/resolveContextualizations.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve  contextualization statements\n * @module resolvers/resolveContextualizations\n */\n\nimport {getResourceModel, getContextualizerModel, resolvePropAgainstType} from '../utils/modelUtils';\nimport * as contextualizerLibs from '../../contextualizers';\n/**\n * Transforms 1, 2, 3 ordinally used number into a, b, c ordinally used letters\n * @param {number} num - the number to transform\n * @return {string} letter - the output letter\n */\nexport const numbersToLetters = (num) =>{\n  const mod = num % 26;\n  let pow = num / 26 | 0;\n  const out = mod ? String.fromCharCode(64 + mod) : (--pow, 'Z');\n  return pow ? numbersToLetters(pow) + out : out.toLowerCase();\n};\n\n/**\n * Resolves a contextualizer object against its model and context, and records errors\n * @param {object} contextualizer - the contextualizer to resolve\n * @param {object} contextualization - the contextualization to use as a clue-giver if the contextualizer is implicit\n * @param {object} section - the section to which the contextualizer belongs\n * @param {object} models - the models to parse the contextualizer against\n * @return {{err: error, contextualizer: Object}} result - parsing errors and final contextualizer\n */\nconst resolveContextualizer = (contextualizer, contextualization, contextualizers, resources, models) =>{\n  const err = [];\n  let newContextualizer = Object.assign({}, contextualizer);\n  // if overloading, first fetch the existing contextualizer\n  if (newContextualizer.overloading) {\n    const overload = newContextualizer.overloading.replace(/^@/, '');\n    // find original\n    const original = contextualizers[overload];\n    // resolve original first\n    if (original) {\n      const originalFormatted = resolveContextualizer(original, contextualization, contextualizers, resources, models).finalContextualizer;\n      // overload inherited params with new ones\n      newContextualizer = Object.assign(originalFormatted, newContextualizer);\n    } else {\n      // no original found ==> overloading reference error\n      err.push({\n        type: 'error',\n        preciseType: 'invalidContextualizer',\n        message: 'overloading reference error: contextualizer ' + newContextualizer.id + ' should overload ' + overload + ' but the original contextualizer does not exist'\n      });\n    }\n  }\n  // guess contextualizer type if needed\n  if (!newContextualizer.type) {\n    if (contextualization.resources.length > 0) {\n      const sourceKey = contextualization.resources[0];\n      const source = resources[sourceKey];\n      if (source === undefined) {\n        err.push({\n          type: 'error',\n          preciseType: 'invalidContextualizer',\n          message: 'contextualizer ' + newContextualizer.id + ' (' + newContextualizer.type + ') does not provide a valid resource'\n        });\n        return {err, undefined};\n      }\n\n      const sourceModel = getResourceModel(source.bibType, models.resourceModels);\n      newContextualizer.type = sourceModel.defaultContextualizer;\n    }\n  }\n  // resolve contextualizer object against its model\n  const contextualizerModel = getContextualizerModel(newContextualizer.type, models.contextualizerModels);\n  const finalContextualizer = contextualizerModel.properties.reduce((obj, thatModel) =>{\n    obj[thatModel.key] = resolvePropAgainstType(newContextualizer[thatModel.key], thatModel.valueType, thatModel);\n    // record error if required field is undefined\n    if (obj[thatModel.key] === undefined && thatModel.required === true) {\n      err.push({\n        type: 'error',\n        preciseType: 'invalidContextualizer',\n        message: 'contextualizer ' + newContextualizer.id + ' (' + newContextualizer.type + ') does not provide required type ' + thatModel.key\n      });\n    }\n    return obj;\n  }, {});\n  return {err, finalContextualizer};\n};\n\n/**\n * Resolves contextualizations' contextualizer and resource, verifying that contextualization will be possible\n * @param {object} contextualizer - the contextualizer to resolve\n * @param {object} section - the section to resolve\n * @param {object} models - the models to use to validate data\n * @return {errors: array, newSection: Object} callback - returns updated section and possible errors as an array\n */\nexport const resolveBindings = ({document, models}) =>{\n  let errors = [];\n  // find implicit contextualizers types\n  for (const id in document.contextualizations) {\n    if (document.contextualizations[id]) {\n      const contextualization = document.contextualizations[id];\n      // resolve contextualizer (in case of overloading)\n      const {err, finalContextualizer} = resolveContextualizer(document.contextualizers[contextualization.contextualizer], contextualization, document.contextualizers, document.resources, models);\n      if (err.length) {\n        errors = errors.concat(err);\n      } else {\n        contextualization.contextualizer = finalContextualizer.id;\n        document.contextualizers[finalContextualizer.id] = finalContextualizer;\n      }\n      // verify that contextualization has an existing contextualizer\n      if (document.contextualizers[contextualization.contextualizer] === undefined) {\n        errors.push({\n          type: 'error',\n          preciseType: 'invalidContextualization',\n          message: 'contextualizer was not found for contextualization ' + contextualization.id\n        });\n        delete document.contextualizations[contextualization.id];\n      // verify that contextualization uses valid resources (they exist and their type is compatible with contextualizer)\n      } else {\n        let toKeep = true;\n        const contextualizer = document.contextualizers[contextualization.contextualizer];\n        const contextualizerModel = getContextualizerModel(contextualizer.type, models.contextualizerModels);\n        if (contextualizerModel === undefined) {\n          errors.push({\n            type: 'error',\n            preciseType: 'invalidContextualization',\n            message: 'No contextualizer model found for ' + contextualization.contextualizer\n          });\n          toKeep = false;\n        } else {\n          const acceptedResourceTypes = contextualizerModel.acceptedResourceTypes;\n          contextualization.resources.some(resKey =>{\n            const res = document.resources[resKey];\n            // resource exists, check if it is accepted for the contextualizerType\n            if (res !== undefined) {\n              let accepted = false;\n              acceptedResourceTypes.some(type => {\n                if (type === '*' || type === res.bibType) {\n                  accepted = true;\n                  return true;\n                }\n              });\n              if (!accepted) {\n                toKeep = false;\n                errors.push({\n                  type: 'error',\n                  preciseType: 'invalidContextualization',\n                  message: 'resource ' + resKey + ' was asked in a contextualization but is not handled by the contextualizer ' + contextualization.contextualizer\n                });\n              }\n            } else {\n              toKeep = false;\n              errors.push({\n                type: 'error',\n                preciseType: 'invalidContextualization',\n                message: 'resource ' + resKey + ' was asked in a contextualization but was not found'\n              });\n            }\n          });\n        }\n        if (toKeep === false) {\n          delete document.contextualizations[contextualization.id];\n        }\n      }\n    }\n  }\n  return {errors, document};\n};\n\n/**\n * Resolves relations of recurrence, order, and similarity between contextualizations in a section\n * @param {inputDocument} document - the document to resolve\n * @param {object} settings - the rendering settings to apply\n * @return {Object} newDocument - the udpated document\n */\nexport const resolveContextualizationsRelations = (inputDocument, settings) =>{\n  const document = Object.assign({}, inputDocument);\n  let opCitIndex;\n  let sameResPrint;\n  for (const sectionKey in document.sections) {\n    if (document.sections[sectionKey]) {\n      const sectio = document.sections[sectionKey];\n      sectio.contextualizations.forEach((contKey, contIndex) => {\n        sameResPrint = undefined;\n        opCitIndex = undefined;\n        const contextualization = document.contextualizations[contKey];\n        contextualization.resPrint = contextualization.resources.join('-');\n        // find if another contextualization has exactly the same resources set and same section as scope\n        for (const oContKey in document.contextualizations) {\n          // check if this other contextualization\n          // uses the same resources and belong to the same section\n          // and use the same contextualizer type\n          if (oContKey !== contKey\n            // same resources set\n            && document.contextualizations[oContKey].resPrint === contextualization.resPrint\n            // same section\n            && document.contextualizations[oContKey].nodePath[0] === contextualization.nodePath[0]\n            // same contextualizer type\n            && document.contextualizations[oContKey].contextualizerType === contextualization.contextualizerType\n            ) {\n            // if opcit section\n           /* sectio.contextualizations.some((thatKey, thatIndex) => {\n              if (thatKey === oContKey && thatIndex > contIndex) {\n                opCitIndex = thatIndex;\n                return true;\n              }\n              return false;\n            });*/\n            document.sections[contextualization.nodePath[0]].contextualizations.find((oKey2, oIndex)=> {\n              if (oKey2 === oContKey) {\n                opCitIndex = oIndex;\n                return oKey2;\n              }\n            });\n            contextualization.precursorId = document.contextualizations[oContKey].id;\n            sameResPrint = true;\n          }\n        }\n        if (sameResPrint !== undefined) {\n          contextualization.sectionOpCit = true;\n        }\n        // todo opcit document\n\n        // ibid section\n        if (opCitIndex) {\n          // want to check for an ibid (same resource, same contextualizer, subsequent)\n          // must check if opCit and current contextualizations are strictly subsequent\n          const substrate = sectio.contextualizations.slice(opCitIndex, contIndex).filter(intContKey=> {\n            return document.contextualizers[\n                      document.contextualizations[intContKey].contextualizer\n                    ].type === document.contextualizers[contextualization.contextualizer].type;\n          });\n          if (substrate.length === 1) {\n            contextualization.sectionIbid = true;\n          }\n        }\n\n        // todo ibid document\n        // citation specifics\n        if (document.contextualizers[contextualization.contextualizer].type === 'citation') {\n          // same authors but different work in year - section scale\n          contextualization.authorsPrint = document.resources[contextualization.resources[0]].author.reduce((str, author)=> {\n            return str + author.lastName + '-' + author.firstName;\n          }, '');\n          for (const oContKey2 in document.contextualizations) {\n            if (oContKey2 !== contKey\n              // same section\n              && document.contextualizations[oContKey2].nodePath[0] === contextualization.nodePath[0]\n              // different resources set\n              && document.contextualizations[oContKey2].resPrint !== contextualization.resPrint\n              // same authors set\n              && document.contextualizations[oContKey2].authorsPrint === contextualization.authorsPrint\n              // same year\n              && (document.contextualizations[oContKey2].year === contextualization.year\n                  || document.contextualizations[oContKey2].date === contextualization.date)\n              ) {\n              // if same authors/year\n              const cont2 = document.contextualizations[oContKey2];\n              cont2.sameAuthorInYear = cont2.sameAuthorInYear !== undefined ? cont2.sameAuthorInYear ++ : 1;\n              contextualization.sameAuthorInYear = cont2.sameAuthorInYear + 1;\n              contextualization.yearSuffix = numbersToLetters(contextualization.sameAuthorInYear);\n              cont2.yearSuffix = numbersToLetters(cont2.sameAuthorInYear);\n            }\n          }\n          // todo same authors in year but different work - at document scale\n        }\n\n        opCitIndex = undefined;\n      });\n    }\n  }\n  return document;\n};\n\n/**\n * Resolves all the contextualizations of a section by updating its contents pseudo-DOM representation\n * @param {object} contextualization - the contextualization to implement\n * @param {object} document - the document to update\n * @param {string} renderingMode - whether rendering is static or dynamic\n * @param {object} settings - the rendering settings to take into account when resolving contextualizations\n * @return {Object} newDocument - the updated document\n */\nexport const resolveContextualizationImplementation = (contextualization, document, renderingMode, settings) =>{\n  let contextualizer;\n  // console.log('resolving ', contextualization.id);\n  contextualizer = contextualizerLibs[contextualization.contextualizerType];\n  if (contextualizer === undefined) {\n    console.log('no contextualizer function was found for type ', contextualization.contextualizerType);\n    return document;\n  }\n  switch (renderingMode) {\n  case 'static':\n    switch (contextualization.type) {\n    case 'inline':\n      return contextualizer.contextualizeInlineStatic(document, contextualization, settings);\n    case 'block':\n      return contextualizer.contextualizeBlockStatic(document, contextualization, settings);\n    default:\n      break;\n    }\n    break;\n  case 'dynamic':\n    switch (contextualization.type) {\n    case 'inline':\n      return contextualizer.contextualizeInlineDynamic(document, contextualization, settings);\n    case 'block':\n      return contextualizer.contextualizeBlockDynamic(document, contextualization, settings);\n    default:\n      break;\n    }\n    break;\n  default:\n    break;\n  }\n  // default return unchanged document\n  return document;\n};\n"
  },
  {
    "__docId__": 259,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "numbersToLetters",
    "memberof": "src/core/resolvers/resolveContextualizations.js",
    "longname": "src/core/resolvers/resolveContextualizations.js~numbersToLetters",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations.js",
    "importStyle": "{numbersToLetters}",
    "description": "Transforms 1, 2, 3 ordinally used number into a, b, c ordinally used letters",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": "the number to transform"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "letter - the output letter"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveContextualizer",
    "memberof": "src/core/resolvers/resolveContextualizations.js",
    "longname": "src/core/resolvers/resolveContextualizations.js~resolveContextualizer",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations.js",
    "importStyle": null,
    "description": "Resolves a contextualizer object against its model and context, and records errors",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualizer",
        "description": "the contextualizer to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualization",
        "description": "the contextualization to use as a clue-giver if the contextualizer is implicit"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to which the contextualizer belongs"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to parse the contextualizer against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{err: error, contextualizer: Object}"
      ],
      "spread": false,
      "description": "result - parsing errors and final contextualizer"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveBindings",
    "memberof": "src/core/resolvers/resolveContextualizations.js",
    "longname": "src/core/resolvers/resolveContextualizations.js~resolveBindings",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations.js",
    "importStyle": "{resolveBindings}",
    "description": "Resolves contextualizations' contextualizer and resource, verifying that contextualization will be possible",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualizer",
        "description": "the contextualizer to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to use to validate data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "errors: array, newSection: Object"
      ],
      "spread": false,
      "description": "callback - returns updated section and possible errors as an array"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveContextualizationsRelations",
    "memberof": "src/core/resolvers/resolveContextualizations.js",
    "longname": "src/core/resolvers/resolveContextualizations.js~resolveContextualizationsRelations",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations.js",
    "importStyle": "{resolveContextualizationsRelations}",
    "description": "Resolves relations of recurrence, order, and similarity between contextualizations in a section",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "inputDocument"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the document to resolve"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the rendering settings to apply"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the udpated document"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveContextualizationImplementation",
    "memberof": "src/core/resolvers/resolveContextualizations.js",
    "longname": "src/core/resolvers/resolveContextualizations.js~resolveContextualizationImplementation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveContextualizations.js",
    "importStyle": "{resolveContextualizationImplementation}",
    "description": "Resolves all the contextualizations of a section by updating its contents pseudo-DOM representation",
    "lineNumber": 279,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualization",
        "description": "the contextualization to implement"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the document to update"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "renderingMode",
        "description": "whether rendering is static or dynamic"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the rendering settings to take into account when resolving contextualizations"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newDocument - the updated document"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/resolveDataDependencies.js",
    "memberof": null,
    "longname": "src/core/resolvers/resolveDataDependencies.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve @assets statements and @res statements\n * @module resolvers/resolveDataDependencies\n */\nimport {map as asyncMap, mapSeries as asyncMapSeries, waterfall} from 'async';\nconst CsvConverter = require('csvtojson').Converter;\nconst csvConverter = new CsvConverter({});\n\n/**\n * Resolves interpolations in metadata, resources, and contextualizations,\n * and possibly fetches & stores necessary data for rendering\n * @param {Object} document - the document to resolve\n * @param {Object} assetsController - the assets controller module to use to communicate with assets\n * @param {Object} assetsParams - the params to use for accessing the assets\n * @param {boolean} resolveData - whether to fetch and store necessary data right away or to store methods for later lazy-loading\n * @param {function(err: error, finalSections: array)} callback - callbacks a possible errors and the updated list of sections\n */\nexport default function resolveDataDependencies(\n  inputDocument,\n  assetsController,\n  assetsParams,\n  resolveData,\n  callback) {\n\n  const document = Object.assign({}, inputDocument);\n  let res;\n  let match;\n  const data = {};// this object stores resolved and unresolved promises about resources data\n  const resRe = /@res([\\d]+)?.(.*)/g;\n  const assetsRe = /@assets\\/([^']+)/g;\n  const inputSections = Object.keys(document.sections).map(key => document.sections[key]);\n\n  asyncMap(inputSections, (section, allSectionsCallback)=> {\n    waterfall([\n      // styles resolution\n      (stylesResolutionCallback)=> {\n        if (section.customizers && section.customizers.styles) {\n          const styles = [];\n          for (const prop in section.customizers.styles) {\n            if (section.customizers.styles[prop]) {\n              styles.push({key: prop, value: section.customizers.styles[prop]});\n            }\n          }\n          // map each style customizer\n          asyncMap(styles, (styleCouple, singleStyleCallback)=> {\n            let style = styleCouple.value;\n            // get all expressions\n            const matches = [];\n            do {\n              match = assetsRe.exec(style);\n              if (match) {\n                matches.push(match);\n              }\n            } while (match);\n            // some assets interpolations to do\n            if (matches.length) {\n              // reverse array to begin with last matches and not mess around with indexes\n              matches.reverse();\n              asyncMap(matches, (thisMatch, matchCallback)=> {\n                assetsController.getAssetUri(thisMatch[1], assetsParams, (err4, uri)=> {\n                  style = style.substr(0, thisMatch.index) + uri + style.substr(thisMatch.index + thisMatch[0].length);\n                  matchCallback(err4, thisMatch);\n                });\n              }, (matchErrors, theseMatches)=> {\n                styleCouple.value = style;\n                singleStyleCallback(matchErrors, styleCouple);\n              });\n            // no interpolations to do\n            } else {\n              styleCouple.value = style;\n              singleStyleCallback(null, styleCouple);\n            }\n          }, (stylesErrors, styleCouples)=> {\n            styleCouples.forEach((styleCouple) =>{\n              section.customizers.styles[styleCouple.key] = styleCouple.value;\n            });\n            stylesResolutionCallback(stylesErrors, section);\n          });\n        } else stylesResolutionCallback(null, section);\n      },\n      // resolve metadata\n      (sectio, metadataCallback)=> {\n        const domains = Object.keys(section.metadata);\n        asyncMap(domains, (domain, domainCallback)=> {\n          const props = Object.keys(sectio.metadata[domain]);\n          asyncMap(props, (propKey, propCallback)=> {\n            const prop = sectio.metadata[domain][propKey];\n            const propObject = {\n              key: propKey,\n              data: prop\n            };\n            if (typeof prop.value === 'string' && prop.value.indexOf('@assets/') === 0) {\n              assetsController.getAssetUri(prop.value.split('@assets/')[1], assetsParams, (err4, uri)=> {\n                prop.value = uri;\n                propObject.data = prop;\n                propCallback(err4, propObject);\n              });\n            } else {\n              propCallback(null, propObject);\n            }\n          }, (propsError, propObjects) => {\n            const domainObject = {\n              key: domain,\n              data: {}\n            };\n            propObjects.forEach(propObject=> {\n              domainObject.data[propObject.key] = propObject.data;\n            });\n            domainCallback(propsError, domainObject);\n          });\n        }, (domainErrors, domainObjects)=>{\n          domainObjects.forEach((domainObject) => {\n            sectio.metadata[domainObject.key] = domainObject.data;\n          });\n          metadataCallback(domainErrors, sectio);\n        });\n      }\n    // waterfall callback for all sections\n    ], (errs, sectio)=> {\n      // fill document section keys with updated sections\n      document.sections[sectio.metadata.general.id.value] = sectio;\n      allSectionsCallback(errs);\n    });\n  // sections final callback\n  }, (err)=> {\n    // document wide resolutions\n    const resources = Object.keys(document.resources).map(key => document.resources[key]);\n    const contextualizations = Object.keys(document.contextualizations).map(key => document.contextualizations[key]);\n\n    waterfall([\n      (contextualizationsCallback)=> {\n        asyncMap(contextualizations, (contextualization, contextualizationCallback)=> {\n          res = undefined;\n          const props = [];\n          // format props as array for performing an async map\n          const contextualizer = document.contextualizers[contextualization.contextualizer];\n\n          for (const prop in contextualizer) {\n            if (contextualizer[prop]) {\n              props.push({key: prop, value: contextualizer[prop]});\n            }\n          }\n          /**\n           * First level props\n           */\n          // resolve async. props\n          asyncMap(props, (prop, contextualizationPropCallback)=> {\n            const val = prop.value;\n            // if prop is itself an array, need for another nested async resolution\n            if (Array.isArray(val) && prop.key !== 'resources') {\n              // loop through propArray members\n              asyncMap(val, (prop2, propArrayMembersCallback)=> {\n                // prepare for asyncMap for propArray member\n                const nestedProps = [];\n                for (const nestedProp in prop2) {\n                  if (prop2[nestedProp]) {\n                    nestedProps.push({key: nestedProp, value: prop2[nestedProp]});\n                  }\n                }\n                // Second level props (contextualization.arrayProp[array member].prop)\n                asyncMap(nestedProps, (nestedProp, nestedPropCallback)=> {\n                  // resolve nested props here\n                  const val3 = nestedProp.value;\n                  if (('' + val3).indexOf('@res') === 0) {\n                    while ((match = resRe.exec(val3)) !== null) {\n                      // Identify which resource is targetted (handling multi-resource contextualizations)\n                      const rank = match[1] ? (+match[1] - 1) : 0;\n                      // find resource data\n                      res = document.resources[contextualization.resources[rank]];\n                      if (res === undefined) {\n                        console.log('res is undefined, expression: ', val3);\n                        return nestedPropCallback(undefined, nestedProp);\n                      }\n                      // case: metadata call\n                      const resProp = match[match.length - 1];\n                      if (resProp.indexOf('data') !== 0) {\n                        // interpolate w/ resource value thanks to resourceProp path\n                        nestedProp.value = res[resProp];\n                      // case : data call\n                      } else {\n                        const dataPath = ('' + val3).split('.').filter(path=>{\n                          return path.length;\n                        });\n                        nestedProp.value = {\n                          type: 'path',\n                          target: 'data',\n                          path: dataPath\n                        };\n                        const defined = data[res.id];\n                        if (!defined) {\n                          const accessor = res.data || res.url;\n                          if (('' + accessor).indexOf('@assets/') === 0) {\n                            const toResolve = {};\n                            toResolve.params = {\n                              path: accessor.split('@assets/')[1],\n                              params: assetsParams,\n                              acceptedExtensions: '*'\n                            };\n                            toResolve.read = assetsController.getReader(assetsParams);\n                            data[res.id] = toResolve;\n                          } else {\n                            console.log('unhandled data accessor (1) : ', accessor);\n                          }\n                        }\n                      }\n                    }\n                    nestedPropCallback(null, nestedProp);\n                  } else if (('' + val3).indexOf('@assets/') === 0) {\n                    assetsController.getAssetUri(val3.split('@assets/')[1], assetsParams, (err4, uri)=> {\n                      nestedProp.value = uri;\n                      nestedPropCallback(err4, nestedProp);\n                    });\n                  } else {\n                    nestedPropCallback(null, nestedProp);\n                  }\n                }, (err3, propsOut2)=> {\n                  const newProp2 = propsOut2.reduce((newCont, newContProp) =>{\n                    newCont[newContProp.key] = newContProp.value;\n                    return newCont;\n                  }, {});\n                  propArrayMembersCallback(err3, newProp2);\n                });\n              // resolve arrayed prop\n              }, (err2, arrayMembers)=> {\n                prop.value = arrayMembers;\n                contextualizationPropCallback(null, prop);\n              });\n            } else if (typeof val !== undefined && prop.key !== 'resources') {\n              if (('' + val).indexOf('@res') === 0) {\n                while ((match = resRe.exec(val)) !== null) {\n                  // Identify which resource is targetted (handling multi-resource contextualizations)\n                  const rank = match[1] ? (+match[1] - 1) : 0;\n                  // find resource data\n                  res = document.resources[contextualization.resources[rank]];\n                  if (res === undefined) {\n                    console.log('res is undefined, expression: ', val);\n                    return contextualizationPropCallback(undefined, prop);\n                  }\n                  const resProp = match[match.length - 1];\n                  // case: metadata call\n                  if (resProp.indexOf('data') !== 0) {\n                    // interpolate w/ resource value thanks to resourceProp path\n                    prop.value = res[resProp];\n                  // case : data call\n                  } else {\n                    const dataPath = ('' + val).split('.').filter(path=>{\n                      return path.length;\n                    });\n                    prop.value = {\n                      type: 'path',\n                      target: 'data',\n                      path: dataPath\n                    };\n                    const defined = data[res.id];\n                    if (!defined) {\n                      const accessor = res.data || res.url;\n                      if (('' + accessor).indexOf('@assets/') === 0) {\n                        const toResolve = {};\n                        toResolve.params = {\n                          path: accessor.split('@assets/')[1],\n                          params: assetsParams,\n                          acceptedExtensions: '*'\n                        };\n                        toResolve.read = assetsController.getReader(assetsParams);\n                        data[res.id] = toResolve;\n                      } else {\n                        console.log('unhandled data accessor (2) : ', accessor);\n                      }\n                    }\n                  }\n                }\n                contextualizationPropCallback(null, prop);\n              } else if (('' + val).indexOf('@assets/') === 0) {\n                assetsController.getAssetUri(val.split('@assets/')[1], assetsParams, (err3, uri)=> {\n                  prop.value = uri;\n                  contextualizationPropCallback(err3, prop);\n                });\n              } else {\n                contextualizationPropCallback(null, prop);\n              }\n            } else {\n              contextualizationPropCallback(null, prop);\n            }\n          }, (err1, propsOut1)=> {\n            const newContextualizer = propsOut1.reduce((newCont, propOut) =>{\n              newCont[propOut.key] = propOut.value;\n              return newCont;\n            }, {});\n\n            // pass contextualizer's resolved values to contextualization object\n            newContextualizer.contextualizerType = newContextualizer.type;\n            delete newContextualizer.type;// contextualization has a type also\n            delete newContextualizer.id;\n            const newContextualization = Object.assign(contextualization, newContextualizer);\n            contextualizationCallback(err1, newContextualization);\n          });\n        }, (contextualizationsError, finalContextualizations)=> {\n          finalContextualizations.forEach(contextualization => {\n            document.contextualizations[contextualization.id] = contextualization;\n          });\n          contextualizationsCallback(contextualizationsError);\n        });\n      },\n      (resourcesResolutionCallback)=>{\n        // resources resolution\n        asyncMap(resources, (resource, resourceCallback)=>{\n          const resolvedResource = {\n            key: resource.id,\n            data: resource\n          };\n          const props = [];\n          // format props as array for performing an async map\n          for (const prop in resource) {\n            if (resource[prop]) {\n              props.push({key: prop, value: resource[prop]});\n            }\n          }\n          asyncMap(props, (prop, resourcePropCallback)=> {\n            if (typeof prop.value === 'string' && prop.value.indexOf('@assets/') === 0) {\n              assetsController.getAssetUri(prop.value.split('@assets/')[1], assetsParams, (err4, uri)=> {\n                prop.value = uri;\n                resourcePropCallback(err4, prop);\n              });\n            } else {\n              resourcePropCallback(null, prop);\n            }\n          }, (singleResourceError, newProps)=> {\n            const newResource = newProps.reduce((obj, prop) =>{\n              obj[prop.key] = prop.value;\n              return obj;\n            }, {});\n            resolvedResource.data = newResource;\n            resourceCallback(singleResourceError, resolvedResource);\n          });\n        }, (resourceErrors, resolvedResources)=>{\n          resolvedResources.forEach(resolvedResource => {\n            document.resources[resolvedResource.key] = resolvedResource.data;\n          });\n          resourcesResolutionCallback(resourceErrors);\n        });\n      }\n    ], (documentWideErrors)=>{\n      if (resolveDataDependencies) {\n        asyncMapSeries(Object.keys(data), (key, dataCallback) =>{\n          const toResolve = data[key];\n          toResolve.read(toResolve.params, (dataErr, dataResult) =>{\n            if (dataErr) {\n              data[key] = dataErr;\n              dataCallback(null, key);\n            } else {\n              const raw = dataResult && dataResult.stringContents;\n              const ext = dataResult.extname;\n              // todo : handle other file formats\n              if (raw && ext === '.csv') {\n                csvConverter.fromString(raw, (parseErr, json)=>{\n                  data[key] = {\n                    format: 'json',\n                    data: json\n                  };\n                  dataCallback(parseErr, key);\n                });\n              }else {\n                console.log('unhandled file format ', ext);\n                dataCallback(null, key);\n              }\n            }\n          });\n        }, (finalErr, keys) =>{\n          document.data = data;\n          callback(finalErr, document);\n        });\n      } else {\n        document.data = data;\n        callback(documentWideErrors, document);\n      }\n    });\n  });\n}\n"
  },
  {
    "__docId__": 265,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "CsvConverter",
    "memberof": "src/core/resolvers/resolveDataDependencies.js",
    "longname": "src/core/resolvers/resolveDataDependencies.js~CsvConverter",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/resolvers/resolveDataDependencies.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "csvConverter",
    "memberof": "src/core/resolvers/resolveDataDependencies.js",
    "longname": "src/core/resolvers/resolveDataDependencies.js~csvConverter",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/resolvers/resolveDataDependencies.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "CsvConverter"
      ]
    }
  },
  {
    "__docId__": 267,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "resolveDataDependencies",
    "memberof": "src/core/resolvers/resolveDataDependencies.js",
    "longname": "src/core/resolvers/resolveDataDependencies.js~resolveDataDependencies",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveDataDependencies.js",
    "importStyle": "resolveDataDependencies",
    "description": "Resolves interpolations in metadata, resources, and contextualizations,\nand possibly fetches & stores necessary data for rendering",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the document to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsController",
        "description": "the assets controller module to use to communicate with assets"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsParams",
        "description": "the params to use for accessing the assets"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "resolveData",
        "description": "whether to fetch and store necessary data right away or to store methods for later lazy-loading"
      },
      {
        "nullable": null,
        "types": [
          "function(err: error, finalSections: array)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "callbacks a possible errors and the updated list of sections"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 268,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/resolveResourcesAgainstModels.js",
    "memberof": null,
    "longname": "src/core/resolvers/resolveResourcesAgainstModels.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\nimport {getResourceModel, resolvePropAgainstType} from '../utils/modelUtils';\n\nexport const resolveResourcesAgainstModels = (resources, models)=> {\n  const newResources = Object.assign({}, resources);\n  const newErrors = [];\n  for (const resourceKey in newResources) {\n    if (newResources[resourceKey]) {\n      const resource = newResources[resourceKey];\n      const model = getResourceModel(resource.bibType, models.resourceModels);\n      if (model) {\n        // populate resource model with input resource data\n        newResources[resourceKey] = model.properties.reduce((resolvedResource, propModel) => {\n          const key = propModel.key;\n          if (propModel.required && !resource[key]) {\n            newErrors.push({\n              type: 'error',\n              preciseType: 'invalidResource',\n              message: 'property ' + key + ' is required in resource ' + resource.id + '(bibType: ' + resource.bibType + ') and not present'\n            });\n          } else if (resource[key]) {\n            resolvedResource[key] = resolvePropAgainstType(resource[key], propModel.valueType, propModel);\n          } else if (propModel.default) {\n            resource[key] = propModel.default;\n          }\n          return resolvedResource;\n        }, {});\n      } else {\n        newErrors.push({\n          type: 'error',\n          preciseType: 'invalidResource',\n          message: 'Could not find suitable data model for resource ' + resource.id\n        });\n      }\n    }\n  }\n  return {newResources, newErrors};\n};\n"
  },
  {
    "__docId__": 269,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveResourcesAgainstModels",
    "memberof": "src/core/resolvers/resolveResourcesAgainstModels.js",
    "longname": "src/core/resolvers/resolveResourcesAgainstModels.js~resolveResourcesAgainstModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveResourcesAgainstModels.js",
    "importStyle": "{resolveResourcesAgainstModels}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/resolvers/resolveSectionAgainstModels.js",
    "memberof": null,
    "longname": "src/core/resolvers/resolveSectionAgainstModels.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Resolver dedicated to resolve sections against metadata models\n * @module resolvers/resolveSectionAgainstModels\n */\nimport {resolvePropAgainstType} from '../utils/modelUtils';\nimport {serializeHtmlMeta} from '../resolvers/htmlMetaTemplateSerializer';\n\n/**\n * Consumes and normalize the metadata of a section\n * @param {Object} section - the section to resolve\n * @param {Object} models - the models to use for resolution\n * @return {newErrors: array, newSection: Object} results - the new errors and section generated by resolution\n */\nexport const resolveSectionAgainstModels = (section, models) => {\n  const errors = [];\n\n  // validate metadata\n  const sectionId = section.metadata.general.id.value;\n  for (const domain in section.metadata) {\n    if (section.metadata[domain]) {\n      for (const key in section.metadata[domain]) {\n        if (section.metadata[domain][key]) {\n          const metadata = section.metadata[domain][key];\n          const model = models.metadataModels[domain][key];\n          if (model) {\n            // resolve unicity\n            const uniquePb = model.unique === true && Array.isArray(metadata.value) && metadata.value.length > 1;\n            if (uniquePb) {\n              errors.push({\n                type: 'error',\n                preciseType: 'invalidMetadata',\n                sectionId,\n                message: key + ' value was set more than once for section ' + sectionId\n              });\n              metadata.value = metadata.value[0];\n            }\n\n            if (Array.isArray(metadata.value)) {\n              metadata.value = metadata.value.map((val)=> {\n                if (typeof metadata.value === 'string') {\n                  return resolvePropAgainstType(val, model.valueType, model);\n                }\n                return val;\n              });\n\n            }else if (typeof metadata.value === 'string') {\n              metadata.value = resolvePropAgainstType(metadata.value, model.valueType, model);\n            }\n\n            if (model.headTemplate) {\n              metadata.htmlHead = serializeHtmlMeta(metadata, key, model.headTemplate);\n            }\n\n          } else {\n            errors.push({\n              type: 'warning',\n              preciseType: 'invalidMetadata',\n              sectionId,\n              message: domain + ' metadata property ' + key + ' is invalid in section ' + sectionId\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // set defaults\n  for (const key in models.metadataModels.general) {\n    if (models.metadataModels.general[key].default) {\n      const present = section.metadata.general[key];\n      if (present === undefined) {\n        section.metadata.general[key] = {\n          value: models.metadataModels.general[key].default\n        };\n      }\n    }\n  }\n  return {newErrors: errors, newSection: section};\n  // return callback(null, {newErrors: errors, newSection: section});\n};\n"
  },
  {
    "__docId__": 271,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveSectionAgainstModels",
    "memberof": "src/core/resolvers/resolveSectionAgainstModels.js",
    "longname": "src/core/resolvers/resolveSectionAgainstModels.js~resolveSectionAgainstModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/resolvers/resolveSectionAgainstModels.js",
    "importStyle": "{resolveSectionAgainstModels}",
    "description": "Consumes and normalize the metadata of a section",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "section",
        "description": "the section to resolve"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "the models to use for resolution"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "newErrors: array, newSection: Object"
      ],
      "spread": false,
      "description": "results - the new errors and section generated by resolution"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/citationUtils/citationModels.js",
    "memberof": null,
    "longname": "src/core/utils/citationUtils/citationModels.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to create a super abstract class for producing citation style specific, citation components\n * @module utils/citationModels\n */\nimport React, {PropTypes} from 'react';\nimport {\n  StructuredCOinS\n} from './../../components';\nimport * as formatter from '../microDataUtils';\n\n/**\n * Virtual component class for rendering generic block citations\n */\nexport class BlockCitationModel extends React.Component {\n  /**\n   * propTypes\n   * @property {object} resource - the resource to use for making the citation\n   * @property {object} contextualization - the details of contextualization (e.g. page)\n   * @property {boolean} ibid - immediately recurrent citation ?\n   * @property {boolean} opCit - not immediately recurent citation ?\n   * @property {string} schemaType - microformat type fo the item\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    contextualization: PropTypes.object,\n    ibid: PropTypes.bool,\n    opCit: PropTypes.bool,\n    schemaType: PropTypes.string\n  };\n\n  /**\n   * Gets the schematype of the citation, from contextualization statement or from the resource bibType\n   * @return schemaType - the schematype of the citation\n  */\n  getSchemaType() {\n    return this.props.schemaType || formatter.bibToSchema(this.props.resource.bibType);\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    return (\n      <p\n      id={this.props.contextualization.id}\n      className=\"peritext-block-citation\"\n      itemProp=\"citation\"\n      property=\"citation\"\n      itemScope\n      itemType={'http://schema.org/' + this.getSchemaType()}\n      typeof={this.getSchemaType()}\n    >\n      <StructuredCOinS resource={this.props.resource} />\n      {this.renderReference()}\n      {this.renderAdditionnal(this.props)}\n    </p>);\n  }\n}\n\n/**\n * Virtual component class for rendering generic inline citations\n */\nexport class InlineCitationModel extends React.Component {\n  /**\n   * propTypes\n   * @property {object} resource the resource to use for making the citation\n   * @property {object} contextualization the details of contextualization (e.g. page)\n   * @property {boolean} ibid immediately recurent citation ?\n   * @property {boolean} opCit not immediately recurent citation ?\n   * @property {string} schemaType microformat type fo the item\n   */\n  static propTypes = {\n    resource: PropTypes.object,\n    contextualization: PropTypes.object,\n    ibid: PropTypes.bool,\n    opCit: PropTypes.bool,\n    schemaType: PropTypes.string\n  };\n\n  /**\n   * Gets the schematype of the citation, from contextualization statement or from the resource bibType\n   * @return schemaType - the schematype of the citation\n  */\n  getSchemaType() {\n    return this.props.schemaType || formatter.bibToSchema(this.props.resource.bibType);\n  }\n\n  /**\n   * render\n   * @return {ReactElement} markup\n   */\n  render() {\n    // console.log(this.props);\n    return (<span\n      id={this.props.contextualization.id}\n      className=\"peritext-inline-citation\"\n      itemProp=\"citation\"\n      property=\"citation\"\n      itemScope\n      itemType={'http://schema.org/' + this.getSchemaType()}\n      typeof={this.getSchemaType()}\n    >\n      {this.renderReference()}\n      {this.renderAdditionnal(this.props)}\n    </span>);\n  }\n}\n"
  },
  {
    "__docId__": 273,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "BlockCitationModel",
    "memberof": "src/core/utils/citationUtils/citationModels.js",
    "longname": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/citationUtils/citationModels.js",
    "importStyle": "{BlockCitationModel}",
    "description": "Virtual component class for rendering generic block citations",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 274,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSchemaType",
    "memberof": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel#getSchemaType",
    "access": null,
    "description": "Gets the schematype of the citation, from contextualization statement or from the resource bibType",
    "lineNumber": 35,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "schemaType - the schematype of the citation"
    },
    "generator": false
  },
  {
    "__docId__": 275,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~BlockCitationModel#render",
    "access": null,
    "description": "render",
    "lineNumber": 43,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 276,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "InlineCitationModel",
    "memberof": "src/core/utils/citationUtils/citationModels.js",
    "longname": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/citationUtils/citationModels.js",
    "importStyle": "{InlineCitationModel}",
    "description": "Virtual component class for rendering generic inline citations",
    "lineNumber": 64,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 277,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSchemaType",
    "memberof": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel#getSchemaType",
    "access": null,
    "description": "Gets the schematype of the citation, from contextualization statement or from the resource bibType",
    "lineNumber": 85,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "schemaType - the schematype of the citation"
    },
    "generator": false
  },
  {
    "__docId__": 278,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "render",
    "memberof": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel",
    "longname": "src/core/utils/citationUtils/citationModels.js~InlineCitationModel#render",
    "access": null,
    "description": "render",
    "lineNumber": 93,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 279,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/componentsFactory.js",
    "memberof": null,
    "longname": "src/core/utils/componentsFactory.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to consuming peritext contents' pseudo-dom representations by returning React markup\n * @module utils/modelUtils\n */\nimport React from 'react';\n\n/**\n * Consumes a peritext content's pseudo-dom node (described as a js object) and returns a react component\n * @param {Object} node - the pseudo-dom node\n * @param {number} index - the index of the node (used for providing react keys)\n * @return {ReactElement} markup describing the node\n */\nexport const jsToComponent = (node, index)=> {\n  if (node.node === 'text') {\n    return node.text;\n  }\n  if (node.special && node.tag) {\n    // Component class stored as referenced object\n    const Component = node.tag;\n    return <Component key={index} {...node.props} />;\n  }\n  // plain string tag name\n  if (node.tag) {\n    const Tag = node.tag;\n    return (<Tag key={index} id={node.attr && node.attr.id} href={node.attr && node.attr.href}>\n      {node.children && node.children.map(jsToComponent)}\n    </Tag>);\n  }\n  // if no react tag to use, render harmless empty string\n  return '';\n};\n\n/**\n * Consumes a peritext content's pseudo-dom nodes list to produce react markup\n * @param {Object} contents - the pseudo-dom nodes array\n * @return {ReactElement|string} markup or string contents\n */\nexport default function renderContents(contents) {\n  if (Array.isArray(contents)) {\n    return contents.map(jsToComponent);\n  } else if (typeof contents === 'string') {\n    return contents;\n  }\n  return '';\n}\n"
  },
  {
    "__docId__": 280,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "jsToComponent",
    "memberof": "src/core/utils/componentsFactory.js",
    "longname": "src/core/utils/componentsFactory.js~jsToComponent",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/componentsFactory.js",
    "importStyle": "{jsToComponent}",
    "description": "Consumes a peritext content's pseudo-dom node (described as a js object) and returns a react component",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "the pseudo-dom node"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": "the index of the node (used for providing react keys)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup describing the node"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "renderContents",
    "memberof": "src/core/utils/componentsFactory.js",
    "longname": "src/core/utils/componentsFactory.js~renderContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/componentsFactory.js",
    "importStyle": "renderContents",
    "description": "Consumes a peritext content's pseudo-dom nodes list to produce react markup",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "the pseudo-dom nodes array"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement",
        "string"
      ],
      "spread": false,
      "description": "markup or string contents"
    },
    "generator": false
  },
  {
    "__docId__": 282,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/microDataUtils.js",
    "memberof": null,
    "longname": "src/core/utils/microDataUtils.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - Collection of utils for formatting scholarly citations in html+schema+RDFa+COiNS elements\n * @module utils/microDataUtils\n */\n\n/**\n * Translates a peritext bibType to a schema.org Type\n * @param {string} bib - the peritext bibType\n * @return {string} SchemaType - the corresponding SchemaType\n */\nexport const bibToSchema = (bib) => {\n  switch (bib) {\n  case 'book':\n    return 'Book';\n  case 'article':\n    return 'ScholarlyArticle';\n  case 'booklet':\n    return 'CreativeWork';\n  case 'conference':\n    return 'Chapter';\n  case 'incollection':\n    return 'Chapter';\n  case 'inherits':\n    return 'Chapter';\n  case 'inbook':\n    return 'Chapter';\n  case 'mastersthesis':\n    return 'Thesis';\n  case 'phdthesis':\n    return 'Thesis';\n  case 'proceedings':\n    return 'Book';\n  case 'image':\n    return 'ImageObject';\n  case 'online':\n    return 'WebSite';\n  case 'vectorsImage':\n    return 'ImageObject';\n  case 'tabularData':\n    return 'Dataset';\n  case 'video':\n    return 'VideoObject';\n  case 'audio':\n    return 'AudioObject';\n  case 'person':\n    return 'Person';\n  case 'place':\n    return 'Place';\n  case 'organization':\n    return 'Organization';\n  // not very accurate\n  case 'artefact':\n    return 'Product';\n  // no schematype for these ones (too abstract)\n  case 'topic':\n  case 'concept':\n  case 'technology':\n    return 'Thing';\n  default:\n    return 'CreativeWork';\n  }\n};\n\n/*\n  Context Objects in Spans (COiNS) related functions\n*/\n\nconst addPropToCOinSData = (key, value) => {\n  return {\n    key: key,\n    value: value\n  };\n};\n\nconst urify = (key, value) => {\n  return key + '=' + encodeURIComponent(value);\n};\n\nconst assembleUri = (infos) => {\n  const vals = [];\n  infos.forEach(function(info) {\n    vals.push(urify(info.key, info.value));\n  });\n  return vals.join('&amp;');\n};\n\nconst baseMap = {\n  'rft.date': 'date',\n  'rft.pages': 'pages',\n  'rft.issn': 'ISSN',\n  'rft.isbn': 'ISBN',\n  'rft_id': 'url',\n  'rft.place': 'address',\n  'rft.pub': 'publisher'\n};\n\nconst journalMap = {\n  'rft.atitle': 'title',\n  'rft.jtitle': 'journal',\n  'rft.volume': 'volume',\n  'rft.issue': 'issue'\n};\n\nconst chapterMap = {\n  'rft.atitle': 'title',\n  'rft.btitle': 'booktitle'\n};\n\nconst translate = (data, item, map) => {\n  for (const key in map) {\n    if (item[map[key]]) {\n      data.push(addPropToCOinSData(key, item[map[key]]));\n    }\n  }\n  return data;\n};\n\n/**\n * Generates an openUrl URI describing the resource, and aimed at being used in a ContextObjectInSpan (COinS)\n * @param {Object} resource - the resource to describe with an openUrl\n * @return {string} uri - the uri describing the resource\n */\nexport const generateOpenUrl = (resource) => {\n  let data = [];\n  data.push(addPropToCOinSData('ctx_ver', 'Z39.88-2004'));\n\n  if (resource.author && resource.author.length) {\n    resource.author.forEach(function(author) {\n      data.push(addPropToCOinSData('rft.au', author.lastName + ', ' + author.firstName));\n    });\n  }\n  data = translate(data, resource, baseMap);\n  if (resource.bibType === 'journal' || resource.bibType === 'article') {\n    data = translate(data, resource, journalMap);\n    data.push(addPropToCOinSData('rft.genre', 'article'));\n    data.push(addPropToCOinSData('rft_val_fmt', 'info:ofi/fmt:kev:mtx:journal'));\n  }else if (resource.bibType === 'proceedings' || resource.bibType === 'conferencePaper') {\n    data = translate(data, resource, journalMap);\n    data.push(addPropToCOinSData('rft.genre', 'conference'));\n    data.push(addPropToCOinSData('rft_val_fmt', 'info:ofi/fmt:kev:mtx:book'));\n  }else if (resource.bibType === 'chapter') {\n    data = translate(data, resource, chapterMap);\n    data.push(addPropToCOinSData('rft.genre', 'bookitem'));\n    data.push(addPropToCOinSData('rft_val_fmt', 'info:ofi/fmt:kev:mtx:book'));\n  }else {\n    data.push(addPropToCOinSData('rft.genre', 'document'));\n  }\n  return assembleUri(data);\n};\n"
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "bibToSchema",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~bibToSchema",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": "{bibToSchema}",
    "description": "Translates a peritext bibType to a schema.org Type",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bib",
        "description": "the peritext bibType"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "SchemaType - the corresponding SchemaType"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "addPropToCOinSData",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~addPropToCOinSData",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "urify",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~urify",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "assembleUri",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~assembleUri",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "baseMap",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~baseMap",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "journalMap",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~journalMap",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "chapterMap",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~chapterMap",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "translate",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~translate",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "generateOpenUrl",
    "memberof": "src/core/utils/microDataUtils.js",
    "longname": "src/core/utils/microDataUtils.js~generateOpenUrl",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/microDataUtils.js",
    "importStyle": "{generateOpenUrl}",
    "description": "Generates an openUrl URI describing the resource, and aimed at being used in a ContextObjectInSpan (COinS)",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "the resource to describe with an openUrl"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "uri - the uri describing the resource"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/modelUtils.js",
    "memberof": null,
    "longname": "src/core/utils/modelUtils.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to everything that deals with models (composing, translating values, ...)\n * @module utils/modelUtils\n */\nimport {parseBibAuthors} from '../converters/bibTexConverter';\n\n/**\n * Builds a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType\n * @param {string} bibType - the bibType of the resource\n * @param {Object} resourceModels - the models describing resources data\n * @return {Object} model - the model corresponding to the input bibType\n */\nexport const getResourceModel = (bibType, resourceModels) =>{\n  const model = resourceModels.individual[bibType];\n  if (model) {\n    // first set highestly specific props\n    let properties = model.properties;\n    let defaultContextualizer = model.defaultContextualizer;\n    let otherProps;\n    let existing;\n    // then parse related categories\n    model.categories.forEach((category) => {\n      otherProps = resourceModels.collective[category]\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n      properties = properties.concat(otherProps);\n\n      // inherit default contextualizer\n      if (resourceModels.collective[category].defaultContextualizer && !defaultContextualizer) {\n        defaultContextualizer = resourceModels.collective[category].defaultContextualizer;\n      }\n    });\n    // then finally parse common props\n    otherProps = resourceModels.collective.common\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n    properties = properties.concat(otherProps);\n\n    return Object.assign({}, model, {properties: model.properties.concat(properties)}, {defaultContextualizer});\n  }\n  return undefined;\n};\n\n/**\n * Build a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType\n * @param {string} bibType - the bibType of the contextualizer\n * @param {Object} contextualizerModels - the models describing contextualizer possible data\n * @return {Object} model - the model corresponding to the input bibType\n */\nexport const getContextualizerModel = (bibType, contextualizerModels) =>{\n  const model = contextualizerModels.individual[bibType];\n  if (model) {\n    // first set highestly specific props\n    let properties = model.properties;\n    let otherProps;\n    let existing;\n    // then parse related categories\n    model.categories.forEach((category) => {\n      otherProps = contextualizerModels.collective[category]\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n      properties = properties.concat(otherProps);\n\n    });\n\n    // then finally parse common props\n    otherProps = contextualizerModels.collective.common\n                    .properties\n                    .filter((prop) =>{\n                      existing = properties.find((property) =>{\n                        return property.key === prop.key;\n                      });\n                      if (existing) {\n                        return false;\n                      }\n                      return true;\n                    });\n    properties = properties.concat(otherProps);\n    return Object.assign({}, model, {properties});\n  }\n  return undefined;\n};\n\n/**\n * Transforms a (possibly not primitive : array, object, bibAuthor) value to a string-friendly value, thanks to its model's type\n * @param {Object} prop - the prop to serialize\n * @param {string} valueType - the type of the value ('string', 'stringArray', 'bibAuthor', ...)\n * @param {Object} model - the model to parse the prop against\n * @return {string} newValue - the serialized value\n */\nexport const serializePropAgainstType = (prop, valueType, model) => {\n  if (prop === undefined) {\n    return undefined;\n  }\n  switch (valueType) {\n  case 'string':\n    return prop;\n\n  case 'stringArray':\n    return prop.join(', ');\n\n  case 'bibAuthorsArray':\n    return prop.map((author) =>{\n      if (author.firstName) {\n        return author.firstName + ' {' + author.lastName + '}';\n      }\n      return author.lastName;\n    }).join('; ');\n\n  case 'objectArray' : {\n    if (model.children && Array.isArray(prop)) {\n      const newProp = prop.map((obj)=>{\n        if (typeof obj === 'object') {\n          const vals = Object.keys(obj).map((key)=>{\n            if (obj[key] !== undefined) {\n              return key + '=' + obj[key];\n            }\n            return '';\n          });\n          return vals.filter((part)=>{return part.length;}).join(',');\n        }\n        return undefined;\n      });\n      return newProp;\n    }\n    break;\n  }\n\n  default:\n    return prop;\n  }\n\n};\n\n/**\n * Transforms a string value to a complex and type-compliant value, thanks to its model's type\n * @param {Object} prop - the prop to resolve\n * @param {string} valueType - the type of the value ('string', 'stringArray', 'bibAuthor', ...)\n * @param {Object} model - the model to parse the prop against\n * @return {string|array|number|Object} newValue - the resolved value\n */\nexport const resolvePropAgainstType = (prop, valueType, model) => {\n  if (prop === undefined) {\n    // looking for a default value if no value specified\n    if (model.default) {\n      return model.default;\n    }\n    return undefined;\n  // looking for restricted values\n  } else if (model.values) {\n    const validValue = model.values.find((value) => {\n      return value === prop;\n    });\n    // value not allowed\n    if (validValue === undefined) {\n      // look for default\n      if (model.default) {\n        return model.default;\n      }\n      // or return undefined\n      return undefined;\n    }\n  }\n  switch (valueType) {\n  case 'number':\n    return +prop;\n\n  case 'numberArray':\n    return prop.split(',').map((number)=> {\n      return +number.trim();\n    });\n\n  case 'string':\n    /*\n    if (model.values) {\n      // nominal set of possible values\n      val = model.values.some((mval)=>{\n        return mval === prop;\n      });\n      console.log('val : ', val);\n      return val;\n    }\n    */\n    return prop;\n\n  case 'stringArray':\n    return prop.split(/,|;/).map((value)=>{return value.trim();});\n\n  case 'bibAuthorsArray':\n    return parseBibAuthors(prop);\n\n  case 'objectArray' : {\n    if (model.children && Array.isArray(prop)) {\n      const newProp = prop.map((obj)=>{\n        if (typeof obj === 'object') {\n          const newObj = model.children.reduce((thatObj, childModel) =>{\n            thatObj[childModel.key] = resolvePropAgainstType(obj[childModel.key], childModel.valueType, childModel);\n            return thatObj;\n          }, {});\n          return newObj;\n        }\n        return undefined;\n      });\n      return newProp;\n    }\n  }\n\n  default:\n    return prop;\n  }\n};\n\n/**\n * Populate rendering settings according to default bibtype-related settings\n * @param {Object} settings - the settings provided as input\n * @param {string} bibType - the bibType of the root section to render\n * @param {Object} settingsModel - the model to use for populating the settings\n * @return {Object} newSettings - the populated settings\n */\nexport const resolveSettings = (settings = {}, bibType, settingsModel) =>{\n  const typeModel = {};\n  for (const param in settingsModel) {\n    if (settingsModel[param].default[bibType]) {\n      typeModel[param] = settingsModel[param].default[bibType];\n    } else {\n      typeModel[param] = settingsModel[param].default.default;\n    }\n  }\n  return Object.assign(typeModel, settings);\n};\n"
  },
  {
    "__docId__": 293,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getResourceModel",
    "memberof": "src/core/utils/modelUtils.js",
    "longname": "src/core/utils/modelUtils.js~getResourceModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils.js",
    "importStyle": "{getResourceModel}",
    "description": "Builds a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the resource"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "resourceModels",
        "description": "the models describing resources data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "model - the model corresponding to the input bibType"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getContextualizerModel",
    "memberof": "src/core/utils/modelUtils.js",
    "longname": "src/core/utils/modelUtils.js~getContextualizerModel",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils.js",
    "importStyle": "{getContextualizerModel}",
    "description": "Build a model object from a specific bibType, composing it according to its inheritance dependencies, from more general models to the specific bibType",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the contextualizer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "contextualizerModels",
        "description": "the models describing contextualizer possible data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "model - the model corresponding to the input bibType"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "serializePropAgainstType",
    "memberof": "src/core/utils/modelUtils.js",
    "longname": "src/core/utils/modelUtils.js~serializePropAgainstType",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils.js",
    "importStyle": "{serializePropAgainstType}",
    "description": "Transforms a (possibly not primitive : array, object, bibAuthor) value to a string-friendly value, thanks to its model's type",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "prop",
        "description": "the prop to serialize"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "valueType",
        "description": "the type of the value ('string', 'stringArray', 'bibAuthor', ...)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "the model to parse the prop against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "newValue - the serialized value"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolvePropAgainstType",
    "memberof": "src/core/utils/modelUtils.js",
    "longname": "src/core/utils/modelUtils.js~resolvePropAgainstType",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils.js",
    "importStyle": "{resolvePropAgainstType}",
    "description": "Transforms a string value to a complex and type-compliant value, thanks to its model's type",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "prop",
        "description": "the prop to resolve"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "valueType",
        "description": "the type of the value ('string', 'stringArray', 'bibAuthor', ...)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "the model to parse the prop against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string",
        "array",
        "number",
        "Object"
      ],
      "spread": false,
      "description": "newValue - the resolved value"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveSettings",
    "memberof": "src/core/utils/modelUtils.js",
    "longname": "src/core/utils/modelUtils.js~resolveSettings",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/modelUtils.js",
    "importStyle": "{resolveSettings}",
    "description": "Populate rendering settings according to default bibtype-related settings",
    "lineNumber": 244,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the settings provided as input"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the root section to render"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settingsModel",
        "description": "the model to use for populating the settings"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "newSettings - the populated settings"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/referenceUtils.js",
    "memberof": null,
    "longname": "src/core/utils/referenceUtils.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - dedicated to representing a reference/bibliography section\n * @module utils/referenceUtils\n */\n\nconst bibliographicTypes = [\n  'article',\n  'book',\n  'booklet',\n  'collection',\n  'conference',\n  'inbook',\n  'incollection',\n  'inproceedings',\n  'manual',\n  'mastersthesis',\n  'phdthesis',\n  'proceedings',\n  'techreport',\n  'unpublished'\n];\n\n/**\n * Checks whether a given references belongs to a \"traditional\" bibliographical reference (journal article, book, ...)\n * @param {string} bibType - the bibType of the resource\n * @return {boolean} isBibliographical\n */\nconst isBibliographical = (bibType) =>{\n  const bibliType = bibliographicTypes.find((type)=> {\n    return bibType === type;\n  });\n  return bibliType !== undefined;\n};\n\n/**\n * Filter and order a list of resources against bibliography settings\n * @param {array} sections - the sections to handle for building the list\n * @param {Object} document - the reference to the overall document\n * @param {Object} settings - the rendering settings, among which are bibliography-making related settings\n * @return {array} references - the resulting list\n */\nexport const computeReferences = (sections, document, settings) =>{\n  if (settings.referenceScope === 'document') {\n    const references = [];\n    for (const key in document.resources) {\n      if (document.resources[key]) {\n        references.push(document.resources[key]);\n      }\n    }\n\n    // handle filters\n    const filters = (settings.referenceFilters || []) && settings.referenceFilters.split(' ');\n    const filteredReferences = filters.reduce((outputReferences, filter)=> {\n      switch (filter) {\n      case 'has-title':\n        return outputReferences.filter((ref)=> {\n          return ref.title !== undefined;\n        });\n      case 'bibliographical':\n        return outputReferences.filter((ref)=> {\n          return isBibliographical(ref.bibType);\n        });\n      // todo : document filters\n      // todo : design other filters\n      default:\n        return outputReferences;\n      }\n    }, references);\n\n    // retrieve related contextualizations\n    const improvedReferences = filteredReferences.map((reference) => {\n      const contextualizations = Object.keys(document.contextualizations)\n                                  .map(key => document.contextualizations[key])\n                                  .filter(contextualization =>\n                                    contextualization.resources.indexOf(reference.id) > -1\n                                  );\n      return Object.assign(reference, {contextualizations});\n    });\n\n    // order references\n    const order = settings.referenceSortBy;\n    const sortedReferences = improvedReferences.sort((ref1, ref2)=> {\n      switch (order) {\n      case 'title':\n        return (ref1.title && ref1.title.toLowerCase()) > (ref2.title && ref2.title.toLowerCase()) ? 1 : -1;\n      case 'authors':\n        const print1 = ref1.author && ref1.author.reduce((str1, author1)=> {\n          return str1 + author1.lastName + '-';\n        }, '');\n        const print2 = ref2.author && ref2.author.reduce((str2, author2)=> {\n          return str2 + author2.lastName + '-';\n        }, '');\n        return print1 > print2 ? 1 : -1;\n      case 'year':\n        return ref1.year > ref2.year ? 1 : -1;\n      case 'type':\n        return ref1.bibType > ref2.bibType ? 1 : -1;\n      default:\n        return 1;\n      }\n    });\n    return sortedReferences;\n  }\n};\n"
  },
  {
    "__docId__": 299,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "bibliographicTypes",
    "memberof": "src/core/utils/referenceUtils.js",
    "longname": "src/core/utils/referenceUtils.js~bibliographicTypes",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/referenceUtils.js",
    "importStyle": null,
    "description": "Utils - dedicated to representing a reference/bibliography section",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@module",
        "tagValue": "utils/referenceUtils"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "isBibliographical",
    "memberof": "src/core/utils/referenceUtils.js",
    "longname": "src/core/utils/referenceUtils.js~isBibliographical",
    "access": null,
    "export": false,
    "importPath": "peritext/src/core/utils/referenceUtils.js",
    "importStyle": null,
    "description": "Checks whether a given references belongs to a \"traditional\" bibliographical reference (journal article, book, ...)",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bibType",
        "description": "the bibType of the resource"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "isBibliographical"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "computeReferences",
    "memberof": "src/core/utils/referenceUtils.js",
    "longname": "src/core/utils/referenceUtils.js~computeReferences",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/referenceUtils.js",
    "importStyle": "{computeReferences}",
    "description": "Filter and order a list of resources against bibliography settings",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "sections",
        "description": "the sections to handle for building the list"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the reference to the overall document"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the rendering settings, among which are bibliography-making related settings"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "references - the resulting list"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/utils/sectionUtils.js",
    "memberof": null,
    "longname": "src/core/utils/sectionUtils.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Utils - section metadata & resources utils : access, filter, deletion, ...\n * @module utils/sectionUtils\n */\n\n/**\n * Gets a value in metadata props array by its domain and key\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @return {string} value - the value\n */\n /*\nexport const getMetaValue = (metaList, domain, key) =>{\n  const prop = metaList.find((meta) =>{\n    return meta.domain === domain && meta.key === key;\n  });\n  if (prop) {\n    return prop.value;\n  }\n  return undefined;\n};\n*/\n\n/**\n * Sets a value in metadata props array after localized it by its domain and key\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @param {string} newValue - the new value to assign to the prop\n * @return {array} newlist - the updated list\n */\n/*\nexport const setMetaValue = (metaList, domain, key, newValue) =>{\n  const newMetaList = metaList.map((meta) =>{\n    if (meta.domain === domain && meta.key === key) {\n      meta.value = newValue;\n    }\n    return meta;\n  });\n  return newMetaList;\n};\n*/\n\n/**\n * Checks if the value has a metadata property\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @return {boolean} hasMeta - whether the prop is there\n */\n/*\nexport const hasMeta = (metaList, domain, key) =>{\n  if (typeof domain === 'string') {\n    return getMetaValue(metaList, domain, key) !== undefined;\n  }else if (domain.domain) {\n    return getMetaValue(metaList, domain.domain, domain.key) !== undefined;\n  }\n  throw new Error('error in couple ' + domain + '_' + key + ': hasMeta method needs either a domain+key pair or a metadata prop object');\n};\n*/\n\n/**\n * Finds a specific section in a sections list through one of its metadata\n * @param {array} sections - the sections array to search in\n * @param {string} domain - the domain of the prop used to search the section, stored in its \"domain\" prop\n * @param {string} key - the key of the prop used to search the section, stored in its \"key\" prop\n * @return {Object} section - the resulting section\n */\n/*\nexport const findByMetadata = (sections, domain, key, value) =>{\n  return sections.find((section) =>{\n    const meta = getMetaValue(section.metadata, domain, key);\n    return meta === value;\n  });\n};\n*/\n\n/**\n * Checks if two metadata props have the same scope (domain and key)\n * @param {Object} meta1 - the first metadata prop\n * @param {Object} meta1 - the second metadata prop\n * @return {boolean} sameScope - whether the two props have the same scope\n */\n /*\nexport const sameMetaScope = (meta1, meta2) =>{\n  return meta1.domain === meta2.domain && meta1.key === meta2.key;\n};\n*/\n\n/**\n * Delete a specific metadata prop\n * @param {array} metaList - the list of metadata objects in which looking for the value\n * @param {string} domain - the domain of the prop, stored in its \"domain\" prop\n * @param {string} key - the key of the prop, stored in its \"key\" prop\n * @return {array} updatedMetaList - the new metadata list, without the deleted prop\n */\n /*\nexport const deleteMeta = (metaList, domain, key) =>{\n  return metaList.filter((meta)=>{\n    return !(domain === meta.domain && key === meta.key);\n  });\n};\n*/\n\n/**\n * Converts a bibtex metadata expression (e.g. \"title\", \"twitter_twitter\") to an object prop\n * @param {string} str - the bibtex metadata expression\n * @return {Object} metadata - the metadata prop object, without value\n */\nexport const metaStringToCouple = (str) =>{\n  const parts = str.split('_');\n  const domain = (parts.length > 1) ? parts.shift() : 'general';\n  const key = parts.join('_');\n  return {domain, key};\n};\n\n/**\n * Checks if a resource list contains a resource, by id\n * @param {array} resourcesList - the resources list in which looking for\n * @param {Object} resource - the resource to look for\n * @return {boolean} hasResource - whether resource is present in the list\n */\n /*\nexport const hasResource = (resourcesList, resource) =>{\n  return resourcesList.find((res) =>{\n    return resource.id === res.id;\n  }) !== undefined;\n};\n*/\n\n/**\n * Filter resources that have a specific value\n * @param {array} resourcesList - the list of resource sto filter\n * @param {string} key - the key by which filtering the resources\n * @param {string} value - the value by which filtering the resources\n * @return {array} updatedResourceList - the filtered resources list\n */\n /*\nexport const filterResources = (resourcesList, key, value) =>{\n  return resourcesList.filter((res) =>{\n    return res[key] === value;\n  });\n};\n*/\n"
  },
  {
    "__docId__": 303,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "metaStringToCouple",
    "memberof": "src/core/utils/sectionUtils.js",
    "longname": "src/core/utils/sectionUtils.js~metaStringToCouple",
    "access": null,
    "export": true,
    "importPath": "peritext/src/core/utils/sectionUtils.js",
    "importStyle": "{metaStringToCouple}",
    "description": "Converts a bibtex metadata expression (e.g. \"title\", \"twitter_twitter\") to an object prop",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the bibtex metadata expression"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "metadata - the metadata prop object, without value"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 304,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/validators/index.js",
    "memberof": null,
    "longname": "src/core/validators/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Validators check some data against some models.\n * They should record errors and return them in a callback along with input data, either in first argument or in a {errors, data} second argument.\n * They should not modify/correct input data.\n * @module validators\n */\n\nexport {validateResources} from './sectionValidator';\n"
  },
  {
    "__docId__": 305,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/core/validators/sectionValidator.js",
    "memberof": null,
    "longname": "src/core/validators/sectionValidator.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Section-related validation functions\n * @todo lighten documentConverter by putting more utils there\n * @module validators/sectionValidator\n */\n"
  },
  {
    "__docId__": 306,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/exporters/index.js",
    "memberof": null,
    "longname": "src/exporters/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Exporters - pure functions that export contents in different formats\n * @module exporters\n */\n\nexport {default as exportSectionToPdf} from './pdfExporter';\n"
  },
  {
    "__docId__": 307,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/exporters/pdfExporter/index.js",
    "memberof": null,
    "longname": "src/exporters/pdfExporter/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Prince PDF exporter\n * @module exporters/pdfExporter\n */\n\n\n/**\n * This module inputs a specific peritext section, including possibly its children sections\n * and outputs a pdf file ready to display.\n * The converter used is PrinceXML non-commercial version.\n * After endless trials with free software converters such as wkhtmltopdf, weasyprint or phantomjs-pdf,\n * I could not find a way to use a free (gratis & open) tech. to produce & sufficiently reliable and user-customizable pdf output (notably via css3 @paged-media props).\n * For instance, wkhtmltopdf (and webkit-based converters in general) does not support 'float:footnotes' feature which is mandatory for scholarly outputs like peritext's ones\n * Therefore I chose proprietary software PrinceXML, which works wonderfully well. It is used in its free version for now (which is why Prince logo is added on the first page, no commercial use license)\n */\n\nconst Prince = require('prince');\nimport {resolve} from 'path';\nimport {waterfall} from 'async';\nimport {\n  writeFile,\n  exists,\n  mkdir\n} from 'fs';\n\nimport {renderDocument} from './../../renderers/renderToStaticHtml';\n\n/**\n * Exports a section representation of a peritext document to a pdf file\n * @param {Object} params - The params of the export\n * @param {Object} params.document - the document to export\n * @param {Object} params.settings - the specific rendering settings to use in order to produce the output\n * @param {string} params.destinationFolder - where to output the file\n * @params {Object} assetsController - the module to use in order to communicate with assets\n * @param {Object} assetsParams - the assets parameters to use while communicating with assetsController\n * @param {function(err:error)} callback - the possible errors encountered during export\n */\nexport const exportDocumentToPdf = ({\n  document,\n  settings,\n  destinationFolder,\n}, assetsController, assetsParams, finalCallback) =>{\n\n  const motherKey = document.metadata.general.id.value;\n  const path = destinationFolder || resolve(__dirname + '/temp/');\n  console.log('export to path: ', path);\n  waterfall([\n    // get or create destination folder\n    (existsCb)=> {\n      exists(path, (isThere)=> {\n        if (!isThere) {\n          return mkdir(path, existsCb);\n        }\n        return existsCb(null);\n      });\n    },\n    // render the section to static html\n    (renderCb)=> {\n      renderDocument({document, destinationFolder}, assetsController, assetsParams, renderCb);\n    },\n    // write the section to a static html file\n    (html, writeCb)=> {\n      writeFile(path + '/' + motherKey + '.html', html, 'utf-8', writeCb);\n    }\n  ], (err)=> {\n    if (!err) {\n      Prince()\n      .inputs(path + '/' + motherKey + '.html')\n      .output(path + '/' + motherKey + '.pdf')\n      .execute()\n      .then(function() {\n        console.log('saved to pdf with PrinceXML');\n        return finalCallback();\n      }, function(error) {\n        console.log('Prince ERROR: ', error);\n        return finalCallback(error);\n      });\n    } else {\n      console.error('error during rendering to static html : ', err);\n      return finalCallback(err);\n    }\n  });\n};\n"
  },
  {
    "__docId__": 308,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "Prince",
    "memberof": "src/exporters/pdfExporter/index.js",
    "longname": "src/exporters/pdfExporter/index.js~Prince",
    "access": null,
    "export": false,
    "importPath": "peritext/src/exporters/pdfExporter/index.js",
    "importStyle": null,
    "description": "This module inputs a specific peritext section, including possibly its children sections\nand outputs a pdf file ready to display.\nThe converter used is PrinceXML non-commercial version.\nAfter endless trials with free software converters such as wkhtmltopdf, weasyprint or phantomjs-pdf,\nI could not find a way to use a free (gratis & open) tech. to produce & sufficiently reliable and user-customizable pdf output (notably via css3 @paged-media props).\nFor instance, wkhtmltopdf (and webkit-based converters in general) does not support 'float:footnotes' feature which is mandatory for scholarly outputs like peritext's ones\nTherefore I chose proprietary software PrinceXML, which works wonderfully well. It is used in its free version for now (which is why Prince logo is added on the first page, no commercial use license)",
    "lineNumber": 17,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 309,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "exportDocumentToPdf",
    "memberof": "src/exporters/pdfExporter/index.js",
    "longname": "src/exporters/pdfExporter/index.js~exportDocumentToPdf",
    "access": null,
    "export": true,
    "importPath": "peritext/src/exporters/pdfExporter/index.js",
    "importStyle": "{exportDocumentToPdf}",
    "description": "Exports a section representation of a peritext document to a pdf file",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@params",
        "tagValue": "{Object} assetsController - the module to use in order to communicate with assets"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "The params of the export"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.document",
        "description": "the document to export"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.settings",
        "description": "the specific rendering settings to use in order to produce the output"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "params.destinationFolder",
        "description": "where to output the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsParams",
        "description": "the assets parameters to use while communicating with assetsController"
      },
      {
        "nullable": null,
        "types": [
          "function(err:error)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "the possible errors encountered during export"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/peritext.js",
    "memberof": null,
    "longname": "src/peritext.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Peritext library entrypoint\n * @module peritext\n */\n\nimport * as assetsC from './core/controllers/assetsController';\nimport * as contentsC from './core/controllers/contentsController';\nimport * as models from './core/models';\nimport * as parameters from './config/defaultParameters';\nimport componentsFactory from './core/utils/componentsFactory';\nimport * as getters from './core/getters';\n\n/**\n * Exposes assets communication methods\n * @property {Object} assetsController\n */\nexport const assetsController = assetsC;\n/**\n * Exposes contents communication methods\n * @property {Object} contentsController\n */\nexport const contentsController = contentsC;\n/**\n * Exposes peritext default models for metadata, resources, contextualizers, and rendering settings\n * @property {Object} defaultModels\n */\nexport const defaultModels = models;\n/**\n * Exposes default language parameters for includes and templates\n * @property {Object} defaultParameters\n */\nexport const defaultParameters = parameters;\n\n/**\n * Exposes section export to pdf with print renderer function\n * @property {function} exportSectionToPdf\n */\nexport { exportDocumentToPdf } from './exporters/pdfExporter';\n/**\n * Exposes dynqmic rendering modules\n * @property {function} exportSectionToPdf\n */\nexport {\n  renderDocument as renderToDynamicDocument,\n  renderObjectMetadata,\n  resolveDocumentContextualizationsRelations,\n  renderSectionContents\n} from './renderers/renderToDynamicHtml';\n\nexport const renderContents = componentsFactory;\n\nexport const packSection = getters.packSection;\nexport const getSection = getters.getSection;\nexport const getForewords = getters.getForewords;\nexport const getTableOfSections = getters.getTableOfSections;\nexport const getTableOfFigures = getters.getTableOfFigures;\nexport const getResourceContextualizations = getters.getResourceContextualizations;\nexport const getContextualizerContextualizations = getters.getContextualizerContextualizations;\nexport const getGlossary = getters.getGlossary;\nexport const getDocumentMetadata = getters.getDocumentMetadata;\n\nexport {computeReferences} from './core/utils/referenceUtils';\n\nexport {resolveContextualizationImplementation} from './core/resolvers/resolveContextualizations';\n"
  },
  {
    "__docId__": 311,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "assetsController",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~assetsController",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{assetsController}",
    "description": "Exposes assets communication methods",
    "lineNumber": 17,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsController",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "contentsController",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~contentsController",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{contentsController}",
    "description": "Exposes contents communication methods",
    "lineNumber": 22,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "contentsController",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultModels",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~defaultModels",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{defaultModels}",
    "description": "Exposes peritext default models for metadata, resources, contextualizers, and rendering settings",
    "lineNumber": 27,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultModels",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultParameters",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~defaultParameters",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{defaultParameters}",
    "description": "Exposes default language parameters for includes and templates",
    "lineNumber": 32,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultParameters",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "renderContents",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~renderContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{renderContents}",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "packSection",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~packSection",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{packSection}",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getSection",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getSection",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getSection}",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getForewords",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getForewords",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getForewords}",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getTableOfSections",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getTableOfSections",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getTableOfSections}",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getTableOfFigures",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getTableOfFigures",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getTableOfFigures}",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getResourceContextualizations",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getResourceContextualizations",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getResourceContextualizations}",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getContextualizerContextualizations",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getContextualizerContextualizations",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getContextualizerContextualizations}",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getGlossary",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getGlossary",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getGlossary}",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getDocumentMetadata",
    "memberof": "src/peritext.js",
    "longname": "src/peritext.js~getDocumentMetadata",
    "access": null,
    "export": true,
    "importPath": "peritext/src/peritext.js",
    "importStyle": "{getDocumentMetadata}",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/referencers/index.js",
    "memberof": null,
    "longname": "src/referencers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Set of citation style-specific components\n * @module referencers\n */\nimport * as iso690frLib from './iso690fr';\n\n/**\n * ISO 690 style citation - formatted in french language\n * @todo : try to internationalize it from scratch in order to have language-agnostic citation modules ?\n */\nexport const iso690fr = iso690frLib;\n"
  },
  {
    "__docId__": 326,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "iso690fr",
    "memberof": "src/referencers/index.js",
    "longname": "src/referencers/index.js~iso690fr",
    "access": null,
    "export": true,
    "importPath": "peritext/src/referencers/index.js",
    "importStyle": "{iso690fr}",
    "description": "ISO 690 style citation - formatted in french language",
    "lineNumber": 11,
    "todo": [
      ": try to internationalize it from scratch in order to have language-agnostic citation modules ?"
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/referencers/iso690fr.js",
    "memberof": null,
    "longname": "src/referencers/iso690fr.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * iso690 bibliographic norm formatter (lang: fr)\n * @module referencers/iso690fr\n * @todo Not finished resourceType-to-citation mapping (documented properly only books and journal articles - setup a default presentation for others)\n * Doc 1 : http://revues.refer.org/telechargement/fiche-bibliographie.pdf\n * Doc 2 : https://www.mpl.ird.fr/documentation/download/FormBibliog.pdf\n */\n\nimport React, {PropTypes} from 'react';\nimport {InlineCitationModel, BlockCitationModel} from './../core/utils/citationUtils/citationModels.js';\nimport {\n  StructuredPerson,\n  StructuredDate,\n  StructuredParentJournal,\n  StructuredSpan,\n  StructuredPublisher,\n  StructuredCite\n} from './../core/components/';\n\n/**\n * Renders additionnal citation information, such as pages mentions, translations, etc.\n * @param {Object} propsObj - the React element props\n * @return {ReactElement} markup\n */\nconst renderAdditionnal = (propsObj) =>{\n  const details = propsObj.contextualization;\n  if (!details) {\n    return '';\n  }\n  return (\n    <span className=\"peritext-citation-details\">\n      {details.page || details.pages || propsObj.resource.caption || propsObj.resource.note || propsObj.resource.translation || propsObj.resource.original ? ', ' : ''}\n      {details.page ?\n        <span className=\"peritext-citation-quote-pages\">\n        p. {details.page}\n        </span>\n       : ''}\n       {details.pages ?\n        <span className=\"peritext-citation-quote-pages\">\n        pp. {details.pages}\n        </span>\n       : ''}\n       {(details.page || details.pages) && propsObj.resource.caption ? ', ' : ''}\n       {propsObj.resource.caption ?\n        <StructuredSpan htmlClass=\"peritext-citation-comment\" property=\"comment\" value={propsObj.resource.caption} />\n       : ''}\n       {(details.page || details.pages) && propsObj.resource.note ? ', ' : ''}\n       {propsObj.resource.note ?\n        <StructuredSpan htmlClass=\"peritext-citation-comment\" property=\"comment\" value={propsObj.resource.note} />\n       : ''}\n       {propsObj.resource.translation ?\n          <span className=\"peritext-citation-translation\">\n            . Traduction : <q>details.translation</q>\n          </span>\n          : ''\n        }\n       {propsObj.resource.translation ?\n          <span className=\"peritext-citation-original\">\n            . Citation originale : <q>details.original</q>\n          </span>\n          : ''\n        }\n    </span>\n  );\n};\n\n/**\n * Dumb component for rendering a iso690fr block citation\n */\nexport class BlockCitation extends BlockCitationModel {\n  /**\n   * constructor\n   * @param {object} props\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource to build the citation with\n   * @property {object} contextualization - the contextualization to build the citation with\n   */\n  static propTypes = {\n    contextualization: PropTypes.object,\n    resource: PropTypes.object\n  }\n  /**\n   * Renders additionnal citation information, such as pages mentions, translations, etc.\n   */\n  renderAdditionnal = renderAdditionnal;\n  /**\n   * Renders the representation of involved author (from resource), for long citations outputs\n   * @return {ReactElement} markup\n   */\n  renderAuthors() {\n    const pattern = '${lastName:capitals}, ${firstName}';\n    if (this.props.resource.author && this.props.resource.author.length <= 2) {\n\n      return (<span className=\"peritext-citation-authors\">\n          {this.props.resource.author.map((author, index) => {\n            return (\n                <span key={author.id}>\n                  <StructuredPerson resource={author} pattern={pattern} property=\"author\" />\n                  {(index < this.props.resource.author.length - 1) ? ' et ' : ''}\n                </span>\n              );\n          })}\n      </span>);\n    } else if (this.props.resource.author) {\n      return (\n          <span className=\"peritext-citation-authors\">\n            <StructuredPerson resource={this.props.resource.author[0]} pattern={pattern} property=\"author\" />\n            <i className=\"peritext-citation-etal\">et al.</i>\n          </span>\n      );\n    }\n    return '';\n  }\n\n  /**\n   * Renders the complete reference of a resource\n   * @return {ReactElement} markup\n   */\n  renderCompleteReference() {\n    switch (this.props.resource.bibType) {\n    /* case book not set because is default for now\n    case 'book':\n    break;*/\n    case 'article':\n      if (this.props.opCit === true) {\n        return (\n          <span className=\"peritext-citation-detailed-reference-container\">\n            {this.renderAuthors()}, <i className=\"peritext-citation-opcit\">op.cit.</i>\n          </span>\n        );\n      }\n      const pages = (Array.isArray(this.props.resource.pages)) ? this.props.resource.pages : this.props.resource.pages.split('-');\n      return (\n        <span className=\"peritext-citation-detailed-reference-container\">\n          {this.renderAuthors()}\n          <span>. </span>\n          <StructuredCite value={this.props.resource.title} />\n          <span>. </span>\n          <StructuredParentJournal resource={this.props.resource} pattern=\"${journal}, ${date}, vol. ${volume}, n° ${issue}, ISSN : ${issn}\" />\n          {this.props.resource.pages ? ', pp. ' : ''}\n          {this.props.resource.pages ? <StructuredSpan htmlClass=\"peritext-citation-pages-in-publication\" property=\"pageStart\" value={pages[0]} /> : ''}\n          {this.props.resource.pages ? '-' : ''}\n          {this.props.resource.pages ? <StructuredSpan htmlClass=\"peritext-citation-pages-in-publication\" property=\"pageEnd\" value={pages[1]} /> : ''}\n        </span>\n      );\n    default:\n      if (this.props.opCit === true) {\n        return (\n          <span className=\"peritext-citation-detailed-reference-container\">\n            {this.renderAuthors()}, <i className=\"peritext-citation-opcit\">op.cit.</i>\n          </span>\n        );\n      }\n      return (\n        <span className=\"peritext-citation-detailed-reference-container\">\n          {this.renderAuthors()}\n          {this.props.resource.author ? <span>. </span> : ''}\n          <StructuredCite value={this.props.resource.title} />\n          {this.props.resource.edition ? '. ' : ''}\n          {this.props.resource.edition ? <StructuredSpan htmlClass=\"peritext-citation-publication-edition\" property=\"bookEdition\" value={this.props.resource.edition} /> : ''}\n          {this.props.resource.publisher ? '. ' : ''}\n          {this.props.resource.publisher ? <StructuredPublisher resource={this.props.resource} /> : ''}\n          {this.props.resource.year || this.props.resource.date ? ', ' : ''}\n          {this.props.resource.year || this.props.resource.date ? <StructuredSpan htmlClass=\"peritext-citation-publication-edition\" property=\"datePublished\" value={(this.props.resource.year || this.props.resource.date)} /> : ''}\n        </span>\n      );\n    }\n  }\n\n  /**\n   * Renders additionnal reference information (isbn, doi, url)\n   * @return {ReactElement} markup\n   */\n  renderReferenceDecoration() {\n    if (this.props.resource.isbn || this.props.resource.url || this.props.resource.doi) {\n      return (\n        <span className=\"peritext-citation-reference-decoration-container\">\n          {this.props.resource.isbn ? '. ISBN : ' : ''}\n          {this.props.resource.isbn ? <StructuredSpan htmlClass=\"peritext-citation-isbn\" property=\"isbn\" value={this.props.resource.isbn} /> : ''}\n          {this.props.resource.doi ? '. DOI : ' : ''}\n          {this.props.resource.doi ?\n            <a className=\"peritext-citation-doi\" target=\"blank\" itemProp=\"sameAs\" property=\"sameAs\" href={this.props.resource.doi}>\n              {this.props.resource.doi}\n            </a> : ''}\n          {this.props.resource.doi ? '. Accessible en ligne : ' : ''}\n          {this.props.resource.doi ?\n            <a className=\"peritext-citation-url\" target=\"blank\" itemProp=\"url\" property=\"url\" href={this.props.resource.url}>\n              {this.props.resource.url}\n            </a> : ''}\n        </span>\n      );\n    }\n  }\n\n  /**\n   * Renders final markup of the contextualization\n   * @return {ReactElement} markup\n   */\n  renderReference() {\n    return (\n      <span\n        className=\"peritext-citation-reference-container\"\n      >\n        {this.props.ibid === true ?\n          <i\n            className=\"peritext-citation-ibid\"\n          >\n            ibid.\n          </i> : ''}\n        {this.renderCompleteReference()}\n        {this.renderReferenceDecoration()}\n        <span>.</span>\n      </span>\n    );\n  }\n}\n\n\n/**\n * Dumb component for rendering a iso690fr inline citation\n */\nexport class InlineCitation extends InlineCitationModel {\n  /**\n   * constructor\n   * @param {object} props\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * propTypes\n   * @property {object} resource - the resource to build the citation with\n   * @property {object} contextualization - the contextualization to build the citation with\n   */\n  static propTypes = {\n    contextualization: PropTypes.object,\n    resource: PropTypes.object\n  }\n\n  /**\n   * Renders additionnal citation information, such as pages mentions, translations, etc.\n   */\n  renderAdditionnal = renderAdditionnal;\n\n  /**\n   * Renders the representation of involved author (from resource), for short citations outputs\n   * @return {ReactElement} markup\n   */\n  renderAuthors() {\n    if (this.props.resource.author.length <= 2) {\n      return this.props.resource.author.map((author, index) => {\n        return (\n          <span key={author.id} className=\"peritext-citation-authors\">\n            <StructuredPerson resource={author} pattern=\"${lastName:capitals}\" property=\"author\" />\n            {(index < this.props.resource.author.length - 1) ? ' et ' : ''}\n          </span>\n        );\n      });\n    }\n    return (\n        <span className=\"peritext-citation-authors\">\n          <StructuredPerson resource={this.props.resource.author[0]} pattern=\"${lastName:capitals}\" property=\"author\" />\n          <i className=\"peritext-citation-et-al\">et al.</i>\n        </span>\n    );\n  }\n\n  /**\n   * Renders final markup of the contextualization\n   * @return {ReactElement} markup\n   */\n  renderReference() {\n    if (this.props.ibid === true) {\n      return (\n        <span className=\"peritext-citation-brief-reference\">\n          <i\n            className=\"peritext-citation-ibid\"\n          >\n            ibid.\n          </i>\n        </span>\n      );\n    } else if (this.props.opCit === true) {\n      return (\n        <span className=\"peritext-citation-brief-reference\">\n          {this.renderAuthors()}\n          <span>, </span>\n          <i\n            className=\"peritext-citation-opcit\"\n          >\n            op.cit.\n          </i>\n        </span>\n      );\n    } else if (this.props.resource.date !== undefined || this.props.resource.year !== undefined) {\n      const value = this.props.resource.date || this.props.resource.year;\n      return (\n        <span className=\"peritext-citation-brief-reference\">\n          {this.renderAuthors()}\n          <span>, </span>\n          <StructuredDate value={value} modificator=\"year\" />\n          <span className=\"peritext-citation-year-suffix\">{this.props.contextualization.yearSuffix}</span>\n        </span>\n      );\n    }\n    return (\n      <span className=\"peritext-citation-brief-reference\">\n        {this.renderAuthors()}\n      </span>\n    );\n  }\n}\n"
  },
  {
    "__docId__": 328,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "renderAdditionnal",
    "memberof": "src/referencers/iso690fr.js",
    "longname": "src/referencers/iso690fr.js~renderAdditionnal",
    "access": null,
    "export": false,
    "importPath": "peritext/src/referencers/iso690fr.js",
    "importStyle": null,
    "description": "Renders additionnal citation information, such as pages mentions, translations, etc.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "propsObj",
        "description": "the React element props"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "BlockCitation",
    "memberof": "src/referencers/iso690fr.js",
    "longname": "src/referencers/iso690fr.js~BlockCitation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/referencers/iso690fr.js",
    "importStyle": "{BlockCitation}",
    "description": "Dumb component for rendering a iso690fr block citation",
    "lineNumber": 70,
    "interface": false,
    "extends": [
      "src/core/utils/citationUtils/citationModels.js~BlockCitationModel"
    ]
  },
  {
    "__docId__": 330,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#constructor",
    "access": null,
    "description": "constructor",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "props",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 331,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderAuthors",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderAuthors",
    "access": null,
    "description": "Renders the representation of involved author (from resource), for long citations outputs",
    "lineNumber": 96,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 332,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderCompleteReference",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderCompleteReference",
    "access": null,
    "description": "Renders the complete reference of a resource",
    "lineNumber": 125,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 333,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderReferenceDecoration",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderReferenceDecoration",
    "access": null,
    "description": "Renders additionnal reference information (isbn, doi, url)",
    "lineNumber": 180,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 334,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderReference",
    "memberof": "src/referencers/iso690fr.js~BlockCitation",
    "longname": "src/referencers/iso690fr.js~BlockCitation#renderReference",
    "access": null,
    "description": "Renders final markup of the contextualization",
    "lineNumber": 205,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 335,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "InlineCitation",
    "memberof": "src/referencers/iso690fr.js",
    "longname": "src/referencers/iso690fr.js~InlineCitation",
    "access": null,
    "export": true,
    "importPath": "peritext/src/referencers/iso690fr.js",
    "importStyle": "{InlineCitation}",
    "description": "Dumb component for rendering a iso690fr inline citation",
    "lineNumber": 228,
    "interface": false,
    "extends": [
      "src/core/utils/citationUtils/citationModels.js~InlineCitationModel"
    ]
  },
  {
    "__docId__": 336,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/referencers/iso690fr.js~InlineCitation",
    "longname": "src/referencers/iso690fr.js~InlineCitation#constructor",
    "access": null,
    "description": "constructor",
    "lineNumber": 233,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "props",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 337,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderAuthors",
    "memberof": "src/referencers/iso690fr.js~InlineCitation",
    "longname": "src/referencers/iso690fr.js~InlineCitation#renderAuthors",
    "access": null,
    "description": "Renders the representation of involved author (from resource), for short citations outputs",
    "lineNumber": 256,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 338,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "renderReference",
    "memberof": "src/referencers/iso690fr.js~InlineCitation",
    "longname": "src/referencers/iso690fr.js~InlineCitation#renderReference",
    "access": null,
    "description": "Renders final markup of the contextualization",
    "lineNumber": 279,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ReactElement"
      ],
      "spread": false,
      "description": "markup"
    },
    "generator": false
  },
  {
    "__docId__": 339,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/renderers/index.js",
    "memberof": null,
    "longname": "src/renderers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Renderers - pure functions that render peritext contents in a specific data format\n * @module renderers\n */\n\n export {default as renderToStaticHtml} from './renderToStaticHtml/index.js';\n"
  },
  {
    "__docId__": 340,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/renderers/renderToDynamicHtml/index.js",
    "memberof": null,
    "longname": "src/renderers/renderToDynamicHtml/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Render a document to dynamic html\n * @module renderers/renderToDynamicHtml\n */\n\nimport {waterfall} from 'async';\n// import {readFile} from 'fs';\n// import {resolve} from 'path';\n// import React from 'react';\n// import {IntlProvider} from 'react-intl';\n\nimport resolveDataDependencies from './../../core/resolvers/resolveDataDependencies';\nimport {resolveSettings} from './../../core/utils/modelUtils';\nimport {settingsModels} from './../../core/models';\nimport {\n  resolveContextualizationImplementation,\n  resolveContextualizationsRelations\n} from './../../core/resolvers/resolveContextualizations';\nimport {\n  setDynamicSectionContents\n} from './../renderingUtils';\n/*\nimport {\n  StaticDocument\n} from './../../core/components';\n*/\n\n// const defaultStylesPath = './../../config/defaultStyles/';\n\nexport function renderObjectMetadata(document, inputMetaHead) {\n  let metaHead = inputMetaHead;\n  return Object.keys(document.metadata).map(domain => {\n    return Object.keys(document.metadata[domain]).map(key => {\n      if (document.metadata[domain][key] && document.metadata[domain][key].htmlHead) {\n        metaHead += document.metadata[domain][key].htmlHead;\n      }\n    }).join('\\n');\n  }).join('\\n');\n}\n\n\n/**\n * Renders a section representation as a string representation of an html page\n * @param {Object} params - The params of the rendering\n * @param {Object} params.document - the document to render\n * @param {Object} params.settings - the specific rendering settings to use in order to produce the output\n * @param {string} params.destinationFolder - where to output the file\n * @params {Object} assetsController - the module to use in order to communicate with assets\n * @param {Object} assetsParams - the assets parameters to use while communicating with assetsController\n * @param {function(err:error, result:string)} rendererCallback - the possible errors encountered during rendering, and the resulting html data as a string\n */\nexport const renderDocument = ({\n  document,\n  settings = {}\n}, assetsController, assetsParams, rendererCallback) =>{\n\n  // populate rendering params with defaults if needed\n  const finalSettings = resolveSettings(settings, document.metadata.general.bibType.value, settingsModels);\n  // let style = '';\n\n  waterfall([\n    // load default css rules\n    /*\n    (cback) =>{\n      readFile(resolve(__dirname + defaultStylesPath + 'global.css'), (err, contents)=> {\n        if (!err) {\n          style += contents;\n        }\n        cback(err);\n      });\n    // load default @paged-related css rules\n    },\n    */\n    (depCallback) =>{\n      resolveDataDependencies(document, assetsController, assetsParams, false, depCallback);\n    },\n    // build html code\n    (inputDocument,\n      cback) =>{\n      let renderedDocument = Object.assign({}, document); // inputDocument\n      // build final css code (default + user-generated customizers)\n      let style = '';\n      const cssCustomizers = renderedDocument.customizers && renderedDocument.customizers.styles;\n      if (cssCustomizers !== undefined) {\n        for (const name in cssCustomizers) {\n          if (name !== 'screen.css') {\n            style += '\\n\\n' + cssCustomizers[name];\n          }\n        }\n      }\n      // build metadata html head at document level\n      // todo : check if react-helmet renders dublincore metadata properly\n      // (reason why I don't use it at first)\n      let metaHead = '';\n      Object.keys(document.metadata).forEach(domain => {\n        Object.keys(document.metadata[domain]).forEach(key => {\n          if (renderedDocument.metadata[domain][key] && renderedDocument.metadata[domain][key].htmlHead) {\n            metaHead += renderedDocument.metadata[domain][key].htmlHead;\n          }\n        });\n      });\n      renderedDocument.metaHead = renderObjectMetadata(document, metaHead);\n\n      // order contextualizations (ibid/opCit, ...)\n      renderedDocument = resolveContextualizationsRelations(renderedDocument, finalSettings);\n\n      // this renders react components, it is not good\n      renderedDocument = Object.keys(renderedDocument.contextualizations).reduce((doc, contId)=>{\n        return resolveContextualizationImplementation(doc.contextualizations[contId], doc, 'dynamic', finalSettings);\n      }, renderedDocument);\n\n      cback(null, renderedDocument);\n    }\n  ], rendererCallback);\n};\n\nexport function resolveDocumentContextualizationsRelations(document, settings = []) {\n  const finalSettings = resolveSettings(settings, document.metadata.general.bibType.value, settingsModels);\n  return resolveContextualizationsRelations(document, finalSettings);\n}\n\nexport function renderSectionContents(section, settings) {\n  return Object.assign(section, {\n    contents: setDynamicSectionContents(section, 'contents', settings)\n  }, {\n    notes: setDynamicSectionContents(section, 'notes', settings)\n  });\n}\n"
  },
  {
    "__docId__": 341,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "renderObjectMetadata",
    "memberof": "src/renderers/renderToDynamicHtml/index.js",
    "longname": "src/renderers/renderToDynamicHtml/index.js~renderObjectMetadata",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderToDynamicHtml/index.js",
    "importStyle": "{renderObjectMetadata}",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "document",
        "types": [
          "*"
        ]
      },
      {
        "name": "inputMetaHead",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 342,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "renderDocument",
    "memberof": "src/renderers/renderToDynamicHtml/index.js",
    "longname": "src/renderers/renderToDynamicHtml/index.js~renderDocument",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderToDynamicHtml/index.js",
    "importStyle": "{renderDocument}",
    "description": "Renders a section representation as a string representation of an html page",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@params",
        "tagValue": "{Object} assetsController - the module to use in order to communicate with assets"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "The params of the rendering"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.document",
        "description": "the document to render"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.settings",
        "description": "the specific rendering settings to use in order to produce the output"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "params.destinationFolder",
        "description": "where to output the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsParams",
        "description": "the assets parameters to use while communicating with assetsController"
      },
      {
        "nullable": null,
        "types": [
          "function(err:error, result:string)"
        ],
        "spread": false,
        "optional": false,
        "name": "rendererCallback",
        "description": "the possible errors encountered during rendering, and the resulting html data as a string"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "resolveDocumentContextualizationsRelations",
    "memberof": "src/renderers/renderToDynamicHtml/index.js",
    "longname": "src/renderers/renderToDynamicHtml/index.js~resolveDocumentContextualizationsRelations",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderToDynamicHtml/index.js",
    "importStyle": "{resolveDocumentContextualizationsRelations}",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [
      {
        "name": "document",
        "types": [
          "*"
        ]
      },
      {
        "name": "settings",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 344,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "renderSectionContents",
    "memberof": "src/renderers/renderToDynamicHtml/index.js",
    "longname": "src/renderers/renderToDynamicHtml/index.js~renderSectionContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderToDynamicHtml/index.js",
    "importStyle": "{renderSectionContents}",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "params": [
      {
        "name": "section",
        "types": [
          "*"
        ]
      },
      {
        "name": "settings",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 345,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/renderers/renderToStaticHtml/index.js",
    "memberof": null,
    "longname": "src/renderers/renderToStaticHtml/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Render to static html\n * @module renderers/renderToStaticHtml\n */\n\nimport {waterfall} from 'async';\nimport {readFile} from 'fs';\nimport {resolve} from 'path';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport {IntlProvider} from 'react-intl';\n\nimport resolveDataDependencies from './../../core/resolvers/resolveDataDependencies';\nimport {resolveSettings} from './../../core/utils/modelUtils';\nimport {settingsModels} from './../../core/models';\nimport {\n  resolveContextualizationImplementation,\n  resolveContextualizationsRelations\n} from './../../core/resolvers/resolveContextualizations';\nimport {\n  composeRenderedSections,\n  setStaticSectionContents\n} from './../renderingUtils';\nimport {\n  StaticDocument\n} from './../../core/components';\n\nconst defaultStylesPath = './../../config/defaultStyles/';\n\n/**\n * Renders a section representation as a string representation of an html page\n * @param {Object} params - The params of the render\n * @param {Object} params.document - the document to render\n * @param {Object} params.settings - the specific rendering settings to use in order to produce the output\n * @param {string} params.destinationFolder - where to output the file\n * @params {Object} assetsController - the module to use in order to communicate with assets\n * @param {Object} assetsParams - the assets parameters to use while communicating with assetsController\n * @param {function(err:error, result:string)} rendererCallback - the possible errors encountered during rendering, and the resulting html data as a string\n */\nexport const renderDocument = ({\n  document,\n  settings = {}\n}, assetsController, assetsParams, rendererCallback) =>{\n\n  // populate rendering params with defaults if needed\n  const finalSettings = resolveSettings(settings, document.metadata.general.bibType.value, settingsModels);\n  let style = '';\n\n  waterfall([\n    // load default css rules\n    (cback) =>{\n      readFile(resolve(__dirname + defaultStylesPath + 'global.css'), (err, contents)=> {\n        if (!err) {\n          style += contents;\n        }\n        cback(err);\n      });\n    // load default @paged-related css rules\n    }, (cback) =>{\n      readFile(resolve(__dirname + defaultStylesPath + 'page.css'), (err, contents)=> {\n        if (!err) {\n          style += contents;\n        }\n        cback(err);\n      });\n    }, (depCallback) =>{\n      resolveDataDependencies(document, assetsController, assetsParams, true, depCallback);\n    // build html code\n    }, (inputDocument, cback) =>{\n      let renderedDocument = Object.assign({}, inputDocument);\n      // build final css code (default + user-generated customizers)\n      const cssCustomizers = renderedDocument.customizers && renderedDocument.customizers.styles;\n      if (cssCustomizers !== undefined) {\n        for (const name in cssCustomizers) {\n          if (name !== 'screen.css') {\n            style += '\\n\\n' + cssCustomizers[name];\n          }\n        }\n      }\n      // build metadata (todo : check if react-based helmet lib could cover all metadata props like dublincore ones)\n      let metaHead = '<meta name=\"generator\" content=\"peritext\"/>';\n      Object.keys(document.metadata).forEach(domain => {\n        Object.keys(document.metadata[domain]).forEach(key => {\n          if (renderedDocument.metadata[domain][key] && renderedDocument.metadata[domain][key].htmlHead) {\n            metaHead += renderedDocument.metadata[domain][key].htmlHead;\n          }\n        });\n      });\n\n      // order contextualizations (ibid/opCit, ...)\n      renderedDocument = resolveContextualizationsRelations(renderedDocument, finalSettings);\n\n      // resolve contextualizations js representation according to settings\n      renderedDocument.figuresCount = 0;\n\n      renderedDocument = Object.keys(renderedDocument.contextualizations).reduce((doc, contId)=>{\n        return resolveContextualizationImplementation(doc.contextualizations[contId], doc, 'static', finalSettings);\n      }, renderedDocument);\n\n      // transform input js abstraction of contents to a js abstraction specific to rendering settings\n      const sections = renderedDocument.summary.map(sectionKey => {\n        const section1 = renderedDocument.sections[sectionKey];\n        const contents = setStaticSectionContents(section1, 'contents', finalSettings);\n        return Object.assign({}, section1, {contents}, {type: 'contents'});\n      });\n\n      // prepare translations\n      const lang = renderedDocument.metadata.general.language ? renderedDocument.metadata.general.language.value : 'en';\n      const messages = require('./../../../translations/locales/' + lang + '.json');\n      // render sections\n      const {renderedSections, finalStyle} = composeRenderedSections(sections, renderedDocument, finalSettings, style, messages);\n      // render document\n      const renderedContents = ReactDOMServer.renderToStaticMarkup(\n        <IntlProvider locale={lang} messages={messages}>\n          <StaticDocument document={renderedDocument} sections={renderedSections} settings={finalSettings} />\n        </IntlProvider>);\n      const html = `\n<!doctype:html>\n<html>\n  <head>\n    ${metaHead}\n    <style>\n      ${finalStyle}\n    </style>\n  </head>\n  <body>\n    ${renderedContents}\n   </body>\n</html>`.replace(/itemscope=\"\"/g, 'itemscope');\n      cback(null, html);\n    }\n  ], rendererCallback);\n};\n"
  },
  {
    "__docId__": 346,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultStylesPath",
    "memberof": "src/renderers/renderToStaticHtml/index.js",
    "longname": "src/renderers/renderToStaticHtml/index.js~defaultStylesPath",
    "access": null,
    "export": false,
    "importPath": "peritext/src/renderers/renderToStaticHtml/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "renderDocument",
    "memberof": "src/renderers/renderToStaticHtml/index.js",
    "longname": "src/renderers/renderToStaticHtml/index.js~renderDocument",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderToStaticHtml/index.js",
    "importStyle": "{renderDocument}",
    "description": "Renders a section representation as a string representation of an html page",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@params",
        "tagValue": "{Object} assetsController - the module to use in order to communicate with assets"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "The params of the render"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.document",
        "description": "the document to render"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.settings",
        "description": "the specific rendering settings to use in order to produce the output"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "params.destinationFolder",
        "description": "where to output the file"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "assetsParams",
        "description": "the assets parameters to use while communicating with assetsController"
      },
      {
        "nullable": null,
        "types": [
          "function(err:error, result:string)"
        ],
        "spread": false,
        "optional": false,
        "name": "rendererCallback",
        "description": "the possible errors encountered during rendering, and the resulting html data as a string"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/renderers/renderingUtils/index.js",
    "memberof": null,
    "longname": "src/renderers/renderingUtils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * Shared static rendering utils\n * @module renderers/sharedStaticUtils\n */\n\nimport {\n  computeReferences\n} from './../../core/utils/referenceUtils';\nimport {\n  getGlossary,\n} from './../../core/getters';\nimport {\n  StaticFootnote,\n  StaticNotePointer\n} from './../../core/components';\n\n/**\n * Resolves a sections' list against rendering settings by modifying contents, adding output-related pseudo-sections, and updating css styles\n * @param {array} sections - the sections to render\n * @param {Object} document - the document reference\n * @param {Object} settings - the specific rendering settings to use in order to produce the output\n * @param {string} inputStyle - the css style data to use\n * @param {array} messages - the intl messages to use for some sections localization (e.g. : translation of \"Table of contents\")\n * @return {Object} results - an object composed of an array of rendered sections and a string with the updated css styles\n */\nexport const composeRenderedSections = (sections = [], document, settings = {}, inputStyle = '', messages = []) =>{\n  const renderedSections = sections.slice();\n  let style = typeof inputStyle === 'string' ? inputStyle : '';\n  // transform regarding notes display settings\n  if (settings.notesPosition === 'footnotes') {\n    style += `.peritext-static-note-content-container\n            {\n                display: prince-footnote;\n                counter-increment: footnote;\n            }`;\n  } else if (settings.notesPosition === 'document-end') {\n    let noteNumber = 0;\n    const contents = sections.reduce((notes, section2) =>{\n      return notes.concat(section2.notes.map(note =>{\n        return Object.assign(note, {noteNumber: ++noteNumber});\n      }));\n    }, []);\n    if (contents.length) {\n      renderedSections.push({\n        type: 'endnotes',\n        contents,\n        title: messages.end_notes,\n        id: 'peritext-end-notes'\n      });\n    }\n  }\n\n  // handle figures\n  if (settings.figuresPosition === 'document-end') {\n    const figures = sections.reduce((figs, section3)=>{\n      if (section3.figures) {\n        return figs.concat(section3.figures);\n      }\n      return figs;\n    }, []);\n    if (figures.length) {\n      renderedSections.push({\n        type: 'endfigures',\n        contents: figures,\n        title: messages.end_figures,\n        id: 'peritext-end-figures'\n      });\n    }\n  }\n\n  // build references/bibliography\n  if (settings.referenceScope === 'document') {\n    const refs = computeReferences(sections, document, settings);\n    if (refs.length) {\n      renderedSections.push({\n        type: 'references',\n        contents: refs,\n        title: messages.references_title,\n        id: 'peritext-end-references'\n      });\n    }\n  }\n  // handle glossary\n  if (settings.glossaryPosition !== 'none') {\n    // prepare glossary\n    const glossaryData = getGlossary(document);\n    const glossary = {\n      type: 'glossary',\n      contents: glossaryData,\n      title: messages.glossary,\n      id: 'peritext-end-glossary'\n    };\n    if (settings.glossaryPosition === 'begining' && glossary.contents.length) {\n      renderedSections.splice(0, 0, glossary);\n    } else if (glossary.contents.length) {\n      renderedSections.push(glossary);\n    }\n  }\n\n  // handle table of figures\n  if (settings.figuresTablePosition !== 'none') {\n    // making figures table data\n    const figuresTableData = sections.reduce((figures, section4)=> {\n      // 1. take numbered figures\n      const figuresL = section4.contextualizations.filter((cont)=> {\n        return document.contextualizations[cont].figureNumber !== undefined;\n      })\n      .map(contKey => document.contextualizations[contKey])\n      // 2. filter uniques\n      .filter((figure, index, self) => self.findIndex((other) => {\n        return other.figureNumber === figure.figureNumber;\n      }) === index)\n      // 3. make table array\n      .map((cont)=> {\n        return {\n          id: 'peritext-figure-' + cont.figureId,\n          number: cont.figureNumber\n        };\n      });\n      return figures.concat(figuresL);\n    }, []);\n\n    const figuresTable = {\n      type: 'table-of-figures',\n      contents: figuresTableData,\n      title: messages.table_of_figures,\n      id: 'peritext-end-table-of-figures'\n    };\n    if (settings.figuresTablePosition === 'begining' && figuresTable.contents.length) {\n      renderedSections.splice(0, 0, figuresTable);\n    } else if (figuresTable.contents.length) {\n      renderedSections.push(figuresTable);\n    }\n  }\n\n  // handle print table of contents\n  if (settings.contentsTablePosition !== 'none') {\n    const tocData = renderedSections.map((thisSection) => {\n      return {\n        id: thisSection.metadata ? thisSection.metadata.general.id.value : thisSection.id,\n        title: thisSection.metadata ? thisSection.metadata.general.title.value : thisSection.title,\n        level: thisSection.metadata ? thisSection.metadata.general.generalityLevel.value : 0\n      };\n    });\n    const toc = {type: 'table-of-contents', contents: tocData};\n    if (settings.contentsTablePosition === 'begining' && toc.contents.length) {\n      renderedSections.splice(0, 0, toc);\n    } else if (toc.contents.length) {\n      renderedSections.push(toc);\n    }\n  }\n  // handle forewords\n  renderedSections.splice(0, 0, Object.assign({}, document.forewords, {type: 'forewords'}));\n  // handle cover\n  if (settings.showCovers === 'yes') {\n    renderedSections.splice(0, 0, {\n      type: 'front-cover',\n      metadata: document.metadata\n    });\n    renderedSections.push({\n      type: 'back-cover',\n      metadata: document.metadata\n    });\n  }\n  return {\n    renderedSections,\n    finalStyle: style\n  };\n};\n\nconst resolveStaticNode = (inputNode, section, settings) =>{\n  const node = Object.assign({}, inputNode);\n  if (node.tag === 'note') {\n    const note = section.notes.find(thatNote =>{\n      return thatNote.id === node.target;\n    });\n    node.props = {note};\n    if (settings.notesPosition === 'footnotes') {\n      node.tag = StaticFootnote;\n    } else {\n      node.tag = StaticNotePointer;\n    }\n    node.special = true;\n  }\n  if (node.children) {\n    node.children = node.children.map(child =>{\n      return resolveStaticNode(child, section, settings);\n    });\n  }\n  return node;\n};\n\nexport const setStaticSectionContents = (section, key, settings) =>{\n  return section[key].map(node => {\n    return resolveStaticNode(node, section, settings);\n  });\n};\n\nconst resolveDynamicNode = (inputNode, section, settings) =>{\n  const node = Object.assign({}, inputNode);\n  if (node.tag === 'note') {\n    const note = section.notes.find(thatNote =>{\n      return thatNote.id === node.target;\n    });\n    node.props = {note};\n    node.tag = StaticNotePointer;\n    node.special = true;\n  }\n  if (node.children) {\n    node.children = node.children.map(child =>{\n      return resolveDynamicNode(child, section, settings);\n    });\n  }\n  return node;\n};\n\nexport const setDynamicSectionContents = (section, key, settings) =>{\n  return section[key].map(node => {\n    return resolveDynamicNode(node, section, settings);\n  });\n};\n"
  },
  {
    "__docId__": 349,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "composeRenderedSections",
    "memberof": "src/renderers/renderingUtils/index.js",
    "longname": "src/renderers/renderingUtils/index.js~composeRenderedSections",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderingUtils/index.js",
    "importStyle": "{composeRenderedSections}",
    "description": "Resolves a sections' list against rendering settings by modifying contents, adding output-related pseudo-sections, and updating css styles",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "sections",
        "description": "the sections to render"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the document reference"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "the specific rendering settings to use in order to produce the output"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputStyle",
        "description": "the css style data to use"
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "messages",
        "description": "the intl messages to use for some sections localization (e.g. : translation of \"Table of contents\")"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "results - an object composed of an array of rendered sections and a string with the updated css styles"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveStaticNode",
    "memberof": "src/renderers/renderingUtils/index.js",
    "longname": "src/renderers/renderingUtils/index.js~resolveStaticNode",
    "access": null,
    "export": false,
    "importPath": "peritext/src/renderers/renderingUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "setStaticSectionContents",
    "memberof": "src/renderers/renderingUtils/index.js",
    "longname": "src/renderers/renderingUtils/index.js~setStaticSectionContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderingUtils/index.js",
    "importStyle": "{setStaticSectionContents}",
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 352,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resolveDynamicNode",
    "memberof": "src/renderers/renderingUtils/index.js",
    "longname": "src/renderers/renderingUtils/index.js~resolveDynamicNode",
    "access": null,
    "export": false,
    "importPath": "peritext/src/renderers/renderingUtils/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 353,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "setDynamicSectionContents",
    "memberof": "src/renderers/renderingUtils/index.js",
    "longname": "src/renderers/renderingUtils/index.js~setDynamicSectionContents",
    "access": null,
    "export": true,
    "importPath": "peritext/src/renderers/renderingUtils/index.js",
    "importStyle": "{setDynamicSectionContents}",
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 356,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 357,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 358,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 359,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 360,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 361,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 362,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 363,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 364,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 365,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 366,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 367,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 368,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 369,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 370,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 371,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 372,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 373,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 374,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 375,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 376,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 377,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 378,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 379,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 380,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 381,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 382,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 383,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 384,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 385,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 386,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 387,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 388,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 389,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 390,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 391,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 392,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 393,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 394,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 395,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 396,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 397,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 398,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 399,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 400,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 401,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 403,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 404,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 405,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 406,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 407,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 408,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 409,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 410,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "builtinExternal": true
  }
]