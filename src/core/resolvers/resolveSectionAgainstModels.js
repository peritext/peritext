/**
 * Resolver dedicated to resolve sections against metadata models
 * @module resolvers/resolveSectionAgainstModels
 */
import {resolvePropAgainstType} from '../utils/modelUtils';
import {serializeHtmlMeta} from '../resolvers/htmlMetaTemplateSerializer';

/**
 * Consumes and normalize the metadata of a section
 * @param {Object} section - the section to resolve
 * @param {Object} models - the models to use for resolution
 * @return {newErrors: array, newSection: Object} results - the new errors and section generated by resolution
 */
export const resolveSectionAgainstModels = (section, models) => {
  const errors = [];

  // validate metadata
  const sectionId = section.metadata.general.id.value;
  for (const domain in section.metadata) {
    if (section.metadata[domain]) {
      for (const key in section.metadata[domain]) {
        if (section.metadata[domain][key]) {
          const metadata = section.metadata[domain][key];
          const model = models.metadataModels[domain][key];
          if (model) {
            // resolve unicity
            const uniquePb = model.unique === true && Array.isArray(metadata.value) && metadata.value.length > 1;
            if (uniquePb) {
              errors.push({
                type: 'error',
                preciseType: 'invalidMetadata',
                sectionId,
                message: key + ' value was set more than once for section ' + sectionId
              });
              metadata.value = metadata.value[0];
            }

            if (Array.isArray(metadata.value)) {
              metadata.value = metadata.value.map((val)=> {
                if (typeof metadata.value === 'string') {
                  return resolvePropAgainstType(val, model.valueType, model);
                }
                return val;
              });

            }else if (typeof metadata.value === 'string') {
              metadata.value = resolvePropAgainstType(metadata.value, model.valueType, model);
            }

            if (model.headTemplate) {
              metadata.htmlHead = serializeHtmlMeta(metadata, key, model.headTemplate);
            }

          } else {
            errors.push({
              type: 'warning',
              preciseType: 'invalidMetadata',
              sectionId,
              message: domain + ' metadata property ' + key + ' is invalid in section ' + sectionId
            });
          }
        }
      }
    }
  }

  // set defaults
  for (const key in models.metadataModels.general) {
    if (models.metadataModels.general[key].default) {
      const present = section.metadata.general[key];
      if (present === undefined) {
        section.metadata.general[key] = {
          value: models.metadataModels.general[key].default
        };
      }
    }
  }
  return {newErrors: errors, newSection: section};
  // return callback(null, {newErrors: errors, newSection: section});
};
