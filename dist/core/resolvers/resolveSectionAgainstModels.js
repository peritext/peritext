'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveSectionAgainstModels = undefined;

var _modelUtils = require('../utils/modelUtils');

var _htmlMetaTemplateSerializer = require('../resolvers/htmlMetaTemplateSerializer');

/**
 * Consumes and normalize the metadata of a section
 * @param {Object} section - the section to resolve
 * @param {Object} models - the models to use for resolution
 * @return {newErrors: array, newSection: Object} results - the new errors and section generated by resolution
 */
/**
 * Resolver dedicated to resolve sections against metadata models
 * @module resolvers/resolveSectionAgainstModels
 */
var resolveSectionAgainstModels = exports.resolveSectionAgainstModels = function resolveSectionAgainstModels(section, models) {
  var errors = [];

  // validate metadata
  var sectionId = section.metadata.general.id.value;
  for (var domain in section.metadata) {
    if (section.metadata[domain]) {
      for (var key in section.metadata[domain]) {
        if (section.metadata[domain][key]) {
          (function () {
            var metadata = section.metadata[domain][key];
            var model = models.metadataModels[domain][key];
            if (model) {
              // resolve unicity
              var uniquePb = model.unique === true && Array.isArray(metadata.value) && metadata.value.length > 1;
              if (uniquePb) {
                errors.push({
                  type: 'error',
                  preciseType: 'invalidMetadata',
                  sectionId: sectionId,
                  message: key + ' value was set more than once for section ' + sectionId
                });
                metadata.value = metadata.value[0];
              }

              if (Array.isArray(metadata.value)) {
                metadata.value = metadata.value.map(function (val) {
                  if (typeof metadata.value === 'string') {
                    return (0, _modelUtils.resolvePropAgainstType)(val, model.valueType, model);
                  }
                  return val;
                });
              } else if (typeof metadata.value === 'string') {
                metadata.value = (0, _modelUtils.resolvePropAgainstType)(metadata.value, model.valueType, model);
              }

              if (model.headTemplate) {
                metadata.htmlHead = (0, _htmlMetaTemplateSerializer.serializeHtmlMeta)(metadata, key, model.headTemplate);
              }
            } else {
              errors.push({
                type: 'warning',
                preciseType: 'invalidMetadata',
                sectionId: sectionId,
                message: domain + ' metadata property ' + key + ' is invalid in section ' + sectionId
              });
            }
          })();
        }
      }
    }
  }

  // set defaults
  for (var _key in models.metadataModels.general) {
    if (models.metadataModels.general[_key].default) {
      var present = section.metadata.general[_key];
      if (present === undefined) {
        section.metadata.general[_key] = {
          value: models.metadataModels.general[_key].default
        };
      }
    }
  }
  return { newErrors: errors, newSection: section };
  // return callback(null, {newErrors: errors, newSection: section});
};